{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///exsurge.min.js","webpack:///webpack/bootstrap 6f17a1afaaa61ba84253","webpack:///./src/index.js","webpack:///./src/Exsurge.Core.js","webpack:///./src/Exsurge.Text.js","webpack:///./src/Exsurge.Glyphs.js","webpack:///./src/Exsurge.Drawing.js","webpack:///./src/addAccent.js","webpack:///./src/makeLigature.js","webpack:///./src/greextraGlyphs.js","webpack:///./src/Exsurge.Chant.js","webpack:///./src/Exsurge.Chant.ChantLine.js","webpack:///./src/Exsurge.Chant.Markings.js","webpack:///./src/Exsurge.Chant.Signs.js","webpack:///./src/Exsurge.Gabc.js","webpack:///./src/Exsurge.Chant.Neumes.js","webpack:///./src/Exsurge.Titles.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Object","defineProperty","value","_ExsurgeCore","keys","forEach","key","enumerable","get","_ExsurgeText","_ExsurgeGlyphs","_ExsurgeDrawing","_ExsurgeChant","_ExsurgeChantChantLine","_ExsurgeChantMarkings","_ExsurgeChantSigns","_ExsurgeChantNeumes","_ExsurgeGabc","_ExsurgeTitles","_greextraGlyphs","_classCallCheck","instance","Constructor","TypeError","DeviceIndependent","n","Centimeters","Units","ToDeviceIndependent","Millimeters","Inches","ToCentimeters","FromDeviceIndependent","ToMillimeters","ToInches","generateRandomGuid","s4","Math","floor","random","toString","substring","getCssForProperties","properties","entries","map","_ref","_ref2","_slicedToArray","val","join","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","length","err","Array","isArray","_createClass","defineProperties","target","props","descriptor","configurable","writable","protoProps","staticProps","prototype","DeviceIndepenedent","DIU_PER_INCH","DIU_PER_CENTIMETER","inputUnits","outputUnits","StringToUnitsType","s","ToLower","UnitsTypeToString","units","Point","x","y","point","Step","Rect","width","height","Infinity","rect","other","right","max","bottom","min","Margins","left","top","margins","Size","size","Do","Du","Re","Me","Mi","Fa","Fu","So","La","Te","Ti","__StepToStaffPosition","__StaffOffsetToStep","Pitch","step","octave","toInt","pitch","offset","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","Language","name","centerNeume","text","parsedWords","words","split","end","syllabifyWord","English","_Language","_this","getPrototypeOf","startIndex","regexLetter","match","exec","slice","found","index","Latin","_Language2","_this2","diphthongs","possibleDiphthongs","concat","regexVowel","wordExceptions","vowels","vowelsThatMightBeConsonants","muteConsonantsAndF","liquidConsonants","isVowelThatMightBeConsonant","isVowel","word","lookahead","haveLookahead","syllables","haveCompleteSyllable","previousWasVowel","workingString","toLowerCase","startSyllable","makeSyllable","substr","wordLength","cIsVowel","isDiphthong","isMuteConsonantOrF","isLiquidConsonant","Spanish","_Language3","_this3","weakVowels","strongVowels","uDiphthongExceptions","previousIsVowel","previousIsStrongVowel","cIsStrongVowel","isStrongVowel","createSyllable","consonant2","numberOfConsonants","j","d","indexOf","tripthong","endj","findVowelSegment","language","english","latin","spanish","Glyphs","None","paths","type","data","bounds","origin","align","AcuteAccent","GraveAccent","Circle","Semicircle","ReversedSemicircle","Stropha","BeginningAscLiquescent","BeginningDesLiquescent","CustosDescLong","CustosDescShort","CustosLong","CustosShort","DoClef","FaClef","Flat","Mora","Natural","Sharp","OriscusAsc","OriscusDes","OriscusLiquescent","PodatusLower","PodatusUpper","Porrectus1","Porrectus2","Porrectus3","Porrectus4","PunctumCavum","PunctumQuadratum","PunctumQuadratumLiquescent","PunctumQuadratumAscLiquescent","PunctumQuadratumDesLiquescent","PunctumInclinatum","PunctumInclinatumLiquescent","Quilisma","TerminatingAscLiquescent","TerminatingDesLiquescent","VerticalEpisemaAbove","VerticalEpisemaBelow","VirgaLong","VirgaShort","Virgula","_toConsumableArray","arr2","from","getFontFilenameForProperties","arguments","url","italic","bold","replace","MarkupStackFrame","tagName","symbol","ChantNotationElement","Annotations","Annotation","TextLeftRight","Subtitle","Title","Supertitle","TitleTextElement","DropCap","TranslationText","AboveLinesText","ChoralSign","Lyric","LyricArray","LyricType","TextElement","TextSpan","CurlyBraceVisualizer","RoundBraceVisualizer","GlyphVisualizer","LineaVisualizer","VirgaLineVisualizer","NeumeLineVisualizer","DividerLineVisualizer","ChantLayoutElement","ChantContext","TextMeasuringStrategy","QuickSvg","GlyphCode","DefaultTrailingSpace","TextTypesByClass","TextTypes","MarkingPositionHint","_get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getter","_addAccent","_makeLigature","canAccessDOM","document","__getNeumeFromSvgElem","score","elem","note","notes","parentElement","querySelector","getAttribute","neume","Default","Above","Below","supertitle","display","defaultSize","containedInScore","titles","hasSupertitle","getFromScore","title","hasTitle","subtitle","hasSubtitle","leftRight","cssClass","hasTextLeft","hasTextRight","extraClass","getFromSvgElem","classList","contains","annotation","mergeAnnotationWithTextLeft","dropCap","_ref$elementIndex","elementIndex","annotations","al","hasAboveLinesText","notations","notation","notationIndex","alText","alIndex","choralSign","ctxt","staffInterval","lyric","hasLyrics","lyrics","lyricIndex","translation","hasTranslations","translationText","translationIndex","_ref3","entry","intraNeumeSpacing","interSyllabicMultiplier","isDefault","StrophaLiquescent","UpperBrace","ns","xmlns","xlink","hasDOMAccess","svg","node","createElementNS","setAttribute","setAttributeNS","defs","appendChild","clearNotations","removeChild","hasChildNodes","lastChild","line","x1","y1","x2","y2","g","tspan","str","textContent","use","nodeRef","svgFragmentForGlyph","glyph","svgSrc","path","createFragment","fill","nodesForGlyph","functionName","nodes","createNode","attributes","children","source","attr","hasOwnProperty","createSvgTree","_len","_key","className","class","convertKeysToCamelCase","obj","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","test","camelCase","whole","letter","toUpperCase","return","style","sourceGabc","child","fragment","parseFragment","well","createElement","container","innerHTML","il","firstChild","childNodes","translate","scale","sx","sy","Svg","Canvas","OpenTypeJS","textMeasuringStrategy","makeDefs","defsNode","textStyles","textColor","setFont","rubricColor","specialCharProperties","font-family","textBeforeSpecialChar","textAfterSpecialChar","specialCharMap","℣","℟","+","*","plusProperties","asteriskProperties","specialCharText","char","fontStyleDictionary","b","font-weight","font-style","u","text-decoration","ul","sc","font-variant","font-variant-caps","font-feature-settings","-webkit-font-feature-settings","v","markupSymbolDictionary","_","^","%","prefix","padding","minLedgerSeparation","minSpaceAboveStaff","minSpaceBelowStaff","spaceBetweenSystems","glyphPunctumWidth","glyphPunctumHeight","maxExtraSpaceInStaffIntervals","activeClef","neumeLineColor","staffLineColor","dividerLineColor","defaultLanguage","pixelRatio","window","devicePixelRatio","svgTextMeasurer","body","insertBefore","makeCanvasIfNeeded","syllableConnector","scaleDefs","setGlyphScaling","accidentalSpaceMultiplier","interVerbalMultiplier","drawGuides","drawDebuggingBounds","activeNotations","currNotationIndex","minSyllablesLastLine","minNotesLastLine","condensingTolerance","autoColor","useExtraTextOnly","noteIdPrefix","insertFontsInDoc","fontFamily","keyWithFontFamily","fontDictionary","Regular","font","baseStyle","opentypeFontDictionary","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_step2$value","textType","textStyle","color","baseTextStyle","glyphScaling","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_step3$value","_textStyles$key","createStyleCss","hyphen","SingleSyllable","multiplier","minLyricWordSpacing","hyphenWidth","staffHeight","staffLineWeight","ceil","neumeLineWeight","dividerLineWeight","episemaLineWeight","updateHyphenWidth","staffPosition","styleElement","getElementById","head","isNeume","hasNoWidth","canvas","canvasCtxt","getContext","setTransform","selected","highlighted","_ChantLayoutElement","staffPosition0","staffPosition1","divider","y0","calculateHeightFromStaffPosition","temp","fillStyle","fillRect","sourceIndex","getSvgProps","_ChantLayoutElement2","note0","note1","hanging","abs","_ChantLayoutElement3","_this4","_ChantLayoutElement4","_this5","_this6","_this7","apply","_this8","_ChantLayoutElement5","glyphCode","_this9","setGlyph","getDefProps","options","transform","makeDef","makeSvgTree","Path2D","noteIndex","nextNote","isSelected","model","result","xlink:href","glyphVisualizer","getSvgAttributes","_ChantLayoutElement6","isAbove","_this10","braceHeight","generatePathString","stroke","stroke-width","getSvgPathProps","accent","createSvgNode","createSvgFragment","dx","dy","cx1","cy","cx2","dp","toFixed","_ChantLayoutElement7","addAcuteAccent","_this11","union","h","q","qy1","qx2","qy2","tx1","ty1","qy3","qx4","qy4","activeTags","createStackFrame","extraProperties","assign","__subsForTspans","&","<",">","_ChantLayoutElement8","fontSize","textAnchor","_this12","dominantBaseline","generateSpansFromText","recalculateMetrics","_this13","spans","markupStack","spanStartIndex","newLineInNextSpan","filterFrames","frame","closeSpan","spanText","newLine","markupRegex","vTagRegex","openedAsterisk","closeCurrentSpan","_match","_match2","vTag","asterisk","plus","tilde","vowelLigature","specialChar","specialChar2","specialChar3","markupSymbol","closingTag","family","enclosedText","vMatch","lastIndex","iOffset","_vMatch","_vMatch2","grecross","greextra","greextraGlyphs","pop","vowel","makeLigature","addAccent","filter","findIndex","splice","parseFloat","resize","measureSubstring","returnBBox","lines","widths","newLineSpans","subStringLength","numLines","bbox","span","myText","parseInt","rightAligned","xOffset","firstLineMaxWidth","getCanvasFontForProperties","metrics","measureText","actualBoundingBoxLeft","actualBoundingBoxAscent","actualBoundingBoxDescent","getFontForProperties","features","liga","smcp","spanFontSize","subBbox","getPath","getBoundingBox","subWidth","getAdvanceWidth","resetNewLines","maxWidth","createStyleNode","getBBox","measureSubstringBBox","reduce","percentage","lastWidth","lastMatch","regex","_spans","spanIndex","splitSpan","textLeft","textRight","newSpans","needsLayout","textAlign","translateWidth","translateHeight","count","getExtraStyleProperties","fillText","textLength","source-index","getCssClasses","trim","text-anchor","useStyleObject","lengthAdjust","getSpanOptions","extraStyleProperties","svgNode","escapeForTspan","setFontFamilyAttributes","string","String","BeginningSyllable","MiddleSyllable","EndingSyllable","Directive","getLeft","lyricArray","NaN","Number","MAX_VALUE","getRight","presumeConnectorNeeded","MIN_VALUE","l","allowsConnector","needsConnector","getConnectorWidth","hasOnlyOneLyric","originalText","indexOfLyric","mergeIn","newLyrics","mergeInArray","setNotation","_TextElement","lyricType","_this14","centerStartIndex","centerLength","connectorSpan","force","forceConnector","needs","setConnectorWidth","widthWithoutConnector","connectorWidth","defaultConnectorWidth","setNeedsConnector","activeLanguage","vowelSegmentWidth","getSubStringLength","lastIndexOf","dropCapSpan","clone","dropCapLowerCase","dropCapSourceGabcLength","classes","_TextElement2","_this15","positionHint","_TextElement3","_this16","_TextElement4","gabcSource","anchor","_this17","_TextElement5","_this18","_TextElement6","_TitleTextElement","_this20","_TitleTextElement2","_this21","_TitleTextElement3","_this22","_TitleTextElement4","_this23","headerKey","_TextElement7","_this24","_ChantLayoutElement9","_this25","lineHeight","_len2","texts","_key2","updateBounds","draw","_ChantLayoutElement10","_this26","leadingSpace","trailingSpace","keepWithNext","visualizers","chantLayoutElement","ignoreBounds","isEmpty","unshift","calculatedTrailingSpace","_this27","calculateLyricX","inner","getInnerSvgNodes","svgProps","Æ","Œ","A","E","I","O","U","Y","æ","œ","a","e","o","AE","Ae","ae","OE","Oe","oe","MedicaeaFlat","HufnagelCustosUpShort","HufnagelCustosUpLong","HufnagelCustosUpMedium","HufnagelCustosDownShort","HufnagelCustosDownLong","HufnagelCustosDownMedium","MedicaeaCustosUpShort","MedicaeaCustosUpLong","MedicaeaCustosUpMedium","MedicaeaCustosDownShort","MedicaeaCustosDownLong","MedicaeaCustosDownMedium","MensuralCustosUpShort","MensuralCustosUpLong","MensuralCustosUpMedium","MensuralCustosDownShort","MensuralCustosDownLong","MensuralCustosDownMedium","MensuralFlat","HufnagelFlat","MedicaeaCClef","MedicaeaCClefChange","MedicaeaFClef","MedicaeaFClefChange","HufnagelCClef","HufnagelCClefChange","HufnagelFClef","HufnagelFClefChange","HugnagelCFClef","HufnagelCFClefChange","MensuralFlatHole","HufnagelFlatHole","MedicaeaFlatHole","StarSix","Dagger","Bar.alt","StarHeight","Cross","RBar.alt","VBar.alt","Drawing1","Drawing2","RWithBarGoth","VWithBarGoth","Line1","Line2","Line3","Line4","Line5","Cross.alt","ABarCaption","RBarCaption","VBarCaption","ABarCaptionSC","RBarCaptionSC","VBarCaptionSC","ABar","RBar","VBar","ABarSC","RBarSC","VBarSC","ABarSmall","RBarSmall","VBarSmall","ABarSmallSC","RBarSmallSC","VBarSmallSC","RBar.alt2","VBar.alt2","ABarCaptionSlant","RBarCaptionSlant","VBarCaptionSlant","ABarSlant","RBarSlant","VBarSlant","ABarSmallSlant","RBarSmallSlant","VBarSmallSlant","ChantDocument","ChantScore","ChantMapping","ChantLineBreak","TextOnly","Clef","Note","NoteShapeModifiers","NoteShape","LiquescentType","Large","Small","Ascending","Descending","InitioDebilis","LargeAscending","LargeDescending","SmallAscending","SmallDescending","Virga","Inclinatum","Oriscus","Cavum","Stemmed","Linea","Reverse","liquescent","shape","shapeModifiers","episemata","morae","setStaffPosition","shapeModifier","_ChantNotationElement","defaultAccidental","isClef","activeAccidental","performLayout","accidentalGlyph","createGlyphVisualizer","addVisualizer","__defaultDoClef","_Clef","stepToStaffOffset","octaveOffset","staffOffsetToStep","accidentalType","finishLayout","_Clef2","_ChantNotationElement2","sourceLength","__connectorSpan","_ChantNotationElement3","justify","lb","__mergeAnnotationWithTextLeft","annotationSpans","mappings","useDropCap","Titles","startingClef","compiled","autoColoring","updateNotations","startLine","endLine","lastLine","selection","elementSelection","element","indices","selectedIndices","insertion","afterElementIndex","includes","insertionCursor","insertionElement","insertionLine","chantLine","InsertionCursor","mapping","nonNoteElementCount","default","elements","recreateDropCap","generateDropCap","initializeLayout","finishedCallback","setTimeout","onFontLoaded","performLayoutAsync","layoutElementsAsync","timeout","Date","getTime","overrideTextLeft","mapAnnotationSpansToTextLeft","layoutTitles","currIndex","ChantLine","buildFromChantNotationIndex","notationsStartIndex","numNotationsOnLine","pages","updateSelection","pageHeightOffset","startLineIndex","pageHeight","copyLines","setCanvasSize","clearRect","zoom","version","editable","viewBox","cloneNode","createStyleTree","def","createStyle","lineFragment","fragmentDefs","xmlns:xlink","createDropCap","Gabc","parseChantNotations","unsanitizedText","defaults","layout","default-font","font-size","page","margin-left","margin-top","margin-right","margin-bottom","scores","copyLayout","to","unserializeFromJson","serializeToJson","notationBounds","staffLeft","staffRight","custos","ledgerLines","braces","nextLine","previousLine","lyricLineHeight","lyricLineBaseline","numLyricLines","spaceAfterNotations","spaceBetweenTextTracks","lastLyrics","lastNeumeIndex","extraTextOnlyIndex","altLineHeight","altLineBaseline","numAltLines","translationLineHeight","translationLineBaseline","numTranslationLines","notationBoundsOffset","extraTextOnlyHeight","extraTextOnlyLyricIndex","lastNotation","extraLines","lineWidth","lowestPossibleAnnotationY","lyricAndTextRect","altLineTextRect","totalHeight","strokeStyle","beginPath","moveTo","lineTo","layoutInsertionCursor","ledgerLine","functionNames","quickSvg","getInnerNodes","element-index","len","qx1","qx3","newElementStart","beginningLyrics","prev","prevNeume","prevLyrics","condensableSpaces","paddingLeft","DoubleBar","newLyric","elidesToNext","MAX_SAFE_INTEGER","minX","curr","rightNotationBoundary","lastTranslationTextWithEndNeume","lastNotationIndex","lastStartBrace","lastLyricsBeforeTextOnly","textOnlyStartIndex","actualRightBoundary","Custos","isDivider","forceBreak","fitsOnLine","positionNotationElement","candidateForExtraTextOnlyLine","currentLyric","nextNotation","firstOnLine","startExtraTextOnlyFromFirst","lastNotationWithLyrics","reverse","find","lastLyricRight","setMaxWidth","isTextOnlyBeforeDivider","firstDivider","every","notationsAfterBreak","countSyllables","countNotes","flatMap","cne","firstWithNoWidth","allowLineBreakBeforeNext","maxNumNotationsOnLine","findNeumesToJustify","extraSpace","getWhitespaceOnRight","toJustify","sum","condensable","endNeume","last","isLastLine","whitespace","rightEdge","minHyphenWidth","justifyElements","centerDividers","oldBoundsX","barWidth","leftPoint","rightPoint","FullBar","nextOrCurr","isAccidental","lastRightNeume","lastRightLyric","doJustify","extraSpaceBeforeCustos","increment","toJustifyIndex","nextToJustify","incrementOffsetAtNextChance","startBrace","k","startNote","BraceShape","RoundBrace","getAttachmentX","braceEnd","AccentedCurlyBrace","processElementForLedgerLine","endElem","offsetX","half","minY","maxY","positionNonLyricText","rightX","beyondStaffRight","ll","episema","spaceBetweenEpisemata","terminating","alignment","HorizontalEpisemaAlignment","Left","Center","Right","newY","newWidth","handleEndBrace","braceStart","nextNotationButOne","nextNoteButOne","BracePoint","BraceAttachment","space","fixedX","total","maxRight","currLyric","minLeft","firstOfSyllable","hasShifted","atLeastOneWithoutConnector","prevLyricRight","condensableSpacesSincePrevLyric","condensableSpaceSincePrevLyric","notationI","currLyricLeft","shift","spaceBetweenSyls","pLyrics","lastCondensable","useMidpoint","minIndex","maxIndex","curIndex","notationX","closenessToLeft","closenessToRight","Ictus","HorizontalEpisema","Accent","_GlyphVisualizer","minDistanceAway","punctumInclinatumShorten","prevNote","_GlyphVisualizer2","horizontalOffset","collisionWithEpisema","verticalOffset","shortOffset","extraOffset","collisionWithStaffLine","_GlyphVisualizer3","CurlyBrace","attachment","Accidental","AccidentalType","DominicanBar","HalfBar","QuarterBar","Divider","auto","findNextNeume","pitchToStaffPosition","getGlyphCode","resetsAccidentals","_Divider","_Divider2","_Divider3","_Divider4","_Divider5","parity","_Divider6","line0","line1","adjustStep","_Divider7","_interopRequireWildcard","__esModule","newObj","GabcHeader","Markings","Signs","Neumes","__syllablesRegex","__altTranslationRegex","__notationsRegex","__notationsRegex_group_insideBraces","__bracketedCommandRegex","__braceSpecRegex","TrailingSpaceForAccidental","TrailingSpaceMultiple","regexHeaderEnd","regexHeaderLine","regexHeaderComment","comments","cValues","original","txtHeader","arrayName","gabc","alternateKey","array","console","warn","elementCountForNotations","items","item","headerLength","getLength","splitWords","createMappingsFromWords","clef","before","after","oldIndexMap","startOld","startNew","subLength","inew","overlap","_overlap","iold","diffDescriptorsAndNewWords","newGabcSource","insertionIndex","oldInsertionIndex","newWords","results","lastTranslationNeumes","resultCode","resultValues","sourceIndexDiff","elementCount","createMappingFromWord","curNotation","prevIsAccidental","resetDependencies","resetAccidentals","staffPositionToPitch","automatic","needToEndBrace","transText","lastTranslationText","matches","currSyllable","lyricText","pre","main","post","notationData","parseNotations","firstOfParentheses","notationWithLyrics","indexOffset","proposedLyricType","createSyllableLyrics","lyricTexts","_loop","lyricTextWithoutVTags","vtagRegex","vtags","indexClosingBracket","getTrueIndex","indexWithoutVTags","accum","makeLyric","textIndex","centerEndIndex","elides","setForceConnector","baseSourceIndex","addToLastSourceGabc","addNotation","neumes","createNeumesFromNotes","prevNotation","RegExp","atom","gabcHeightToExsurgeHeight","noteArray","createNoteFromData","accidental","gabcHeightToExsurgePitch","bracketedNotations","finalTrailingSpace","firstNoteIndex","currNoteIndex","createNeume","includeCurrNote","lastNoteIndex","includePrevNote","addNote","unknownState","Punctum","handle","currNote","virgaState","apostrophaState","oriscusState","punctaInclinataState","punctumState","notesRemaining","state","ictus","podatusState","climacusState","clivisState","distrophaState","PunctaInclinata","PesQuassus","Clivis","Podatus","salicusState","scandicusState","pesSubpunctisState","torculusState","porrectusState","Climacus","Porrectus","PorrectusFlexus","PesSubpunctis","Salicus","salicusFlexusState","SalicusFlexus","Scandicus","scandicusFlexusState","ScandicusFlexus","bivirgaState","Bivirga","Trivirga","Apostropha","Distropha","tristrophaState","Tristropha","Torculus","prevNoteButOne","torculusResupinusState","TorculusResupinus","TorculusResupinusFlexus","mark","episemaNoteIndex","episemaNote","previousNote","previousMora","episemaHadModifier","newNote","shapeModifers","processInstructionForNote","instruction","sourceIndexOffset","cmd","above","attachmentPoint","gabcNotations","parseWords","gabcWords","parseWord","gabcWord","gabcHeight","charCodeAt","exsurgeHeight","Neume","NeumeBuilder","startingX","lastNote","lineIsHanging","previousNotation","withLineTo","noteAlignsRight","needsLine","linea","noteAt","lowerNote","upperNote","upperGlyph","lowerGlyph","upper","lower","lineFrom","prevStaffPosition","advanceWidth","multiple","start","requiresLedgerLine","positionMarkings","firstAbove","needsAbove","firstBelow","needsBelow","endI","position","positionEpisemata","bottomNote","topNote","positionEpisemataBelow","positionEpisemataAbove","positionPodatusEpisemata","positionPodatusMorae","firstNote","secondNote","thirdNote","hasTopEpisema","positionClivisMarkings","positionClivisMorae","positionClivisEpisemata","positionPodatusMarkings","first","second","third","fourth","_Neume","build","getNoteGlyphCode","_Neume2","virgaAt","advanceBy","_Neume3","_Neume4","positionInclinataMorae","withInclinata","_Neume5","withClivis","_Neume6","glyphCodes","glyphAdvance","_Neume7","nextNoteStaffPosition","_Neume8","lowerStaffPos","upperStaffPos","builder","withLineEndingAt","_Neume9","withPodatus","_Neume10","_Neume11","positionPorrectusMarkings","thirdGlyph","withPorrectusSwash","_Neume12","positionPorrectusFlexusMarkings","fourthGlyph","_Neume13","_Neume14","_Neume15","_Neume16","positionTorculusMarkings","_Neume17","_Neume18","_Neume19","glyph1","glyph3","note2","note3","_Neume20","firstGlyph","_Neume21","fifthGlyph","fifth","_Neume22","_Neume23","setSupertitle","setTitle","setSubtitle","setTextLeft","setTextRight","elementName","setBoundsX","finalY","el","_arr2","_i2","_arr3","_i3"],"mappings":"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","file":"exsurge.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define(\"exsurge\", [], factory);
	else if(typeof exports === 'object')
		exports[\"exsurge\"] = factory();
	else
		root[\"exsurge\"] = factory();
					})(this, function() {
	return
	
	
	// WEBPACK FOOTER //
	// webpack/universalModuleDefinition","
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define(\"exsurge\", [], factory);
	else if(typeof exports === 'object')
		exports[\"exsurge\"] = factory();
	else
		root[\"exsurge\"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = \"\";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	//
	// Author(s):
	// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
	//
	// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the \"Software\"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	//
	
	'use strict';
	
	// import { Annotation, ChantContext } from './Exsurge.Drawing.js'
	// import { Gabc } from './Exsurge.Gabc.js'
	//
	// // client side support
	//
	// if (typeof document !== 'undefined' && document.registerElement) {
	//   var ChantVisualElementPrototype = Object.create(HTMLElement.prototype);
	//
	//   ChantVisualElementPrototype.createdCallback = function() {
	//     var ctxt = new ChantContext();
	//
	//     ctxt.setFont(\"'Crimson Text', serif\", 19.2);
	//
	//     var useDropCap = true;
	//     var useDropCapAttr = this.getAttribute(\"use-drop-cap\");
	//     if (useDropCapAttr === 'false')
	//       useDropCap = false;
	//
	//     var score = Gabc.loadChantScore(ctxt, this.innerText, useDropCap);
	//
	//     var annotationAttr = this.getAttribute(\"annotation\");
	//     if (annotationAttr) {
	//       // add an annotation
	//       score.annotation = new Annotation(ctxt, annotationAttr);
	//     }
	//
	//     var _element = this;
	//
	//     var width = 0;
	//     var doLayout = function() {
	//       var newWidth = _element.parentElement.clientWidth;
	//       if(width === newWidth) return;
	//       width = newWidth;
	//       // perform layout on the chant
	//       score.performLayout(ctxt, function() {
	//         score.layoutChantLines(ctxt, width, function() {
	//           // render the score to svg code
	//           _element.appendElement(score.createSvgNode(ctxt));
	//         });
	//       });
	//     }
	//     doLayout();
	//     if (window.addEventListener)
	//       window.addEventListener('resize',doLayout,false);
	//     else if (window.attachEvent)
	//       window.attachEvent('onresize',doLayout);
	//   }
	//
	//   ChantVisualElementPrototype.attachedCallback = function() {
	//
	//   }
	//
	//   // register the custom element
	//   // if(window.customElements && window.customElements.define) {
	//   //   window.customElements.define('chant-visual', ChantVisualElementPrototype);
	//   // } else {
	//     document.registerElement('chant-visual', {
	//       prototype: ChantVisualElementPrototype
	//     });
	//   // }
	// }
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	
	var _ExsurgeCore = __webpack_require__(1);
	
	Object.keys(_ExsurgeCore).forEach(function (key) {
	  if (key === \"default\" || key === \"__esModule\") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _ExsurgeCore[key];
	    }
	  });
	});
	
	var _ExsurgeText = __webpack_require__(2);
	
	Object.keys(_ExsurgeText).forEach(function (key) {
	  if (key === \"default\" || key === \"__esModule\") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _ExsurgeText[key];
	    }
	  });
	});
	
	var _ExsurgeGlyphs = __webpack_require__(3);
	
	Object.keys(_ExsurgeGlyphs).forEach(function (key) {
	  if (key === \"default\" || key === \"__esModule\") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _ExsurgeGlyphs[key];
	    }
	  });
	});
	
	var _ExsurgeDrawing = __webpack_require__(4);
	
	Object.keys(_ExsurgeDrawing).forEach(function (key) {
	  if (key === \"default\" || key === \"__esModule\") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _ExsurgeDrawing[key];
	    }
	  });
	});
	
	var _ExsurgeChant = __webpack_require__(8);
	
	Object.keys(_ExsurgeChant).forEach(function (key) {
	  if (key === \"default\" || key === \"__esModule\") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _ExsurgeChant[key];
	    }
	  });
	});
	
	var _ExsurgeChantChantLine = __webpack_require__(9);
	
	Object.keys(_ExsurgeChantChantLine).forEach(function (key) {
	  if (key === \"default\" || key === \"__esModule\") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _ExsurgeChantChantLine[key];
	    }
	  });
	});
	
	var _ExsurgeChantMarkings = __webpack_require__(10);
	
	Object.keys(_ExsurgeChantMarkings).forEach(function (key) {
	  if (key === \"default\" || key === \"__esModule\") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _ExsurgeChantMarkings[key];
	    }
	  });
	});
	
	var _ExsurgeChantSigns = __webpack_require__(11);
	
	Object.keys(_ExsurgeChantSigns).forEach(function (key) {
	  if (key === \"default\" || key === \"__esModule\") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _ExsurgeChantSigns[key];
	    }
	  });
	});
	
	var _ExsurgeChantNeumes = __webpack_require__(13);
	
	Object.keys(_ExsurgeChantNeumes).forEach(function (key) {
	  if (key === \"default\" || key === \"__esModule\") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _ExsurgeChantNeumes[key];
	    }
	  });
	});
	
	var _ExsurgeGabc = __webpack_require__(12);
	
	Object.keys(_ExsurgeGabc).forEach(function (key) {
	  if (key === \"default\" || key === \"__esModule\") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _ExsurgeGabc[key];
	    }
	  });
	});
	
	var _ExsurgeTitles = __webpack_require__(14);
	
	Object.keys(_ExsurgeTitles).forEach(function (key) {
	  if (key === \"default\" || key === \"__esModule\") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _ExsurgeTitles[key];
	    }
	  });
	});
	
	var _greextraGlyphs = __webpack_require__(7);
	
	Object.keys(_greextraGlyphs).forEach(function (key) {
	  if (key === \"default\" || key === \"__esModule\") return;
	  Object.defineProperty(exports, key, {
	    enumerable: true,
	    get: function get() {
	      return _greextraGlyphs[key];
	    }
	  });
	});

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	exports.DeviceIndependent = DeviceIndependent;
	exports.Centimeters = Centimeters;
	exports.Millimeters = Millimeters;
	exports.Inches = Inches;
	exports.ToCentimeters = ToCentimeters;
	exports.ToMillimeters = ToMillimeters;
	exports.ToInches = ToInches;
	exports.generateRandomGuid = generateRandomGuid;
	exports.getCssForProperties = getCssForProperties;
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }
	
	//
	// Author(s):
	// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
	//
	// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the \"Software\"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	//
	
	var Units = exports.Units = {
	  // enums
	  DeviceIndepenedent: 0, // device independent units: 96/inch
	  Centimeters: 1,
	  Millimeters: 2,
	  Inches: 3,
	
	  // constants for device independent units (diu)
	  DIU_PER_INCH: 96,
	  DIU_PER_CENTIMETER: 96 / 2.54,
	
	  ToDeviceIndependent: function ToDeviceIndependent(n, inputUnits) {
	    switch (inputUnits) {
	      case Centimeters:
	        return n * Units.DIU_PER_CENTIMETER;
	      case Millimeters:
	        return n * Units.DIU_PER_CENTIMETER / 10;
	      case Inches:
	        return n * Units.DIU_PER_INCH;
	      default:
	        return n;
	    }
	  },
	
	  FromDeviceIndependent: function FromDeviceIndependent(n, outputUnits) {
	    switch (outputUnits) {
	      case Centimeters:
	        return n / Units.DIU_PER_CENTIMETER;
	      case Millimeters:
	        return n / Units.DIU_PER_CENTIMETER * 10;
	      case Inches:
	        return n / Units.DIU_PER_INCH;
	      default:
	        return n;
	    }
	  },
	
	  StringToUnitsType: function StringToUnitsType(s) {
	    switch (s.ToLower()) {
	      case \"in\":
	      case \"inches\":
	        return Units.Inches;
	
	      case \"cm\":
	      case \"centimeters\":
	        return Units.Centimeters;
	
	      case \"mm\":
	      case \"millimeters\":
	        return Units.Millimeters;
	
	      case \"di\":
	      case \"device-independent\":
	        return Units.DeviceIndepenedent;
	
	      default:
	        return Units.DeviceIndepenedent;
	    }
	  },
	
	  UnitsTypeToString: function UnitsTypeToString(units) {
	    switch (units) {
	      case Units.Inches:
	        return \"in\";
	      case Units.Centimeters:
	        return \"cm\";
	      case Units.Millimeters:
	        return \"mm\";
	      case Units.DeviceIndepenedent:
	        return \"device-independent\";
	      default:
	        return \"device-independent\";
	    }
	  }
	};
	
	function DeviceIndependent(n) {
	  return n;
	}
	
	function Centimeters(n) {
	  return Units.ToDeviceIndependent(n, Units.Centimeters);
	}
	
	function Millimeters(n) {
	  return Units.ToDeviceIndependent(n, Units.Millimeters);
	}
	
	function Inches(n) {
	  return Units.ToDeviceIndependent(n, Units.Inches);
	}
	
	function ToCentimeters(n) {
	  return Units.FromDeviceIndependent(n, Units.Centimeters);
	}
	
	function ToMillimeters(n) {
	  return Units.FromDeviceIndependent(n, Units.Millimeters);
	}
	
	function ToInches(n) {
	  return Units.FromDeviceIndependent(n, Units.Inches);
	}
	
	/*
	 * Point
	 */
	
	var Point = exports.Point = function () {
	  function Point(x, y) {
	    _classCallCheck(this, Point);
	
	    this.x = typeof x !== 'undefined' ? x : 0;
	    this.y = typeof y !== 'undefined' ? y : 0;
	  }
	
	  _createClass(Point, [{
	    key: \"clone\",
	    value: function clone() {
	      return new Point(this.x, this.y);
	    }
	  }, {
	    key: \"equals\",
	    value: function equals(point) {
	      return this.x === point.x && this.y === point.y;
	    }
	  }]);
	
	  return Point;
	}();
	
	/*
	 * Rect
	 */
	
	
	var Rect = exports.Rect = function () {
	  function Rect(x, y, width, height) {
	    _classCallCheck(this, Rect);
	
	    this.x = typeof x !== 'undefined' ? x : Infinity;
	    this.y = typeof y !== 'undefined' ? y : Infinity;
	    this.width = typeof width !== 'undefined' ? width : -Infinity;
	    this.height = typeof height !== 'undefined' ? height : -Infinity;
	  }
	
	  _createClass(Rect, [{
	    key: \"clone\",
	    value: function clone() {
	      return new Rect(this.x, this.y, this.width, this.height);
	    }
	  }, {
	    key: \"isEmpty\",
	    value: function isEmpty() {
	      return this.x === Infinity && this.y === Infinity && this.width === -Infinity && this.height === -Infinity;
	    }
	
	    // convenience method
	
	  }, {
	    key: \"right\",
	    value: function right() {
	      return this.x + this.width;
	    }
	  }, {
	    key: \"bottom\",
	    value: function bottom() {
	      return this.y + this.height;
	    }
	  }, {
	    key: \"equals\",
	    value: function equals(rect) {
	      return this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;
	    }
	
	    // other can be a Point or a Rect
	
	  }, {
	    key: \"contains\",
	    value: function contains(other) {
	      if (other instanceof Point) {
	        return other.x >= this.x && other.x <= this.x + this.width && other.y >= this.y && other.y <= this.y + this.height;
	      } else {
	        // better be instance of Rect
	        return this.x <= other.x && this.x + this.width >= other.x + other.width && this.y <= other.y && this.y + this.height >= other.y + other.height;
	      }
	    }
	  }, {
	    key: \"union\",
	    value: function union(rect) {
	
	      var right = Math.max(this.x + this.width, rect.x + rect.width);
	      var bottom = Math.max(this.y + this.height, rect.y + rect.height);
	
	      this.x = Math.min(this.x, rect.x);
	      this.y = Math.min(this.y, rect.y);
	
	      this.width = right - this.x;
	      this.height = bottom - this.y;
	    }
	  }]);
	
	  return Rect;
	}();
	
	/**
	 * Margins
	 *
	 * @class
	 */
	
	
	var Margins = exports.Margins = function () {
	  function Margins(left, top, right, bottom) {
	    _classCallCheck(this, Margins);
	
	    this.left = typeof left !== 'undefined' ? left : 0;
	    this.top = typeof top !== 'undefined' ? top : 0;
	    this.right = typeof right !== 'undefined' ? right : 0;
	    this.bottom = typeof bottom !== 'undefined' ? bottom : 0;
	  }
	
	  _createClass(Margins, [{
	    key: \"clone\",
	    value: function clone() {
	      return new Margins(this.left, this.top, this.right, this.bottom);
	    }
	  }, {
	    key: \"equals\",
	    value: function equals(margins) {
	      return this.left === margins.left && this.top === margins.top && this.right === margins.right && this.bottom === margins.bottom;
	    }
	  }]);
	
	  return Margins;
	}();
	
	/**
	 * Size
	 *
	 * @class
	 */
	
	
	var Size = exports.Size = function () {
	  function Size(width, height) {
	    _classCallCheck(this, Size);
	
	    this.width = typeof width !== 'undefined' ? width : 0;
	    this.height = typeof height !== 'undefined' ? height : 0;
	  }
	
	  _createClass(Size, [{
	    key: \"clone\",
	    value: function clone() {
	      return new Size(this.width, this.height);
	    }
	  }, {
	    key: \"equals\",
	    value: function equals(size) {
	      return this.width === size.width && this.height === size.height;
	    }
	  }]);
	
	  return Size;
	}();
	
	/*
	 * Pitches, notes
	 */
	
	
	var Step = exports.Step = {
	  Do: 0,
	  Du: 1,
	  Re: 2,
	  Me: 3,
	  Mi: 4,
	  Fa: 5,
	  Fu: 6,
	  So: 7,
	  La: 9,
	  Te: 10,
	  Ti: 11
	};
	
	// this little array helps map step values to staff positions. The numeric values of steps
	// correspond to whole step increments (2) or half step increments (1). This gives us the ability
	// to compare pitches precisely, but makes it challenging to place steps on the staff. this little
	// array maps the steps to an incremental position the steps take on the staff line. This works
	// so simply because chant only uses do and fa clefs, and only has a flatted ti (te), making
	// for relatively easy mapping to staff line locations.
	//                         Do Du Re Me Mi Fa Fu So    La Te Ti
	var __StepToStaffPosition = [0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 6, 6];
	var __StaffOffsetToStep = [Step.Do, Step.Re, Step.Mi, Step.Fa, Step.So, Step.La, Step.Ti]; // no accidentals in this one
	
	
	var Pitch = exports.Pitch = function () {
	  function Pitch(step, octave) {
	    _classCallCheck(this, Pitch);
	
	    if (typeof octave === 'undefined') {
	      octave = Math.floor(step / 12);
	      step = step % 12;
	    }
	    this.step = step;
	    this.octave = octave;
	  }
	
	  _createClass(Pitch, [{
	    key: \"toInt\",
	    value: function toInt() {
	      return this.octave * 12 + this.step;
	    }
	  }, {
	    key: \"transpose\",
	    value: function transpose(step) {
	      return new Pitch(this.toInt() + step);
	    }
	  }, {
	    key: \"isHigherThan\",
	    value: function isHigherThan(pitch) {
	      return this.toInt() > pitch.toInt();
	    }
	  }, {
	    key: \"isLowerThan\",
	    value: function isLowerThan(pitch) {
	      return this.toInt() < pitch.toInt();
	    }
	  }, {
	    key: \"equals\",
	    value: function equals(pitch) {
	      return this.toInt() === pitch.toInt();
	    }
	  }], [{
	    key: \"stepToStaffOffset\",
	    value: function stepToStaffOffset(step) {
	      return __StepToStaffPosition[step];
	    }
	  }, {
	    key: \"staffOffsetToStep\",
	    value: function staffOffsetToStep(offset) {
	      while (offset < 0) {
	        offset = __StaffOffsetToStep.length + offset;
	      }return __StaffOffsetToStep[offset % __StaffOffsetToStep.length];
	    }
	  }]);
	
	  return Pitch;
	}();
	
	function generateRandomGuid() {
	  function s4() {
	    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	  }
	  return s4() + s4();
	}
	
	function getCssForProperties(properties) {
	  return Object.entries(properties).map(function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 2),
	        key = _ref2[0],
	        val = _ref2[1];
	
	    return key && val && key !== \"class\" ? key + \": \" + val + \";\" : \"\";
	  }).join(\"\");
	}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }
	
	//
	
	/**
	 * @class
	 */
	var Language = exports.Language = function () {
	  function Language(name) {
	    _classCallCheck(this, Language);
	
	    this.name = typeof name !== \"undefined\" ? name : \"<unknown>\";
	    this.centerNeume = false;
	  }
	
	  /**
	   * @param {String} text The string to parsed into words.
	   * @return {Word[]} the resulting parsed words from syllabification
	   */
	
	
	  _createClass(Language, [{
	    key: \"syllabify\",
	    value: function syllabify(text) {
	      var parsedWords = [];
	
	      if (typeof text === \"undefined\" || text === \"\") return parsedWords;
	
	      // Divide the text into words separated by whitespace
	      var words = text.split(/[\\s]+/);
	
	      for (var i = 0, end = words.length; i < end; i++) {
	        parsedWords.push(this.syllabifyWord(words[i]));
	      }return parsedWords;
	    }
	  }]);
	
	  return Language;
	}();
	
	var English = exports.English = function (_Language) {
	  _inherits(English, _Language);
	
	  function English() {
	    _classCallCheck(this, English);
	
	    var _this = _possibleConstructorReturn(this, (English.__proto__ || Object.getPrototypeOf(English)).call(this, \"English\"));
	
	    _this.centerNeume = true;
	    return _this;
	  }
	
	  /**
	   * @param {String} s the string to search
	   * @param {Number} startIndex The index at which to start searching for a vowel in the string
	   * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}
	   */
	
	
	  _createClass(English, [{
	    key: \"findVowelSegment\",
	    value: function findVowelSegment(s, startIndex) {
	      var regexLetter = /[a-z\\u0300-\\u0311äëïöüÿáéíóúýàèìòùỳāēīōūȳăĕĭŏŭæœ‿]+/i;
	      var match = regexLetter.exec(s.slice(startIndex));
	      if (match) return {
	        found: true,
	        startIndex: startIndex + match.index,
	        length: match[0].length
	      };
	
	      // no vowels sets found after startIndex!
	      return { found: false, startIndex: -1, length: -1 };
	    }
	  }]);
	
	  return English;
	}(Language);
	
	/**
	 * @class
	 */
	
	
	var Latin = exports.Latin = function (_Language2) {
	  _inherits(Latin, _Language2);
	
	  /**
	   * @constructs
	   */
	  function Latin() {
	    _classCallCheck(this, Latin);
	
	    // fixme: ui is only diphthong in the exceptional cases below (according to Wheelock's Latin)
	    var _this2 = _possibleConstructorReturn(this, (Latin.__proto__ || Object.getPrototypeOf(Latin)).call(this, \"Latin\"));
	
	    _this2.diphthongs = [\"ae\", \"au\", \"oe\", \"aé\", \"áu\", \"oé\"];
	    // for centering over the vowel, we will need to know any combinations that might be diphthongs:
	    _this2.possibleDiphthongs = _this2.diphthongs.concat([\"ei\", \"eu\", \"ui\", \"éi\", \"éu\", \"úi\"]);
	    _this2.regexVowel = /(i|(?:[qg]|^)u)?([eé][iu]|[uú]i|[ao][eé]|[aá]u|[aeiouáéíóúäëïöüāēīōūăĕĭŏŭåe̊o̊ůæœǽyýÿ])/i;
	
	    // some words that are simply exceptions to standard syllabification rules!
	    var wordExceptions = new Object();
	
	    // ui combos pronounced as diphthongs
	    wordExceptions[\"huius\"] = [\"hui\", \"us\"];
	    wordExceptions[\"cuius\"] = [\"cui\", \"us\"];
	    wordExceptions[\"huic\"] = [\"huic\"];
	    wordExceptions[\"cui\"] = [\"cui\"];
	    wordExceptions[\"hui\"] = [\"hui\"];
	
	    // eu combos pronounced as diphthongs
	    wordExceptions[\"euge\"] = [\"eu\", \"ge\"];
	    wordExceptions[\"seu\"] = [\"seu\"];
	
	    _this2.vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"á\", \"é\", \"í\", \"ó\", \"ú\", \"ä\", \"ë\", \"ï\", \"ö\", \"ü\", \"ā\", \"ē\", \"ī\", \"ō\", \"ū\", \"ă\", \"ĕ\", \"ĭ\", \"ŏ\", \"ŭ\", \"å\", \"e̊\", \"o̊\", \"ů\", \"æ\", \"œ\", \"ǽ\", // no accented œ in unicode?
	    \"y\", \"ý\", \"ÿ\"]; // y is treated as a vowel; not native to Latin but useful for words borrowed from Greek
	
	    _this2.vowelsThatMightBeConsonants = [\"i\", \"u\"];
	
	    _this2.muteConsonantsAndF = [\"b\", \"c\", \"d\", \"g\", \"p\", \"t\", \"f\"];
	
	    _this2.liquidConsonants = [\"l\", \"r\"];
	    return _this2;
	  }
	
	  // c must be lowercase!
	
	
	  _createClass(Latin, [{
	    key: \"isVowel\",
	    value: function isVowel(c) {
	      for (var i = 0, end = this.vowels.length; i < end; i++) {
	        if (this.vowels[i] === c) return true;
	      }return false;
	    }
	  }, {
	    key: \"isVowelThatMightBeConsonant\",
	    value: function isVowelThatMightBeConsonant(c) {
	      for (var i = 0, end = this.vowelsThatMightBeConsonants.length; i < end; i++) {
	        if (this.vowelsThatMightBeConsonants[i] === c) return true;
	      }return false;
	    }
	
	    // substring should be a vowel and the character following
	
	  }, {
	    key: \"isVowelActingAsConsonant\",
	    value: function isVowelActingAsConsonant(substring) {
	      return this.isVowelThatMightBeConsonant(substring[0]) && this.isVowel(substring[1]);
	    }
	
	    /**
	     * f is not a mute consonant, but we lump it together for syllabification
	     * since it is syntactically treated the same way
	     *
	     * @param {String} c The character to test; must be lowercase
	     * @return {boolean} true if c is an f or a mute consonant
	     */
	
	  }, {
	    key: \"isMuteConsonantOrF\",
	    value: function isMuteConsonantOrF(c) {
	      for (var i = 0, end = this.muteConsonantsAndF.length; i < end; i++) {
	        if (this.muteConsonantsAndF[i] === c) return true;
	      }return false;
	    }
	
	    /**
	     *
	     * @param {String} c The character to test; must be lowercase
	     * @return {boolean} true if c is a liquid consonant
	     */
	
	  }, {
	    key: \"isLiquidConsonant\",
	    value: function isLiquidConsonant(c) {
	      for (var i = 0, end = this.liquidConsonants.length; i < end; i++) {
	        if (this.liquidConsonants[i] === c) return true;
	      }return false;
	    }
	
	    /**
	     *
	     * @param {String} s The string to test; must be lowercase
	     * @return {boolean} true if s is a diphthong
	     */
	
	  }, {
	    key: \"isDiphthong\",
	    value: function isDiphthong(s) {
	      for (var i = 0, end = this.diphthongs.length; i < end; i++) {
	        if (this.diphthongs[i] === s) return true;
	      }return false;
	    }
	
	    /**
	     *
	     * @param {String} s The string to test; must be lowercase
	     * @return {boolean} true if s is a diphthong
	     */
	
	  }, {
	    key: \"isPossibleDiphthong\",
	    value: function isPossibleDiphthong(s) {
	      for (var i = 0, end = this.possibleDiphthongs.length; i < end; i++) {
	        if (this.possibleDiphthongs[i] === s) return true;
	      }return false;
	    }
	
	    /**
	     * Rules for Latin syllabification (from Collins, \"A Primer on Ecclesiastical Latin\")
	     *
	     * Divisions occur when:
	     *   1. After open vowels (those not followed by a consonant) (e.g., \"pi-us\" and \"De-us\")
	     *   2. After vowels followed by a single consonant (e.g., \"vi-ta\" and \"ho-ra\")
	     *   3. After the first consonant when two or more consonants follow a vowel
	     *      (e.g., \"mis-sa\", \"minis-ter\", and \"san-ctus\").
	     *
	     * Exceptions:
	     *   1. In compound words the consonants stay together (e.g., \"de-scribo\").
	     *   2. A mute consonant (b, c, d, g, p, t) or f followed by a liquid consonant (l, r)
	     *      go with the succeeding vowel: \"la-crima\", \"pa-tris\"
	     *
	     * In addition to these rules, Wheelock's Latin provides this sound exception:
	     *   -  Also counted as single consonants are qu and the aspirates ch, ph,
	     *      th, which should never be separated in syllabification:
	     *      architectus, ar-chi-tec-tus; loquacem, lo-qua-cem.
	     *
	     */
	
	  }, {
	    key: \"syllabifyWord\",
	    value: function syllabifyWord(word) {
	      var syllables = [];
	      var haveCompleteSyllable = false;
	      var previousWasVowel = false;
	      var workingString = word.toLowerCase();
	      var startSyllable = 0;
	
	      var c, lookahead, haveLookahead;
	
	      // a helper function to create syllables
	      var makeSyllable = function makeSyllable(length) {
	        if (haveCompleteSyllable) {
	          syllables.push(word.substr(startSyllable, length));
	          startSyllable += length;
	        }
	
	        haveCompleteSyllable = false;
	      };
	
	      for (var i = 0, wordLength = workingString.length; i < wordLength; i++) {
	        c = workingString[i];
	
	        // get our lookahead in case we need them...
	        lookahead = \"*\";
	        haveLookahead = i + 1 < wordLength;
	
	        if (haveLookahead) lookahead = workingString[i + 1];
	
	        var cIsVowel = this.isVowel(c);
	
	        // i is a special case for a vowel. when i is at the beginning
	        // of the word (Iesu) or i is between vowels (alleluia),
	        // then the i is treated as a consonant (y)
	        if (c === \"i\") {
	          if (i === 0 && haveLookahead && this.isVowel(lookahead)) cIsVowel = false;else if (previousWasVowel && haveLookahead && this.isVowel(lookahead)) {
	            cIsVowel = false;
	          }
	        }
	
	        if (c === \"-\") {
	          // a hyphen forces a syllable break, which effectively resets
	          // the logic...
	
	          haveCompleteSyllable = true;
	          previousWasVowel = false;
	          makeSyllable(i - startSyllable);
	          startSyllable++;
	        } else if (cIsVowel) {
	          // once we get a vowel, we have a complete syllable
	          haveCompleteSyllable = true;
	
	          if (previousWasVowel && !this.isDiphthong(workingString[i - 1] + \"\" + c)) {
	            makeSyllable(i - startSyllable);
	            haveCompleteSyllable = true;
	          }
	
	          previousWasVowel = true;
	        } else if (haveLookahead) {
	          if (c === \"q\" && lookahead === \"u\" || lookahead === \"h\" && (c === \"c\" || c === \"p\" || c === \"t\")) {
	            // handle wheelock's exceptions for qu, ch, ph and th
	            makeSyllable(i - startSyllable);
	            i++; // skip over the 'h' or 'u'
	          } else if (previousWasVowel && this.isVowel(lookahead)) {
	            // handle division rule 2
	            makeSyllable(i - startSyllable);
	          } else if (this.isMuteConsonantOrF(c) && this.isLiquidConsonant(lookahead)) {
	            // handle exception 2
	            makeSyllable(i - startSyllable);
	          } else if (haveCompleteSyllable) {
	            // handle division rule 3
	            makeSyllable(i + 1 - startSyllable);
	          }
	
	          previousWasVowel = false;
	        }
	      }
	
	      // if we have a complete syllable, we can add it as a new one. Otherwise
	      // we tack the remaining characters onto the last syllable.
	      if (haveCompleteSyllable) syllables.push(word.substr(startSyllable));else if (startSyllable > 0) syllables[syllables.length - 1] += word.substr(startSyllable);
	
	      return syllables;
	    }
	
	    /**
	     * @param {String} s the string to search
	     * @param {Number} startIndex The index at which to start searching for a vowel in the string
	     * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}
	     */
	
	  }, {
	    key: \"findVowelSegment\",
	    value: function findVowelSegment(s, startIndex) {
	      var match = this.regexVowel.exec(s.slice(startIndex));
	      if (match) {
	        if (match[1]) {
	          // the first group should be ignored, as it is to separate an i or u that is used as a consonant.
	          match.index += match[1].length;
	        }
	        return {
	          found: true,
	          startIndex: startIndex + match.index,
	          length: match[2].length
	        };
	      }
	
	      // no vowels sets found after startIndex!
	      return { found: false, startIndex: -1, length: -1 };
	    }
	  }]);
	
	  return Latin;
	}(Language);
	
	/**
	 * @class
	 */
	
	
	var Spanish = exports.Spanish = function (_Language3) {
	  _inherits(Spanish, _Language3);
	
	  function Spanish() {
	    _classCallCheck(this, Spanish);
	
	    var _this3 = _possibleConstructorReturn(this, (Spanish.__proto__ || Object.getPrototypeOf(Spanish)).call(this, \"Spanish\"));
	
	    _this3.vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"á\", \"é\", \"í\", \"ó\", \"ú\", \"ü\"];
	
	    _this3.weakVowels = [\"i\", \"u\", \"ü\", \"y\"];
	
	    _this3.strongVowels = [\"a\", \"e\", \"o\", \"á\", \"é\", \"í\", \"ó\", \"ú\"];
	
	    _this3.diphthongs = [\"ai\", \"ei\", \"oi\", \"ui\", \"ia\", \"ie\", \"io\", \"iu\", \"au\", \"eu\", \"ou\", \"ua\", \"ue\", \"uo\", \"ái\", \"éi\", \"ói\", \"úi\", \"iá\", \"ié\", \"ió\", \"iú\", \"áu\", \"éu\", \"óu\", \"uá\", \"ué\", \"uó\", \"üe\", \"üi\"];
	
	    _this3.uDiphthongExceptions = [\"gue\", \"gui\", \"qua\", \"que\", \"qui\", \"quo\"];
	    return _this3;
	  }
	
	  // c must be lowercase!
	
	
	  _createClass(Spanish, [{
	    key: \"isVowel\",
	    value: function isVowel(c) {
	      for (var i = 0, end = this.vowels.length; i < end; i++) {
	        if (this.vowels[i] === c) return true;
	      }return false;
	    }
	
	    /**
	     * @param {String} c The character to test; must be lowercase
	     * @return {boolean} true if c is an f or a mute consonant
	     */
	
	  }, {
	    key: \"isWeakVowel\",
	    value: function isWeakVowel(c) {
	      for (var i = 0, end = this.weakVowels.length; i < end; i++) {
	        if (this.weakVowels[i] === c) return true;
	      }return false;
	    }
	
	    /**
	     * @param {String} c The character to test; must be lowercase
	     * @return {boolean} true if c is an f or a mute consonant
	     */
	
	  }, {
	    key: \"isStrongVowel\",
	    value: function isStrongVowel(c) {
	      for (var i = 0, end = this.strongVowels.length; i < end; i++) {
	        if (this.strongVowels[i] === c) return true;
	      }return false;
	    }
	
	    /**
	     *
	     * @param {String} s The string to test; must be lowercase
	     * @return {boolean} true if s is a diphthong
	     */
	
	  }, {
	    key: \"isDiphthong\",
	    value: function isDiphthong(s) {
	      for (var i = 0, end = this.diphthongs.length; i < end; i++) {
	        if (this.diphthongs[i] === s) return true;
	      }return false;
	    }
	  }, {
	    key: \"createSyllable\",
	    value: function createSyllable(text) {
	      /*
	      var accented = false;
	      var ellidesToNext = false;
	       if (text.length > 0) {
	           if (text[0] == '`') {
	              accented = true;
	              text = text.substr(1);
	          }
	           if (text[text.length - 1] == '_') {
	              ellidesToNext = true;
	              text = text.substr(0, text.length - 1);
	          }
	      }
	       var s = new Syllable(text);
	       s.isMusicalAccent = accented;
	      s.elidesToNext = ellidesToNext;*/
	
	      return text;
	    }
	
	    /**
	     */
	
	  }, {
	    key: \"syllabifyWord\",
	    value: function syllabifyWord(word) {
	      var syllables = [];
	
	      var haveCompleteSyllable = false;
	      var previousIsVowel = false;
	      var previousIsStrongVowel = false; // only valid if previousIsVowel == true
	      var startSyllable = 0;
	
	      // fixme: first check for prefixes
	
	      for (var i = 0; i < word.length; i++) {
	        var c = word[i].toLowerCase();
	
	        if (this.isVowel(c)) {
	          // we have a complete syllable as soon as we have a vowel
	          haveCompleteSyllable = true;
	
	          var cIsStrongVowel = this.isStrongVowel(c);
	
	          if (previousIsVowel) {
	            // if we're at a strong vowel, then we finish out the last syllable
	            if (cIsStrongVowel) {
	              if (previousIsStrongVowel) {
	                syllables.push(this.createSyllable(word.substr(startSyllable, i - startSyllable)));
	                startSyllable = i;
	              }
	            }
	          }
	
	          previousIsVowel = true;
	          previousIsStrongVowel = cIsStrongVowel;
	        } else {
	          if (!haveCompleteSyllable) {
	            // do nothing since we don't have a complete syllable yet...
	          } else {
	            // handle explicit syllable breaks
	            if (word[i] === \"-\") {
	              // start new syllable
	              syllables.push(this.createSyllable(word.substr(startSyllable, i - startSyllable)));
	              startSyllable = ++i;
	            } else {
	              var numberOfConsonants = 1,
	                  consonant2;
	
	              // count how many more consonants there are
	              for (var j = i + 1; j < word.length; j++) {
	                if (this.isVowel(word[j])) break;
	                numberOfConsonants++;
	              }
	
	              if (numberOfConsonants === 1) {
	                // start new syllable
	                syllables.push(this.createSyllable(word.substr(startSyllable, i - startSyllable)));
	                startSyllable = i;
	              } else if (numberOfConsonants === 2) {
	                consonant2 = word[i + 1].toLowerCase();
	                if (consonant2 === \"l\" || consonant2 === \"r\" || c === \"c\" && consonant2 === \"h\") {
	                  // split before the consonant pair
	                  syllables.push(this.createSyllable(word.substr(startSyllable, i - startSyllable)));
	                  startSyllable = i++;
	                } else {
	                  //split the consonants
	                  syllables.push(this.createSyllable(word.substr(startSyllable, ++i - startSyllable)));
	                  startSyllable = i;
	                }
	              } else if (numberOfConsonants === 3) {
	                consonant2 = word[i + 1].toLowerCase();
	
	                // if second consonant is s, divide cc-c, otherwise divide c-cc
	                if (consonant2 === \"s\") {
	                  i += 2;
	                  syllables.push(this.createSyllable(word.substr(startSyllable, i - startSyllable)));
	                } else syllables.push(this.createSyllable(word.substr(startSyllable, ++i - startSyllable)));
	
	                startSyllable = i;
	              } else if (numberOfConsonants === 4) {
	                // four always get split cc-cc
	                syllables.push(this.createSyllable(word.substr(startSyllable, i - startSyllable + 2)));
	                startSyllable = i + 2;
	                i += 3;
	              }
	            }
	
	            haveCompleteSyllable = false;
	          }
	
	          previousIsVowel = false;
	        }
	      }
	
	      // if we have a complete syllable, we can add it as a new one. Otherwise
	      // we tack the remaining characters onto the last syllable.
	      if (haveCompleteSyllable) syllables.push(word.substr(startSyllable));else if (startSyllable > 0) syllables[syllables.length - 1] += word.substr(startSyllable);else if (syllables.length === 0) syllables.push(this.createSyllable(word));
	
	      return syllables;
	    }
	
	    /**
	     * @param {String} s the string to search
	     * @param {Number} startIndex The index at which to start searching for a vowel in the string
	     * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}
	     */
	
	  }, {
	    key: \"findVowelSegment\",
	    value: function findVowelSegment(s, startIndex) {
	      var i, end, index;
	      var workingString = s.toLowerCase();
	
	      // do we have a diphthongs?
	      for (i = 0, end = this.diphthongs.length; i < end; i++) {
	        var d = this.diphthongs[i];
	        index = workingString.indexOf(d, startIndex);
	
	        if (index >= 0) {
	          // check the exceptions...
	          if (d[0] === \"u\" && index > 0) {
	            var tripthong = s.substr(index - 1, 3).toLowerCase();
	
	            for (var j = 0, endj = this.uDiphthongExceptions.length; i < endj; j++) {
	              if (tripthong === this.uDiphthongExceptions[j]) {
	                // search from after the u...
	                return this.findVowelSegment(s, index + 1);
	              }
	            }
	          }
	
	          return { found: true, startIndex: index, length: d.length };
	        }
	      }
	
	      // no diphthongs. Let's look for single vowels then...
	      for (i = 0, end = this.vowels.length; i < end; i++) {
	        index = workingString.indexOf(this.vowels[i], startIndex);
	
	        if (index >= 0) return { found: true, startIndex: index, length: 1 };
	      }
	
	      // no vowels sets found after startIndex!
	      return { found: false, startIndex: -1, length: -1 };
	    }
	  }]);
	
	  return Spanish;
	}(Language);
	
	var language = exports.language = {
	  english: new English(),
	  latin: new Latin(),
	  spanish: new Spanish()
	};

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	//
	// Author(s):
	// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
	//
	// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the \"Software\"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	//
	
	// generated based on the svg data
	var Glyphs = exports.Glyphs = {
	  None: {
	    paths: [{
	      type: \"positive\",
	      data: \"\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 0,
	      height: 0
	    },
	    origin: {
	      x: 0,
	      y: 0
	    },
	    align: \"left\"
	  },
	  AcuteAccent: {
	    paths: [{
	      type: \"positive\",
	      data: \"M4 0C-.614.52-.614.52-.803-3.182l60.768-108.422c4.52-7.182 10.543-13.67 18.075-13.67 5.27 0 14.31 1.264 23.346 7.793 7.53 5.223 8.803 11.752 8.803 16.975 0 3.917-.52 11.1-8.05 17.628L4 0z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 0, // TODO: figure out a better way to align this horizontally.  width should be 110.992,
	      height: 125.794
	    },
	    origin: {
	      x: 0.803,
	      y: 125.274
	    },
	    align: \"left\"
	  },
	  GraveAccent: {
	    paths: [{
	      type: \"positive\",
	      data: \"M105.386.26C110 .78 110 .78 110.189-2.922l-60.768-108.422c-4.52-7.182-10.543-13.67-18.075-13.67-5.27 0-14.31 1.264-23.346 7.793-7.53 5.223-8.803 11.752-8.803 16.975 0 3.917.52 11.1 8.05 17.628L105.386.26z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 0, //110.992,
	      height: 125.794
	    },
	    origin: {
	      x: 0, // -110.992,
	      y: 125.274
	    },
	    align: \"left\"
	  },
	  Circle: {
	    paths: [{
	      type: \"positive\",
	      data: \"M0 -50A50 50 0 0 0 100 -50 50 50 0 0 0 0 -50M10 -50A40 40 0 0 1 90 -50 40 40 0 0 1 10 -50\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 100
	    },
	    origin: {
	      x: -50,
	      y: 100
	    }
	  },
	  Semicircle: {
	    paths: [{
	      type: \"positive\",
	      data: \"M0 -50A50 50 0 0 0 100 -50 5 5 0 0 0 90 -50 40 40 0 0 1 10 -50 5 5 0 0 0 0 -50\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 55
	    },
	    origin: {
	      x: -50,
	      y: 50
	    }
	  },
	  ReversedSemicircle: {
	    paths: [{
	      type: \"positive\",
	      data: \"M0 0A50 50 0 0 1 100 0 5 5 0 0 1 90 0 40 40 0 0 0 10 0 5 5 0 0 1 0 0\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 55
	    },
	    origin: {
	      x: -50,
	      y: 50
	    }
	  },
	  Stropha: {
	    paths: [{
	      type: \"positive\",
	      data: \"M1.22-73.438c4.165 13.02 12.238 27.084 24.217 42.188L49.657 0 34.812 27.344C18.666 55.47-.084 72.396-21.438 78.124c4.687-3.645 7.03-8.593 7.03-14.843 0-8.853-4.947-20.572-14.843-35.155L-48 0 1.22-73.438z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 97.657,
	      height: 151.562
	    },
	    origin: {
	      x: 48,
	      y: 73.438
	    },
	    align: \"left\"
	  },
	  BeginningAscLiquescent: {
	    paths: [{
	      type: \"positive\",
	      data: \"M-50 43.688V-61c4.167 7.292 12.76 10.938 25.78 10.938 9.376 0 20.053-1.563 32.032-4.688C31.773-60.48 45.833-71.677 50-88.344v117.97C43.75 42.645 32.812 51.5 17.187 56.186-.52 61.398-15.886 64-28.906 64-42.97 64-50 57.23-50 43.687z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 152.344
	    },
	    origin: {
	      x: 50,
	      y: 88.344
	    },
	    align: \"left\"
	  },
	  BeginningDesLiquescent: {
	    paths: [{
	      type: \"positive\",
	      data: \"M-50-56.03c0-13.022 7.03-19.532 21.094-19.532 13.02 0 28.385 2.604 46.093 7.812C32.813-63.583 43.75-54.73 50-41.187V76C45.833 59.854 31.77 48.656 7.812 42.406c-11.98-3.125-22.656-4.687-32.03-4.687-13.022 0-21.615 3.905-25.782 11.718v-105.47z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 151.562
	    },
	    origin: {
	      x: 50,
	      y: 75.562
	    },
	    align: \"left\"
	  },
	  CustosDescLong: {
	    paths: [{
	      type: \"positive\",
	      data: \"M39.063 273.472c5.73.52 7.29-6.25 4.687-20.312V-65.59c-13.542 2.083-24.22 5.468-32.03 10.156C3.905-50.226 0-43.714 0-35.904V71.91c5.73-5.21 10.677-8.594 14.844-10.157 5.73-1.562 12.24-2.343 19.53-2.343v196.875c0 11.458 1.563 17.187 4.688 17.187\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 46.353,
	      height: 339.582
	    },
	    origin: {
	      x: 0,
	      y: 65.59
	    },
	    align: \"left\"
	  },
	  CustosDescShort: {
	    paths: [{
	      type: \"positive\",
	      data: \"M34.375 191.923c0 8.333 1.563 12.24 4.688 11.72 3.125-.522 4.687-7.033 4.687-19.533v-250c-13.542 2.084-24.22 5.47-32.03 10.157C3.905-50.525 0-44.015 0-36.203V71.61c5.73-5.208 10.677-8.593 14.844-10.156 5.73-1.562 12.24-2.344 19.53-2.344v132.813z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 43.75,
	      height: 270.053
	    },
	    origin: {
	      x: 0,
	      y: 65.89
	    },
	    align: \"left\"
	  },
	  CustosLong: {
	    paths: [{
	      type: \"positive\",
	      data: \"M39.063-269.562c5.73-.52 7.29 6.25 4.687 20.312V69.5c-13.542-2.083-24.22-5.47-32.03-10.156C3.905 54.134 0 47.624 0 39.812V-68c5.73 5.208 10.677 8.594 14.844 10.156 5.73 1.563 12.24 2.344 19.53 2.344v-196.875c0-11.458 1.563-17.187 4.688-17.187z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 46.353,
	      height: 339.582
	    },
	    origin: {
	      x: 0,
	      y: 270.082
	    },
	    align: \"left\"
	  },
	  CustosShort: {
	    paths: [{
	      type: \"positive\",
	      data: \"M34.375-188.125c0-8.333 1.563-12.24 4.688-11.72 3.125.522 4.687 7.033 4.687 19.532v250c-13.542-2.083-24.22-5.468-32.03-10.156C3.905 54.324 0 47.813 0 40V-67.813c5.73 5.21 10.677 8.594 14.844 10.157 5.73 1.562 12.24 2.344 19.53 2.343v-132.812z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 43.75,
	      height: 270.052
	    },
	    origin: {
	      x: 0,
	      y: 200.365
	    },
	    align: \"left\"
	  },
	  DoClef: {
	    paths: [{
	      type: \"positive\",
	      data: \"M0 98.406V-97.688C0-118 5.99-134.275 17.97-146.516c11.978-12.24 27.603-18.36 46.874-18.36 10.937 0 19.53 3.126 25.78 9.376s9.376 14.583 9.376 25v107.813l-6.25-5.47c-4.167-3.645-10.287-7.42-18.36-11.327-8.072-3.907-16.796-5.86-26.17-5.86-11.46 0-21.486 4.427-30.08 13.282-8.593 8.854-12.89 19.53-12.89 32.03s4.297 23.308 12.89 32.423c8.594 9.115 18.62 13.672 30.08 13.672 9.374 0 18.098-1.822 26.17-5.468 8.073-3.646 14.193-7.292 18.36-10.938l6.25-6.25V132c0 9.896-3.125 18.1-9.375 24.61-6.25 6.51-14.844 9.765-25.78 9.765-19.272 0-34.897-6.25-46.876-18.75C5.99 135.125 0 118.72 0 98.405z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 331.251
	    },
	    origin: {
	      x: 0,
	      y: 164.876
	    },
	    align: \"left\"
	  },
	  FaClef: {
	    paths: [{
	      type: \"positive\",
	      data: \"M85.156-32v193.75c0 9.375-1.562 14.323-4.687 14.844-1.564 0-2.605-.52-3.126-1.563-.52-1.04-.782-2.603-.78-4.686V56.28c-8.335-8.332-19.793-12.5-34.376-12.5-17.71 0-31.77 3.907-42.188 11.72V-32c0-18.23 14.193-27.344 42.578-27.344 28.385 0 42.578 9.115 42.578 27.344zM98.438 93V-92.156c0-19.27 5.73-34.896 17.187-46.875 11.458-11.98 26.562-17.97 45.313-17.97 10.937 0 19.14 2.865 24.61 8.594 5.467 5.73 8.202 13.542 8.202 23.437v103.126l-5.47-4.687c-3.645-3.647-9.374-7.293-17.186-10.94-7.813-3.645-15.886-5.467-24.22-5.468-11.978 0-22.004 4.167-30.077 12.5-8.073 8.334-12.11 18.36-12.11 30.08 0 11.717 4.037 22.004 12.11 30.858s18.1 13.28 30.078 13.28c8.333 0 16.406-1.822 24.22-5.468 7.81-3.645 13.54-7.03 17.186-10.156l5.47-5.468V125.81c0 9.896-2.865 17.84-8.594 23.83-5.73 5.988-13.802 8.983-24.22 8.983-18.75 0-33.853-6.12-45.31-18.36-11.46-12.24-17.19-27.994-17.19-47.265z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 193.752,
	      height: 333.595
	    },
	    origin: {
	      x: 0.001,
	      y: 157.001
	    },
	    align: \"left\"
	  },
	  Flat: {
	    paths: [{
	      type: \"positive\",
	      data: \"M7.813-204.406c4.166 0 6.25 5.208 6.25 15.625L12.5-10.657C33.854 13.302 54.167 25.28 73.438 25.28c9.374 0 14.062-4.686 14.062-14.06 0-6.25-1.042-11.72-3.125-16.407-2.083-4.688-7.03-9.766-14.844-15.235-7.81-5.47-13.02-8.984-15.624-10.547L27.344-45.81V-80.97c17.187 0 33.073 4.82 47.656 14.454C89.583-56.88 96.875-47.376 96.875-38c0 67.708-.26 101.562-.78 101.563-38.543 0-69.532-12.24-92.97-36.72C0-52.322-1.042-123.936 0-188c0-10.937 2.604-16.406 7.813-16.406z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 97.917,
	      height: 267.969
	    },
	    origin: {
	      x: 1.042,
	      y: 204.406
	    },
	    align: \"left\"
	  },
	  Mora: {
	    paths: [{
	      type: \"positive\",
	      data: \"M47.478-24c6.957 0 12.793 2.288 17.49 6.883C69.662-12.52 72-6.904 72-.267c0 6.64-2.337 12.352-7.033 17.118C60.27 21.618 54.435 24 47.477 24c-6.26 0-11.748-2.383-16.444-7.15C26.337 12.086 24 6.374 24-.265c0-6.638 2.337-12.255 7.033-16.85C35.73-21.713 41.217-24 47.478-24z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 48,
	      height: 48
	    },
	    origin: {
	      x: -24,
	      y: 24
	    },
	    align: \"left\"
	  },
	  Natural: {
	    paths: [{
	      type: \"positive\",
	      data: \"M7.906-166.563c-2.864 0-5.614.52-8.218 1.563v13.28l.78 56.25.782 78.907v85.157c.52 3.646 2.604 5.73 6.25 6.25l23.438-3.906 23.437-3.907v29.69c0 42.186-.26 63.54-.78 64.06l6.25 2.345c1.04.52 2.082.78 3.124.78 2.603 0 4.947-1.3 7.03-3.905L67.656-71.25c-.52-2.604-2.083-3.906-4.687-3.906-7.814 0-17.19 1.04-28.126 3.125l-19.53 3.124.78-38.28V-165c-2.604-1.042-5.323-1.562-8.188-1.563zM55.938-40v71.875l-41.407 7.03c0-48.436.262-72.655.783-72.655L55.938-40z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 70.311,
	      height: 330.469
	    },
	    origin: {
	      x: 0.312,
	      y: 166.563
	    },
	    align: \"left\"
	  },
	  Sharp: {
	    paths: [{
	      type: \"positive\",
	      data: \"m41.725,-73.773c-5.421,-0.241-10.878,5.856-6.549,12.357L67.061,-20.473 61.264,-12.5 13.436,-71.199c-5.634,-5.934-16.988,1.032-11.232,9.783L50.756,0.182 2.203,61.416c-6.745,7.984 3.442,17.859 11.232,9.783L61.264,12.5l5.797,7.973-31.885,40.943c-5.578,6.844 5.588,16.005 11.594,9.783L77.568,33.154 108.367,71.199c4.894,6.717 17.343,-1.575 11.232,-9.783L87.715,20.473 93.873,12.5 141.34,71.199c6.725,7.67 17.509,-2.248 11.596,-9.783L104.02,0.182 152.936,-61.416c5.52,-7.02-5.541,-16.309-11.596,-9.783L93.873,-12.5l-6.158,-7.973 31.884766,-40.943c5.407,-7.045-5.505,-15.924-11.232,-9.783L77.568,-33.154 46.77,-71.199c-1.435,-1.708-3.238,-2.494-5.044922,-2.574zM77.568,-8.516 84.09,0.182 77.568,8.516 70.684,0.182Z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 154.646,
	      height: 147.987
	    },
	    origin: {
	      x: 0,
	      y: 74.098
	    },
	    align: \"left\"
	  },
	  OriscusAsc: {
	    paths: [{
	      type: \"positive\",
	      data: \"M50 30.25c0 12.5-3.125 21.354-9.375 26.562-3.125 2.605-7.813 3.907-14.063 3.907-3.125 0-5.99-.522-8.593-1.564-2.605-1.04-5.6-2.474-8.986-4.297C5.6 53.035 2.734 51.603.39 50.56c-2.343-1.04-5.338-2.474-8.984-4.296-3.646-1.823-6.77-3.256-9.375-4.297-2.603-1.043-5.468-1.564-8.593-1.564-6.25 0-10.937 1.563-14.062 4.688C-46.875 50.824-50 59.677-50 71.656v-106.25c0-13.02 3.125-21.875 9.375-26.562 3.125-2.604 7.813-3.906 14.063-3.907 3.125 0 5.99.52 8.593 1.563 2.605 1.042 5.73 2.474 9.376 4.297 3.646 1.823 6.51 2.995 8.594 3.516l10.938 5.468c6.25 3.126 11.458 4.69 15.624 4.69 6.25 0 10.938-1.564 14.063-4.69C46.875-55.426 50-64.02 50-76V30.25z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 147.656
	    },
	    origin: {
	      x: 50,
	      y: 76
	    },
	    align: \"left\"
	  },
	  OriscusDes: {
	    paths: [{
	      type: \"positive\",
	      data: \"M-50 30.844v-106.25c0 11.458 3.125 20.052 9.375 25.78 3.125 3.126 7.813 4.69 14.063 4.688 4.687 0 13.41-3.255 26.17-9.765 12.762-6.51 21.746-9.766 26.954-9.766 6.25 0 10.938 1.303 14.063 3.907C46.875-55.874 50-47.02 50-34V72.25c0-11.98-3.125-20.833-9.375-26.563C37.5 42.563 32.812 41 26.562 41 21.875 41 13.023 44.385 0 51.156c-4.167 2.604-8.594 4.948-13.28 7.032-4.69 2.083-9.116 3.124-13.283 3.124-6.25 0-10.937-1.302-14.062-3.906C-46.875 52.198-50 43.344-50 30.844z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 147.656
	    },
	    origin: {
	      x: 50,
	      y: 75.406
	    },
	    align: \"left\"
	  },
	  OriscusLiquescent: {
	    paths: [{
	      type: \"positive\",
	      data: \"M 19.055,78.887 C 20.242,78.487 21.532,77.890 22.925,77.097 24.318,76.304 26.700882,74.417 30.074,71.438 33.447,68.458 36.524,64.985 39.303,61.019 42.083,57.052 44.563,51.396 46.743,44.05 48.923,36.704 50.013,28.671 50.013,19.950525 L 50.013,-34.226 C 50.013,-54.464 42.074,-64.584 26.195,-64.584 20.248,-64.584 11.519,-61.410 0.007,-55.064 -11.506,-48.717 -20.235,-45.544 -26.182,-45.544 -34.515,-45.544 -40.568,-48.520 -44.340791,-54.473 -48.114,-60.426 -50.000,-67.369 -50.000,-75.303 L -50.000,30.07 C -50.000,49.909 -42.060754,59.829 -26.182,59.829 -21.023,59.829 -12.39,56.455 -0.284,49.709 11.822,42.963 20.648,39.59 26.195,39.59 29.369,40.777 30.362,44.25 29.17479,50.009 27.988,55.768 26.001,62.020829 23.216,68.767 z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 147.656
	    },
	    origin: {
	      x: 50,
	      y: 75.406
	    },
	    align: \"left\"
	  },
	  PodatusLower: {
	    paths: [{
	      type: \"positive\",
	      data: \"M-4.688-30.28c22.396 0 34.636-.262 36.72-.782 5.728-1.563 8.593-5.21 8.593-10.938H50v97.656c0 2.604-1.302 4.167-3.906 4.688-5.21.52-21.355.78-48.438.78-23.958 0-38.54-.26-43.75-.78-2.604 0-3.906-1.302-3.906-3.906v-82.032c0-3.646 1.302-5.468 3.906-5.468h2.344c2.604.52 15.625.78 39.063.78z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 103.124
	    },
	    origin: {
	      x: 50,
	      y: 42
	    },
	    align: \"left\"
	  },
	  PodatusUpper: {
	    paths: [{
	      type: \"positive\",
	      data: \"M-46.094-63.78c13.542 0 24.61 2.473 33.203 7.42C-4.298-51.41 0-43.99 0-34.093V62h-9.375c0-10.938-2.604-19.14-7.812-24.61-5.21-5.468-14.844-8.203-28.907-8.202-18.23 0-33.333 4.166-45.312 12.5v-75.782c0-19.79 15.104-29.687 45.312-29.687z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 91.406,
	      height: 125.781
	    },
	    origin: {
	      x: 91.406,
	      y: 63.781
	    },
	    align: \"right\"
	  },
	  Porrectus1: {
	    paths: [{
	      type: \"positive\",
	      data: \"M233.594 162.875c-58.855 0-107.032-6.25-144.53-18.75C34.895 125.895-11.46 99.855-50 66V-52.75C-21.354-24.625 26.302 6.885 92.97 41.78 123.697 57.928 163.54 66 212.5 66c21.354 0 34.635-9.896 39.844-29.688V151.94c0 7.29-6.25 10.937-18.75 10.937z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 302.344,
	      height: 215.627
	    },
	    origin: {
	      x: 50,
	      y: 52.75
	    },
	    align: \"left\"
	  },
	  Porrectus2: {
	    paths: [{
	      type: \"positive\",
	      data: \"M309.375 259.375c-50.52 0-110.938-22.396-181.25-67.188C48.437 141.667-10.938 94.272-50 50V-68.75C0-3.125 60.417 52.083 131.25 96.875c58.333 36.98 110.677 58.854 157.03 65.625h7.033c16.145 0 26.822-9.896 32.03-29.688v114.844c0 7.812-5.99 11.72-17.968 11.72z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 377.343,
	      height: 328.126
	    },
	    origin: {
	      x: 50,
	      y: 68.75
	    },
	    align: \"left\"
	  },
	  Porrectus3: {
	    paths: [{
	      type: \"positive\",
	      data: \"M309.375 355.78c-48.96-16.666-109.115-55.468-180.47-116.405C79.428 198.23 19.793 134.687-50 48.75V-70C20 40 94.104 103.79 135.25 148.063 190 200 230 230 288.28 258.906c4.168 2.083 8.334 3.125 12.5 3.125 12.5 0 21.355-10.937 26.564-32.81v114.06c0 9.376-3.386 14.063-10.156 14.064-2.084 0-4.688-.522-7.813-1.563z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 377.344,
	      height: 427.345
	    },
	    origin: {
	      x: 50,
	      y: 70
	    },
	    align: \"left\"
	  },
	  Porrectus4: {
	    paths: [{
	      type: \"positive\",
	      data: \"M350 453.438c-52.754-22.397-120-77.345-201.74-164.844C90.87 227.656 24.784 147.708-50 48.75V-70C-8.84-1.25 58.406 86.51 151.74 193.28c60.868 69.793 119.13 124.22 174.782 163.282 5.797 3.646 11.014 5.47 15.652 5.47 12.173 0 21.45-11.72 27.826-35.157V441.72c0 9.373-3.19 14.06-9.565 14.06-2.9 0-6.377-.78-10.435-2.342z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 420,
	      height: 525.78
	    },
	    origin: {
	      x: 50,
	      y: 70
	    },
	    align: \"left\"
	  },
	  PunctumCavum: {
	    paths: [{
	      type: \"positive\",
	      data: \"M0-60.906c33.333 0 50 9.635 50 28.906v94.53C39.062 51.595 22.396 46.126 0 46.126s-39.063 5.47-50 16.406V-32c0-19.27 16.667-28.906 50-28.906z\"
	    }, {
	      type: \"negative\",
	      data: \"M.08-42.56c9.585.206 20.126.53 27.954 6.822 4.96 3.9 4.71 10.792 4.574 16.482v51.278C22.09 27.066 7.283 26.072.168 26.01c-7.72.23-21.895.935-32.616 4.674.04-19.197-.083-38.395.064-57.59.567-7.5 7.834-12.33 14.62-13.774 5.818-1.498 11.857-1.86 17.844-1.88z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 123.438
	    },
	    origin: {
	      x: 50,
	      y: 60.906
	    },
	    align: \"left\"
	  },
	  PunctumQuadratum: {
	    paths: [{
	      type: \"positive\",
	      data: \"M0-60.906c33.333 0 50 9.635 50 28.906v94.53C39.062 51.595 22.396 46.126 0 46.126s-39.063 5.47-50 16.406V-32c0-19.27 16.667-28.906 50-28.906z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 123.438
	    },
	    origin: {
	      x: 50,
	      y: 60.906
	    },
	    align: \"left\"
	  },
	  PunctumQuadratumLiquescent: {
	    paths: [{
	      type: \"positive\",
	      data: \"M0-36.5436c19.999799999999997 0 30 5.781 30 17.3436v56.717999999999996C23.437199999999997 30.956999999999997 13.4376 27.6756 0 27.6756s-23.4378 3.2819999999999996-30 9.843599999999999V-19.2c0-11.562 10.000200000000001-17.3436 30-17.3436z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 123.438
	    },
	    origin: {
	      x: 50,
	      y: 60.906
	    },
	    align: \"left\"
	  },
	  PunctumQuadratumAscLiquescent: {
	    paths: [{
	      type: \"positive\",
	      data: \"M-50 43.688V-61c4.167 7.292 12.76 10.938 25.78 10.938 9.376 0 20.053-1.563 32.032-4.688C31.773-60.48 45.833-71.677 50-88.344v117.97C43.75 42.645 32.812 51.5 17.187 56.186-.52 61.398-15.886 64-28.906 64-42.97 64-50 57.23-50 43.687z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 152.344
	    },
	    origin: {
	      x: 50,
	      y: 88.344
	    },
	    align: \"left\"
	  },
	  PunctumQuadratumDesLiquescent: {
	    paths: [{
	      type: \"positive\",
	      data: \"M-50-56.03c0-13.022 7.03-19.532 21.094-19.532 13.02 0 28.385 2.604 46.093 7.812C32.813-63.583 43.75-54.73 50-41.187V76C45.833 59.854 31.77 48.656 7.812 42.406c-11.98-3.125-22.656-4.687-32.03-4.687-13.022 0-21.615 3.905-25.782 11.718v-105.47z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 151.562
	    },
	    origin: {
	      x: 50,
	      y: 75.562
	    },
	    align: \"left\"
	  },
	  PunctumInclinatum: {
	    paths: [{
	      type: \"positive\",
	      data: \"M0-75.78L50 0 0 75-50 0 0-75.78z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 150.78
	    },
	    origin: {
	      x: 50,
	      y: 75.78
	    },
	    align: \"left\"
	  },
	  PunctumInclinatumLiquescent: {
	    paths: [{
	      type: \"positive\",
	      data: \"M 0,-53.164 35,-0.117 0,52.383 -35,-0.117 0,-53.164 z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 105.546
	    },
	    origin: {
	      x: 50,
	      y: 53.164
	    },
	    align: \"left\"
	  },
	  Quilisma: {
	    paths: [{
	      type: \"positive\",
	      data: \"M-50 34.938V-51c5.73 20.833 13.02 31.25 21.875 31.25 7.813 0 12.5-15.625 14.063-46.875 3.645 12.5 6.9 21.224 9.765 26.172s6.9 7.422 12.11 7.422c5.208 0 9.374-14.324 12.5-42.97 5.73 22.917 10.677 34.375 14.843 34.375 5.73 0 10.677-15.885 14.844-47.656v100c0 17.707-3.125 26.56-9.375 26.56-4.688 0-9.115-5.988-13.28-17.968-2.085 21.875-8.074 32.813-17.97 32.813-7.813 0-16.146-7.292-25-21.875-4.688 20.312-10.677 30.47-17.97 30.47-5.207 0-9.244-2.605-12.108-7.814C-48.568 47.698-50 41.708-50 34.938z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 150
	    },
	    origin: {
	      x: 50,
	      y: 89.282
	    },
	    align: \"left\"
	  },
	  TerminatingAscLiquescent: {
	    paths: [{
	      type: \"positive\",
	      data: \"M-9.375 40.22c0-11.98-4.948-17.97-14.844-17.97-10.936 0-19.53 3.646-25.78 10.938v-53.126c0-6.77 2.604-12.76 7.813-17.968 5.208-5.21 10.677-8.594 16.406-10.157 2.603-.52 5.207-.78 7.81-.78 3.647 0 7.032.78 10.157 2.343C-2.603-43.896 0-39.73 0-34V73.03h-9.375V40.22z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 49.999,
	      height: 121.873
	    },
	    origin: {
	      x: 49.999,
	      y: 48.843
	    },
	    align: \"right\"
	  },
	  TerminatingDesLiquescent: {
	    paths: [{
	      type: \"positive\",
	      data: \"M-9.375-48.156V-80.97H0V26.845c0 5.73-2.604 9.896-7.813 12.5-3.125 1.562-6.51 2.343-10.156 2.343-2.603 0-5.207-.26-7.81-.78-5.73-1.563-11.2-4.95-16.407-10.157C-47.398 25.542-50 19.292-50 12v-52.344c6.25 7.292 14.844 10.938 25.78 10.938 9.897 0 14.845-6.25 14.845-18.75z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 50,
	      height: 122.658
	    },
	    origin: {
	      x: 50,
	      y: 80.97
	    },
	    align: \"right\"
	  },
	  VerticalEpisemaAbove: {
	    paths: [{
	      type: \"positive\",
	      data: \"M-8-4c2 3 6 4 8 4s6-1 8-4v-52c-2-3-6-4-8-4s-6 1-8 4z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 16,
	      height: 60
	    },
	    origin: {
	      x: 8,
	      y: 60
	    },
	    align: \"left\"
	  },
	  VerticalEpisemaBelow: {
	    paths: [{
	      type: \"positive\",
	      data: \"M-8 56c2 3 6 4 8 4s6-1 8-4v-52c-2-3-6-4-8-4s-6 1-8 4z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 16,
	      height: 60
	    },
	    origin: {
	      x: 8,
	      y: 0
	    },
	    align: \"left\"
	  },
	  VirgaLong: {
	    paths: [{
	      type: \"positive\",
	      data: \"M50-38v285.156c0 6.77-2.344 10.937-7.03 12.5-1.564 0-2.605-.78-3.126-2.344-.52-1.562-.782-10.156-.782-25.78V54.186C29.168 45.334 16.146 40.907 0 40.907c-22.917 0-39.583 5.208-50 15.624V-38c0-19.27 16.667-28.906 50-28.906S50-57.27 50-38z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 326.562
	    },
	    origin: {
	      x: 50,
	      y: 66.906
	    },
	    align: \"left\"
	  },
	  VirgaShort: {
	    paths: [{
	      type: \"positive\",
	      data: \"M50-38v211.72c0 7.29-2.344 11.457-7.03 12.5-1.564 0-2.606-.783-3.126-2.345-.52-1.563-.782-10.156-.782-25.78V54.187C29.167 45.332 16.146 40.906 0 40.906c-22.917 0-39.583 5.21-50 15.625V-38c0-19.27 16.667-28.906 50-28.906S50-57.27 50-38z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 100,
	      height: 253.126
	    },
	    origin: {
	      x: 50,
	      y: 66.906
	    },
	    align: \"left\"
	  },
	  Virgula: {
	    paths: [{
	      type: \"positive\",
	      data: \"M8.178-55.66c0-22.137 12.092-33.2 36.287-33.2 11.835 0 23.53 5.66 35.108 16.98C91.15-60.547 96.94-41.766 96.94-15.534c0 53.515-31.646 87.487-94.937 101.895-2.048-2.06-3.077-5.146-3.077-9.273 0-1.03.247-1.8.76-2.316 42.71-19.027 64.075-41.678 64.075-67.92 0-11.322-2.325-20.326-6.945-27.016-4.62-6.69-9.52-11.052-14.676-13.11-5.147-2.048-11.836-3.85-20.07-5.403C12.81-39.707 8.18-45.37 8.18-55.66z\"
	    }],
	    bounds: {
	      x: 0,
	      y: 0,
	      width: 98.014,
	      height: 175.221
	    },
	    origin: {
	      x: 1.074,
	      y: 88.86
	    },
	    align: \"left\"
	  }
	};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	exports.ChantNotationElement = exports.Annotations = exports.Annotation = exports.TextLeftRight = exports.Subtitle = exports.Title = exports.Supertitle = exports.TitleTextElement = exports.DropCap = exports.TranslationText = exports.AboveLinesText = exports.ChoralSign = exports.Lyric = exports.LyricArray = exports.LyricType = exports.TextElement = exports.TextSpan = exports.CurlyBraceVisualizer = exports.RoundBraceVisualizer = exports.GlyphVisualizer = exports.LineaVisualizer = exports.VirgaLineVisualizer = exports.NeumeLineVisualizer = exports.DividerLineVisualizer = exports.ChantLayoutElement = exports.ChantContext = exports.TextMeasuringStrategy = exports.QuickSvg = exports.GlyphCode = exports.DefaultTrailingSpace = exports.TextTypesByClass = exports.TextTypes = exports.MarkingPositionHint = undefined;
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); //
	// Author(s):
	// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
	//
	// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the \"Software\"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	//
	
	var _ExsurgeCore = __webpack_require__(1);
	
	var _ExsurgeGlyphs = __webpack_require__(3);
	
	var _ExsurgeText = __webpack_require__(2);
	
	var _addAccent = __webpack_require__(5);
	
	var _makeLigature = __webpack_require__(6);
	
	var _greextraGlyphs = __webpack_require__(7);
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }
	
	function getFontFilenameForProperties() {
	  var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"{}\";
	
	  var italic = properties[\"font-style\"] === \"italic\" ? \"Italic\" : \"\",
	      bold = properties[\"font-weight\"] === \"bold\" ? \"Bold\" : \"\";
	  return url.replace(\"{}\", \"\" + (italic || bold ? \"\" + bold + italic : \"Regular\"));
	}
	
	// load in the web font for special chant characters here:
	// var __exsurgeCharactersFont = require(\"url?limit=30000!../assets/fonts/ExsurgeChar.otf\")
	
	var canAccessDOM = typeof document !== \"undefined\";
	
	var __getNeumeFromSvgElem = function __getNeumeFromSvgElem(score, elem) {
	  var note = score.notes[elem.parentElement.querySelector(\"[element-index]\").getAttribute(\"element-index\")];
	  return note.neume || note;
	};
	
	// for positioning markings on notes
	var MarkingPositionHint = exports.MarkingPositionHint = {
	  Default: 0,
	  Above: 1,
	  Below: 2
	};
	
	/**
	 * List of types of text and their defaults relative to lyrics
	 * @type Array
	 */
	var TextTypes = exports.TextTypes = {
	  supertitle: {
	    display: \"Supertitle\",
	    defaultSize: function defaultSize(size) {
	      return size * 7 / 6;
	    }, // 14pt
	    containedInScore: function containedInScore(score) {
	      return score.titles.hasSupertitle();
	    },
	    getFromScore: function getFromScore(score) {
	      return score.titles.supertitle;
	    }
	  },
	  title: {
	    display: \"Title\",
	    defaultSize: function defaultSize(size) {
	      return size * 3 / 2;
	    }, // 18pt
	    containedInScore: function containedInScore(score) {
	      return score.titles.hasTitle();
	    },
	    getFromScore: function getFromScore(score) {
	      return score.titles.title;
	    }
	  },
	  subtitle: {
	    display: \"Subtitle\",
	    defaultSize: function defaultSize(size) {
	      return size;
	    }, // 12pt
	    containedInScore: function containedInScore(score) {
	      return score.titles.hasSubtitle();
	    },
	    getFromScore: function getFromScore(score) {
	      return score.titles.subtitle;
	    }
	  },
	  leftRight: {
	    display: \"Left / Right Text\",
	    cssClass: \"textLeftRight\",
	    defaultSize: function defaultSize(size) {
	      return size * 0.9;
	    },
	    containedInScore: function containedInScore(score) {
	      return score.titles.hasTextLeft() || score.titles.hasTextRight();
	    },
	    getFromScore: function getFromScore(score, elem) {
	      return score.titles[elem.extraClass];
	    },
	    getFromSvgElem: function getFromSvgElem(score, elem) {
	      return score.titles[elem.classList.contains(\"textRight\") ? \"textRight\" : \"textLeft\"];
	    }
	  },
	  annotation: {
	    display: \"Annotation\",
	    defaultSize: function defaultSize(size) {
	      return size * 2 / 3;
	    },
	    containedInScore: function containedInScore(score) {
	      return !!score.annotation && (!score.mergeAnnotationWithTextLeft || score.dropCap);
	    },
	    getFromScore: function getFromScore(score, _ref) {
	      var _ref$elementIndex = _ref.elementIndex,
	          elementIndex = _ref$elementIndex === undefined ? 0 : _ref$elementIndex;
	      return score.annotation && (score.annotation.annotations ? score.annotation.annotations[elementIndex] : score.annotation);
	    }
	  },
	  dropCap: {
	    display: \"Drop Cap\",
	    defaultSize: function defaultSize(size) {
	      return size * 4;
	    },
	    containedInScore: function containedInScore(score) {
	      return !!score.dropCap;
	    },
	    getFromScore: function getFromScore(score) {
	      return score.dropCap;
	    }
	  },
	  al: {
	    display: \"Above Staff\",
	    cssClass: \"aboveLinesText\",
	    defaultSize: function defaultSize(size) {
	      return size;
	    },
	    containedInScore: function containedInScore(score) {
	      return score.hasAboveLinesText;
	    },
	    getFromScore: function getFromScore(score, elem) {
	      return score.notations[elem.notation.notationIndex].alText[elem.alIndex];
	    },
	    getFromSvgElem: function getFromSvgElem(score, elem) {
	      return __getNeumeFromSvgElem(score, elem).alText[elem.getAttribute(\"al-index\") || 0];
	    }
	  },
	  choralSign: {
	    display: \"Choral Sign\",
	    size: function size(ctxt) {
	      return ctxt.staffInterval * 1.5;
	    },
	    containedInScore: function containedInScore(score) {
	      return false;
	    },
	    getFromScore: function getFromScore(score, elem) {
	      return score.notes[elem.note.elementIndex].choralSign;
	    }
	  },
	  lyric: {
	    display: \"Lyric\",
	    defaultSize: function defaultSize(size) {
	      return size * 0.9;
	    },
	    containedInScore: function containedInScore(score) {
	      return score.hasLyrics;
	    },
	    getFromScore: function getFromScore(score, elem) {
	      return score.notations[elem.notation.notationIndex].lyrics[elem.lyricIndex];
	    },
	    getFromSvgElem: function getFromSvgElem(score, elem) {
	      return __getNeumeFromSvgElem(score, elem).lyrics[elem.getAttribute(\"lyric-index\") || 0];
	    }
	  },
	  translation: {
	    display: \"Translation\",
	    defaultSize: function defaultSize(size) {
	      return size * 0.75;
	    },
	    containedInScore: function containedInScore(score) {
	      return score.hasTranslations;
	    },
	    getFromScore: function getFromScore(score, elem) {
	      return score.notations[elem.notation.notationIndex].translationText[elem.translationIndex];
	    },
	    getFromSvgElem: function getFromSvgElem(score, elem) {
	      return __getNeumeFromSvgElem(score, elem).translationText[elem.getAttribute(\"translation-index\") || 0];
	    }
	  }
	};
	var TextTypesByClass = exports.TextTypesByClass = {};
	Object.entries(TextTypes).forEach(function (_ref2) {
	  var _ref3 = _slicedToArray(_ref2, 2),
	      key = _ref3[0],
	      entry = _ref3[1];
	
	  var cssClass = entry.cssClass = entry.cssClass || key;
	  entry.key = key;
	  TextTypesByClass[cssClass] = entry;
	});
	
	var DefaultTrailingSpace = exports.DefaultTrailingSpace = function DefaultTrailingSpace(ctxt) {
	  return ctxt.intraNeumeSpacing * ctxt.interSyllabicMultiplier;
	};
	DefaultTrailingSpace.isDefault = true;
	
	var GlyphCode = exports.GlyphCode = {
	  None: \"None\",
	
	  AcuteAccent: \"AcuteAccent\",
	  GraveAccent: \"GraveAccent\",
	  Circle: \"Circle\",
	  Semicircle: \"Semicircle\",
	  ReversedSemicircle: \"ReversedSemicircle\",
	  Stropha: \"Stropha\",
	  StrophaLiquescent: \"StrophaLiquescent\",
	
	  BeginningAscLiquescent: \"BeginningAscLiquescent\",
	  BeginningDesLiquescent: \"BeginningDesLiquescent\",
	
	  CustosDescLong: \"CustosDescLong\",
	  CustosDescShort: \"CustosDescShort\",
	  CustosLong: \"CustosLong\",
	  CustosShort: \"CustosShort\",
	
	  // clefs and other markings
	  DoClef: \"DoClef\",
	  FaClef: \"FaClef\",
	  Flat: \"Flat\",
	  Mora: \"Mora\",
	  Natural: \"Natural\",
	  OriscusAsc: \"OriscusAsc\",
	  OriscusDes: \"OriscusDes\",
	  OriscusLiquescent: \"OriscusLiquescent\",
	
	  PodatusLower: \"PodatusLower\",
	  PodatusUpper: \"PodatusUpper\",
	
	  Porrectus1: \"Porrectus1\", // 1 staff line difference,
	  Porrectus2: \"Porrectus2\", // 2 lines difference, etc...
	  Porrectus3: \"Porrectus3\",
	  Porrectus4: \"Porrectus4\",
	
	  PunctumCavum: \"PunctumCavum\",
	  PunctumQuadratum: \"PunctumQuadratum\",
	  PunctumQuadratumLiquescent: \"PunctumQuadratumLiquescent\",
	  PunctumQuadratumAscLiquescent: \"PunctumQuadratumAscLiquescent\",
	  PunctumQuadratumDesLiquescent: \"PunctumQuadratumDesLiquescent\",
	  PunctumInclinatum: \"PunctumInclinatum\",
	  PunctumInclinatumLiquescent: \"PunctumInclinatumLiquescent\",
	  Quilisma: \"Quilisma\",
	
	  Sharp: \"Sharp\",
	  TerminatingAscLiquescent: \"TerminatingAscLiquescent\",
	  TerminatingDesLiquescent: \"TerminatingDesLiquescent\",
	  VerticalEpisemaAbove: \"VerticalEpisemaAbove\",
	  VerticalEpisemaBelow: \"VerticalEpisemaBelow\",
	  VirgaLong: \"VirgaLong\",
	  VirgaShort: \"VirgaShort\",
	  Virgula: \"Virgula\",
	
	  UpperBrace: \"UpperBrace\"
	}; // GlyphCode
	
	var QuickSvg = exports.QuickSvg = {
	  // namespaces
	  ns: \"http://www.w3.org/2000/svg\",
	  xmlns: \"http://www.w3.org/2000/xmlns/\",
	  xlink: \"http://www.w3.org/1999/xlink\",
	
	  hasDOMAccess: function hasDOMAccess() {
	    return canAccessDOM;
	  },
	
	  // create the root level svg object
	  svg: function svg(width, height) {
	    var node = document.createElementNS(this.ns, \"svg\");
	
	    node.setAttribute(\"xmlns\", this.ns);
	    node.setAttribute(\"version\", \"1.1\");
	    node.setAttributeNS(this.xmlns, \"xmlns:xlink\", this.xlink);
	
	    node.setAttribute(\"width\", width);
	    node.setAttribute(\"height\", height);
	
	    // create the defs element
	    var defs = document.createElementNS(this.ns, \"defs\");
	    node.appendChild(defs);
	
	    node.defs = defs;
	
	    node.clearNotations = function () {
	      // clear out all children except defs
	      node.removeChild(defs);
	
	      while (node.hasChildNodes()) {
	        node.removeChild(node.lastChild);
	      }node.appendChild(defs);
	    };
	
	    return node;
	  },
	
	  rect: function rect(width, height) {
	    var node = document.createElementNS(this.ns, \"rect\");
	
	    node.setAttribute(\"width\", width);
	    node.setAttribute(\"height\", height);
	
	    return node;
	  },
	
	  line: function line(x1, y1, x2, y2) {
	    var node = document.createElementNS(this.ns, \"line\");
	
	    node.setAttribute(\"x1\", x1);
	    node.setAttribute(\"y1\", y1);
	    node.setAttribute(\"x2\", x2);
	    node.setAttribute(\"y2\", y2);
	
	    return node;
	  },
	
	  g: function g() {
	    var node = document.createElementNS(this.ns, \"g\");
	
	    return node;
	  },
	
	  text: function text() {
	    var node = document.createElementNS(this.ns, \"text\");
	
	    return node;
	  },
	
	  tspan: function tspan(str) {
	    var node = document.createElementNS(this.ns, \"tspan\");
	    node.textContent = str;
	
	    return node;
	  },
	
	  // nodeRef should be the id of the object in defs (without the #)
	  use: function use(nodeRef) {
	    var node = document.createElementNS(this.ns, \"use\");
	    node.setAttributeNS(this.xlink, \"xlink:href\", \"#\" + nodeRef);
	
	    return node;
	  },
	
	  svgFragmentForGlyph: function svgFragmentForGlyph(glyph) {
	    var svgSrc = \"\";
	    for (var i = 0; i < glyph.paths.length; ++i) {
	      var path = glyph.paths[i];
	      svgSrc += QuickSvg.createFragment(path.data ? \"path\" : \"g\", {
	        d: path.data || undefined,
	        fill: path.type === \"negative\" ? \"#fff\" : undefined
	      });
	    }
	    return svgSrc;
	  },
	
	  nodesForGlyph: function nodesForGlyph(glyph) {
	    var functionName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"createNode\";
	
	    var nodes = [];
	    for (var i = 0; i < glyph.paths.length; ++i) {
	      var path = glyph.paths[i];
	      var props = {};
	      if (path.data) props.d = path.data;
	      if (path.type === \"negative\") props.fill = \"#fff\";
	      nodes.push(QuickSvg[functionName](path.data ? \"path\" : \"g\", props));
	    }
	    return nodes;
	  },
	
	  createNode: function createNode(name, attributes, children) {
	    var node = document.createElementNS(this.ns, name);
	    if (attributes && attributes.source) {
	      node.source = attributes.source;
	      delete attributes.source;
	    }
	    for (var attr in attributes) {
	      if (attributes.hasOwnProperty(attr) && typeof attributes[attr] !== \"undefined\") {
	        var val = attributes[attr];
	        var match = attr.match(/^([^:]+):([^:]+)$/);
	        if (match) {
	          node.setAttributeNS(this[match[1]], match[2], val);
	        } else {
	          node.setAttribute(attr, val);
	        }
	      }
	    }
	    if (children) {
	      if (typeof children === \"string\") {
	        node.textContent = children;
	      } else if (children.constructor === [].constructor) {
	        for (var i = 0; i < children.length; ++i) {
	          node.appendChild(children[i]);
	        }
	      } else {
	        node.appendChild(children);
	      }
	    }
	    return node;
	  },
	
	  createSvgTree: function createSvgTree(name, props) {
	    for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      children[_key - 2] = arguments[_key];
	    }
	
	    if (\"class\" in props) {
	      props.className = props.class;
	      delete props.class;
	    }
	    if (children.length === 1 && children[0] instanceof Array) {
	      children = children[0];
	    }
	    var convertKeysToCamelCase = function convertKeysToCamelCase(obj) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = Object.keys(obj)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var key = _step.value;
	
	          if (/[-:][a-z]/.test(key)) {
	            if (/^\\w+-index$/.test(key)) continue;
	            var camelCase = key.replace(/[-:]([a-z])/g, function (whole, letter) {
	              return letter.toUpperCase();
	            });
	            obj[camelCase] = obj[key];
	            delete obj[key];
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    };
	    convertKeysToCamelCase(props);
	    if (props.style) convertKeysToCamelCase(props.style);
	    var source = props.source;
	    if (source && source.sourceGabc) {
	      props[\"source-gabc\"] = source.sourceGabc;
	    }
	    return { name: name, props: props, children: children };
	  },
	
	
	  createFragment: function createFragment(name, attributes, child) {
	    if (child === undefined || child === null) child = \"\";
	
	    var fragment = \"<\" + name + \" \";
	
	    for (var attr in attributes) {
	      if (attributes.hasOwnProperty(attr) && typeof attributes[attr] !== \"undefined\") fragment += attr + '=\"' + attributes[attr] + '\" ';
	    }
	
	    fragment += \">\" + child + \"</\" + name + \">\";
	
	    return fragment;
	  },
	
	  parseFragment: function parseFragment(fragment) {
	    // create temporary holder
	    var well = document.createElement(\"svg\");
	
	    // act as a setter if svg is given
	    if (fragment) {
	      var container = this.g();
	
	      // dump raw svg
	      // do this to allow the browser to automatically create svg nodes?
	      well.innerHTML = \"<svg>\" + fragment.replace(/\
/, \"\").replace(/<(\\w+)([^<]+?)\\/>/g, \"<$1$2></$1>\") + \"</svg>\";
	
	      // transplant nodes
	      for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++) {
	        container.appendChild(well.firstChild.firstChild);
	      }return container;
	    }
	  },
	
	  translate: function translate(node, x, y) {
	    node.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");
	    return node;
	  },
	
	  scale: function scale(node, sx, sy) {
	    node.setAttribute(\"transform\", \"scale(\" + sx + \",\" + sy + \")\");
	    return node;
	  }
	};
	
	var TextMeasuringStrategy = exports.TextMeasuringStrategy = {
	  // shapes
	  Svg: 0,
	  Canvas: 1,
	  OpenTypeJS: 2
	};
	
	/*
	 * ChantContext
	 */
	
	var ChantContext = exports.ChantContext = function () {
	  function ChantContext() {
	    var _this = this;
	
	    var textMeasuringStrategy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : QuickSvg.hasDOMAccess() ? TextMeasuringStrategy.Canvas : TextMeasuringStrategy.OpenTypeJS;
	
	    _classCallCheck(this, ChantContext);
	
	    this.textMeasuringStrategy = textMeasuringStrategy;
	    this.defs = {};
	    this.makeDefs = [];
	    if (QuickSvg.hasDOMAccess()) {
	      this.defsNode = QuickSvg.createNode(\"defs\");
	    }
	
	    // font styles
	    this.textStyles = {};
	    this.textColor = \"#000\";
	    this.setFont(\"'Palatino Linotype', 'Book Antiqua', Palatino, serif\", 16);
	
	    this.rubricColor = \"#d00\";
	    this.specialCharProperties = {
	      \"font-family\": \"'Exsurge Characters'\",
	      fill: this.rubricColor,
	      class: 'rubric'
	    };
	    this.textBeforeSpecialChar = \"\";
	    this.textAfterSpecialChar = \".\";
	    this.specialCharMap = {
	      \"℣\": 'v',
	      \"℟\": 'r',
	      \"+\": \"+\",
	      \"*\": \"*\"
	    };
	    this.plusProperties = {};
	    this.asteriskProperties = {};
	    this.specialCharText = function (char) {
	      return _this.specialCharMap[char] || char;
	    };
	
	    this.fontStyleDictionary = {
	      b: { \"font-weight\": \"bold\" },
	      i: { \"font-style\": \"italic\" },
	      u: { \"text-decoration\": \"underline\" },
	      ul: { \"text-decoration\": \"underline\" },
	      c: { fill: this.rubricColor, class: 'rubric' },
	      sc: {
	        \"font-variant\": \"small-caps\",
	        \"font-variant-caps\": \"small-caps\",
	        \"font-feature-settings\": \"'smcp'\",
	        \"-webkit-font-feature-settings\": \"'smcp'\"
	      },
	      v: {}
	    };
	
	    this.markupSymbolDictionary = {
	      \"*\": \"b\",
	      \"_\": \"i\",
	      \"^\": \"c\",
	      \"%\": \"sc\"
	    };
	
	    this.textStyles.al.prefix = \"<i>\";
	
	    this.textStyles.translation.prefix = \"<i>\";
	
	    this.textStyles.dropCap.padding = 1; // minimum padding on either side of drop cap in staffIntervals
	
	    this.textStyles.annotation.padding = 1; // minimum padding on either side of annotation in staffIntervals
	
	    this.minLedgerSeparation = 2; // multiple of staffInterval
	    this.minSpaceAboveStaff = 2; // multiple of staffInterval
	    this.minSpaceBelowStaff = 1; // multiple of staffInterval
	    this.spaceBetweenSystems = 1.5; // multiple of staffInterval
	
	    // everything depends on the scale of the punctum
	    this.glyphPunctumWidth = _ExsurgeGlyphs.Glyphs.PunctumQuadratum.bounds.width;
	    this.glyphPunctumHeight = _ExsurgeGlyphs.Glyphs.PunctumQuadratum.bounds.height;
	
	    // max space to add between notations when justifying, in multiples of this.staffInterval
	    this.maxExtraSpaceInStaffIntervals = 0.5;
	
	    // for keeping track of the clef
	    this.activeClef = null;
	
	    this.neumeLineColor = \"#000\";
	    this.staffLineColor = \"#000\";
	    this.dividerLineColor = \"#000\";
	
	    this.defaultLanguage = _ExsurgeText.language.latin;
	
	    // calculate the pixel ratio for drawing to a canvas
	    this.pixelRatio = window.devicePixelRatio || 1.0;
	
	    //this.canvasCtxt.scale(this.pixelRatio, this.pixelRatio);
	
	    if (textMeasuringStrategy === TextMeasuringStrategy.Svg) {
	      this.svgTextMeasurer = QuickSvg.svg(0, 0);
	      this.svgTextMeasurer.setAttribute(\"id\", \"TextMeasurer\");
	      this.svgTextMeasurer.setAttribute(\"style\", \"position:absolute\");
	      document.body.insertBefore(this.svgTextMeasurer, document.body.firstChild);
	    } else if (textMeasuringStrategy === TextMeasuringStrategy.Canvas) {
	      this.makeCanvasIfNeeded();
	    }
	
	    // for connecting neume syllables...
	    this.syllableConnector = \"-\";
	
	    // set whether to scale the def tags (scaleDefs = true) or the use tags.
	    this.scaleDefs = true;
	
	    // fixme: for now, we just set these using the glyph scales as noted above, presuming a
	    // staff line size of 0.5 in. Really what we should do is scale the punctum size based
	    // on the text metrics, right? 1 punctum ~ x height size?
	    this.setGlyphScaling(1.0 / 16.0);
	
	    // minimum space between puncta of different syllables, in multiples of this.intraNeumeSpacing
	    this.interSyllabicMultiplier = 2.5;
	
	    // space between an accidental and the following note, in multiples of this.intraNeumeSpacing
	    this.accidentalSpaceMultiplier = 2;
	
	    // space added between puncta of different words, in multiples of this.intraNeumeSpacing
	    this.interVerbalMultiplier = 1;
	
	    this.drawGuides = false;
	    this.drawDebuggingBounds = true;
	
	    // we keep track of where we are in processing notations, so that
	    // we can maintain the context for notations to know about.
	    //
	    // these are only gauranteed to be valid during the performLayout phase!
	    this.activeNotations = null;
	    this.currNotationIndex = -1;
	
	    this.minSyllablesLastLine = 0;
	    this.minNotesLastLine = 0;
	
	    // chant notation elements are normally separated by a minimum fixed amount of space
	    // on the staff line. It can happen, however, that two text elements are almost close
	    // enough to merge, only to be separated much more by the required hyphen (or other
	    // connecting string).
	    //
	    // This tolerance value allows a little bit of flexibility to merge two close lyrical
	    // elements, thus bringing the chant notation elements a bit closer than otherwise
	    // would be normally allowed.
	    //
	    // condensing tolerance is a percentage value (0.0-1.0, inclusive) that indicates
	    // how much the default spacing can shrink. E.g., a value of 0.20 allows the layout
	    // engine to separate two glyphs by only 80% of the normal inter-neume spacing value.
	    this.condensingTolerance = 0.3;
	
	    // if auto color is true, then exsurge tries to automatically colorize
	    // some elements of the chant (directives become rubric color, etc.)
	    this.autoColor = true;
	
	    this.useExtraTextOnly = true;
	
	    this.noteIdPrefix = 'note-';
	
	    this.insertFontsInDoc();
	  }
	
	  _createClass(ChantContext, [{
	    key: \"getFontForProperties\",
	    value: function getFontForProperties() {
	      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var fontFamily = arguments[1];
	
	      var key = getFontFilenameForProperties(properties),
	          keyWithFontFamily = getFontFilenameForProperties(properties, fontFamily);
	      return this.fontDictionary && (this.fontDictionary[keyWithFontFamily] || this.fontDictionary[fontFamily] || this.fontDictionary.Regular);
	    }
	  }, {
	    key: \"setFont\",
	    value: function setFont(font) {
	      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;
	      var baseStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var opentypeFontDictionary = arguments[3];
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = Object.entries(TextTypes)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var _step2$value = _slicedToArray(_step2.value, 2),
	              key = _step2$value[0],
	              textType = _step2$value[1];
	
	          var textStyle = this.textStyles[key] = this.textStyles[key] || {};
	          textStyle.size = textType.defaultSize ? textType.defaultSize(size, this) : textType.size(this);
	          textStyle.font = font;
	          textStyle.color = this.textColor || \"#000\";
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	
	      this.baseTextStyle = baseStyle;
	
	      if (opentypeFontDictionary) {
	        this.textMeasuringStrategy = TextMeasuringStrategy.OpenTypeJS;
	        this.fontDictionary = opentypeFontDictionary;
	      }
	    }
	  }, {
	    key: \"setRubricColor\",
	    value: function setRubricColor(color) {
	      this.rubricColor = color;
	      this.specialCharProperties.fill = color;
	      this.fontStyleDictionary.c.fill = color;
	    }
	  }, {
	    key: \"setScaleDefs\",
	    value: function setScaleDefs(scaleDefs) {
	      scaleDefs = !!scaleDefs;
	      if (this.scaleDefs !== scaleDefs) {
	        this.scaleDefs = scaleDefs;
	        this.setGlyphScaling(this.glyphScaling);
	      }
	    }
	  }, {
	    key: \"createStyleCss\",
	    value: function createStyleCss() {
	      var style = \"\";
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;
	
	      try {
	        for (var _iterator3 = Object.entries(TextTypes)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var _step3$value = _slicedToArray(_step3.value, 2),
	              key = _step3$value[0],
	              textType = _step3$value[1];
	
	          var cssClass = textType.cssClass,
	              _textStyles$key = this.textStyles[key],
	              color = _textStyles$key.color,
	              font = _textStyles$key.font,
	              size = _textStyles$key.size;
	
	          style += \"svg.Exsurge .\" + cssClass + \"{fill:\" + color + \";font-family:\" + font + \";font-size:\" + size + \"px;font-kerning:normal}\";
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }
	
	      return style;
	    }
	  }, {
	    key: \"createStyleNode\",
	    value: function createStyleNode() {
	      var node = QuickSvg.createNode(\"style\", {});
	      node.textContent = this.createStyleCss();
	      return node;
	    }
	  }, {
	    key: \"createStyleTree\",
	    value: function createStyleTree() {
	      return { name: \"style\", props: {}, children: [this.createStyleCss()] };
	    }
	  }, {
	    key: \"createStyle\",
	    value: function createStyle() {
	      return \"<style>\" + this.createStyleCss() + \"</style>\";
	    }
	  }, {
	    key: \"updateHyphenWidth\",
	    value: function updateHyphenWidth() {
	      // measure the size of a hyphen for the lyrics
	      var hyphen = new Lyric(this, this.syllableConnector, LyricType.SingleSyllable);
	      var multiplier = this.minLyricWordSpacing / (this.hyphenWidth || this.minLyricWordSpacing) || 1;
	      this.hyphenWidth = hyphen.bounds.width;
	
	      this.minLyricWordSpacing = multiplier * this.hyphenWidth;
	    }
	  }, {
	    key: \"setStaffHeight\",
	    value: function setStaffHeight(staffHeight) {
	      this.setGlyphScaling(staffHeight / 600);
	    }
	  }, {
	    key: \"setGlyphScaling\",
	    value: function setGlyphScaling(glyphScaling) {
	      this.glyphScaling = glyphScaling;
	
	      this.staffInterval = this.glyphPunctumWidth * this.glyphScaling;
	
	      // setup the line weights for the various elements.
	      this.staffLineWeight = Math.ceil(5 * this.staffInterval / 8) / 5;
	      this.neumeLineWeight = this.staffLineWeight; // the weight of connecting lines in the glyphs.
	      this.dividerLineWeight = this.neumeLineWeight; // of quarter bar, half bar, etc.
	      this.episemaLineWeight = this.neumeLineWeight * 1.25; // of horizontal episemata
	
	      this.intraNeumeSpacing = this.staffInterval / 2.0;
	
	      while (this.defsNode && this.defsNode.firstChild) {
	        this.defsNode.removeChild(this.defsNode.firstChild);
	      }for (var i = 0; i < this.makeDefs.length; ++i) {
	        this.makeDefs[i]();
	      }
	
	      this.updateHyphenWidth();
	    }
	  }, {
	    key: \"calculateHeightFromStaffPosition\",
	    value: function calculateHeightFromStaffPosition(staffPosition) {
	      return -staffPosition * this.staffInterval;
	    }
	  }, {
	    key: \"insertFontsInDoc\",
	    value: function insertFontsInDoc() {
	      if (!canAccessDOM) return;
	
	      var styleElement = document.getElementById(\"exsurge-fonts\");
	
	      if (styleElement === null) {
	        // create it since it doesn't exist yet.
	        styleElement = document.createElement(\"style\");
	        styleElement.id = \"exsurge-fonts\";
	
	        // styleElement.appendChild(document.createTextNode(\"@font-face{font-family: 'Exsurge Characters';font-weight: normal;font-style: normal;src: url(\" + __exsurgeCharactersFont + \") format('opentype');}\"));
	
	        document.head.appendChild(styleElement);
	      }
	    }
	
	    // returns the next neume starting at this.currNotationIndex, or null
	    // if there isn't a neume after this one...
	
	  }, {
	    key: \"findNextNeume\",
	    value: function findNextNeume() {
	      if (typeof this.currNotationIndex === \"undefined\") throw \"findNextNeume() called without a valid currNotationIndex set\";
	
	      for (var i = this.currNotationIndex + 1; i < this.notations.length; i++) {
	        var notation = this.notations[i];
	
	        if (notation.isNeume && !notation.hasNoWidth) return notation;
	      }
	
	      return null;
	    }
	  }, {
	    key: \"makeCanvasIfNeeded\",
	    value: function makeCanvasIfNeeded() {
	      if (!this.canvas) {
	        this.canvas = document.createElement(\"canvas\");
	        this.canvasCtxt = this.canvas.getContext(\"2d\");
	      }
	    }
	  }, {
	    key: \"setCanvasSize\",
	    value: function setCanvasSize(width, height) {
	      var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
	
	      this.makeCanvasIfNeeded();
	
	      this.canvas.style.width = width * scale + \"px\";
	      this.canvas.style.height = height * scale + \"px\";
	      scale *= this.pixelRatio;
	      this.canvas.width = width * scale;
	      this.canvas.height = height * scale;
	
	      this.canvasCtxt.setTransform(scale, 0, 0, scale, 0, 0);
	    }
	  }]);
	
	  return ChantContext;
	}();
	
	/*
	 * ChantLayoutElement
	 */
	
	
	var ChantLayoutElement = exports.ChantLayoutElement = function () {
	  function ChantLayoutElement() {
	    _classCallCheck(this, ChantLayoutElement);
	
	    this.bounds = new _ExsurgeCore.Rect();
	    this.origin = new _ExsurgeCore.Point(0, 0);
	
	    this.selected = false;
	    this.highlighted = false;
	  }
	
	  // draws the element on an html5 canvas
	
	
	  _createClass(ChantLayoutElement, [{
	    key: \"draw\",
	    value: function draw(ctxt) {
	      throw \"ChantLayout Elements must implement draw(ctxt)\";
	    }
	
	    // returns svg element
	
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      throw \"ChantLayout Elements must implement createSvgNode(ctxt)\";
	    }
	
	    // returns svg code for the element, used for printing support
	
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      throw \"ChantLayout Elements must implement createSvgFragment(ctxt)\";
	    }
	  }]);
	
	  return ChantLayoutElement;
	}();
	
	var DividerLineVisualizer = exports.DividerLineVisualizer = function (_ChantLayoutElement) {
	  _inherits(DividerLineVisualizer, _ChantLayoutElement);
	
	  function DividerLineVisualizer(ctxt, staffPosition0, staffPosition1, divider) {
	    _classCallCheck(this, DividerLineVisualizer);
	
	    var _this2 = _possibleConstructorReturn(this, (DividerLineVisualizer.__proto__ || Object.getPrototypeOf(DividerLineVisualizer)).call(this));
	
	    _this2.divider = divider;
	
	    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition0);
	    var y1 = ctxt.calculateHeightFromStaffPosition(staffPosition1);
	
	    if (y0 > y1) {
	      var temp = y0;
	      y0 = y1;
	      y1 = temp;
	    }
	
	    _this2.bounds.x = 0;
	    _this2.bounds.y = y0;
	    _this2.bounds.width = ctxt.dividerLineWeight;
	    _this2.bounds.height = y1 - y0;
	
	    _this2.origin.x = _this2.bounds.width / 2;
	    _this2.origin.y = y0;
	    return _this2;
	  }
	
	  _createClass(DividerLineVisualizer, [{
	    key: \"draw\",
	    value: function draw(ctxt) {
	      var canvasCtxt = ctxt.canvasCtxt;
	
	      canvasCtxt.fillStyle = ctxt.dividerLineColor;
	
	      canvasCtxt.fillRect(this.bounds.x, this.bounds.y, ctxt.dividerLineWeight, this.bounds.height);
	    }
	  }, {
	    key: \"getSvgProps\",
	    value: function getSvgProps(ctxt) {
	      var props = {
	        x: this.bounds.x,
	        y: this.bounds.y,
	        width: ctxt.dividerLineWeight,
	        height: this.bounds.height,
	        fill: ctxt.dividerLineColor,
	        class: \"dividerLine\"
	      };
	      if (this.divider) {
	        if (this.divider.selected) props.class += \" selected\";
	        props[\"source-index\"] = this.divider.sourceIndex;
	        props[\"element-index\"] = this.divider.elementIndex;
	        props.source = this.divider;
	      }
	      return props;
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt) {
	      return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));
	    }
	  }]);
	
	  return DividerLineVisualizer;
	}(ChantLayoutElement);
	
	var NeumeLineVisualizer = exports.NeumeLineVisualizer = function (_ChantLayoutElement2) {
	  _inherits(NeumeLineVisualizer, _ChantLayoutElement2);
	
	  function NeumeLineVisualizer(ctxt, note0, note1, hanging) {
	    _classCallCheck(this, NeumeLineVisualizer);
	
	    var _this3 = _possibleConstructorReturn(this, (NeumeLineVisualizer.__proto__ || Object.getPrototypeOf(NeumeLineVisualizer)).call(this));
	
	    var staffPosition0 = note0.staffPosition;
	    var staffPosition1 = note1.staffPosition;
	
	    // note0 should be the upper one for our calculations here
	    if (staffPosition0 < staffPosition1) {
	      var temp = staffPosition0;
	      staffPosition0 = staffPosition1;
	      staffPosition1 = temp;
	    }
	
	    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition0);
	    var y1 = 0;
	
	    if (hanging) {
	      // if the difference between the notes is only one, and the upper
	      // note is on a line, and the lower note is within the four staff lines,
	      // then our hanging line goes past the lower note by a whole
	      // staff interval
	      if (staffPosition0 - staffPosition1 === 1 && Math.abs(staffPosition0) % 2 === 1 && staffPosition1 > -3) staffPosition1--;
	
	      y1 += ctxt.glyphPunctumHeight * ctxt.glyphScaling / 2.2;
	    }
	
	    y1 += ctxt.calculateHeightFromStaffPosition(staffPosition1);
	
	    _this3.bounds.x = 0;
	    _this3.bounds.y = y0;
	    _this3.bounds.width = ctxt.neumeLineWeight;
	    _this3.bounds.height = y1 - y0;
	
	    _this3.origin.x = 0;
	    _this3.origin.y = 0;
	    return _this3;
	  }
	
	  _createClass(NeumeLineVisualizer, [{
	    key: \"draw\",
	    value: function draw(ctxt) {
	      var canvasCtxt = ctxt.canvasCtxt;
	
	      canvasCtxt.fillStyle = ctxt.neumeLineColor;
	
	      canvasCtxt.fillRect(this.bounds.x, this.bounds.y, ctxt.neumeLineWeight, this.bounds.height);
	    }
	  }, {
	    key: \"getSvgProps\",
	    value: function getSvgProps(ctxt) {
	      return {
	        x: this.bounds.x,
	        y: this.bounds.y,
	        width: ctxt.neumeLineWeight,
	        height: this.bounds.height,
	        fill: ctxt.neumeLineColor,
	        class: \"neumeLine\"
	      };
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt) {
	      return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));
	    }
	  }]);
	
	  return NeumeLineVisualizer;
	}(ChantLayoutElement);
	
	var VirgaLineVisualizer = exports.VirgaLineVisualizer = function (_ChantLayoutElement3) {
	  _inherits(VirgaLineVisualizer, _ChantLayoutElement3);
	
	  function VirgaLineVisualizer(ctxt, note) {
	    _classCallCheck(this, VirgaLineVisualizer);
	
	    var _this4 = _possibleConstructorReturn(this, (VirgaLineVisualizer.__proto__ || Object.getPrototypeOf(VirgaLineVisualizer)).call(this));
	
	    var staffPosition = note.staffPosition;
	
	    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition);
	    var y1;
	
	    if (Math.abs(staffPosition % 2) === 0) y1 = y0 + ctxt.staffInterval * 1.8;else y1 = y0 + ctxt.staffInterval * 2.7;
	
	    _this4.bounds.x = 0;
	    _this4.bounds.y = y0;
	    _this4.bounds.width = ctxt.neumeLineWeight;
	    _this4.bounds.height = y1 - y0;
	
	    _this4.origin.x = 0;
	    _this4.origin.y = 0;
	    return _this4;
	  }
	
	  _createClass(VirgaLineVisualizer, [{
	    key: \"draw\",
	    value: function draw(ctxt) {
	      var canvasCtxt = ctxt.canvasCtxt;
	
	      canvasCtxt.fillStyle = ctxt.neumeLineColor;
	      canvasCtxt.fillRect(this.bounds.x, this.bounds.y, ctxt.neumeLineWeight, this.bounds.height);
	    }
	  }, {
	    key: \"getSvgProps\",
	    value: function getSvgProps(ctxt) {
	      return {
	        x: this.bounds.x,
	        y: this.bounds.y,
	        width: ctxt.neumeLineWeight,
	        height: this.bounds.height,
	        fill: ctxt.neumeLineColor,
	        class: \"neumeLine\"
	      };
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt) {
	      return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));
	    }
	  }]);
	
	  return VirgaLineVisualizer;
	}(ChantLayoutElement);
	
	var LineaVisualizer = exports.LineaVisualizer = function (_ChantLayoutElement4) {
	  _inherits(LineaVisualizer, _ChantLayoutElement4);
	
	  function LineaVisualizer(ctxt, note) {
	    _classCallCheck(this, LineaVisualizer);
	
	    var _this5 = _possibleConstructorReturn(this, (LineaVisualizer.__proto__ || Object.getPrototypeOf(LineaVisualizer)).call(this));
	
	    var staffPosition = note.staffPosition;
	
	    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition) - note.origin.y;
	    var y1 = y0 + note.bounds.height;
	
	    _this5.bounds.x = 0;
	    _this5.bounds.y = y0;
	    _this5.bounds.width = ctxt.neumeLineWeight * 5 + note.bounds.width;
	    _this5.bounds.height = y1 - y0;
	
	    _this5.origin.x = ctxt.neumeLineWeight * 2.5;
	    _this5.origin.y = 0;
	    return _this5;
	  }
	
	  _createClass(LineaVisualizer, [{
	    key: \"draw\",
	    value: function draw(ctxt) {
	      var canvasCtxt = ctxt.canvasCtxt;
	
	      canvasCtxt.fillStyle = ctxt.neumeLineColor;
	      canvasCtxt.fillRect(this.bounds.x, this.bounds.y, ctxt.neumeLineWeight, this.bounds.height);
	      canvasCtxt.fillRect(this.bounds.x + this.bounds.width - ctxt.neumeLineWeight, this.bounds.y, ctxt.neumeLineWeight, this.bounds.height);
	    }
	  }, {
	    key: \"getSvgProps\",
	    value: function getSvgProps(ctxt, x) {
	      return {
	        x: x,
	        y: this.bounds.y,
	        width: ctxt.neumeLineWeight,
	        height: this.bounds.height,
	        fill: ctxt.neumeLineColor,
	        class: \"neumeLine\"
	      };
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      var _this6 = this;
	
	      return QuickSvg.createNode(\"g\", null, [this.bounds.x, this.bounds.x + this.bounds.width - ctxt.neumeLineWeight].map(function (x) {
	        return QuickSvg.createNode(\"rect\", _this6.getSvgProps(ctxt, x));
	      }));
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt) {
	      var _this7 = this;
	
	      return QuickSvg.createSvgTree.apply(QuickSvg, [\"g\", {}].concat(_toConsumableArray([this.bounds.x, this.bounds.x + this.bounds.width - ctxt.neumeLineWeight].map(function (x) {
	        return QuickSvg.createSvgTree(\"rect\", _this7.getSvgProps(ctxt, x));
	      }))));
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      var _this8 = this;
	
	      return QuickSvg.createFragment(\"g\", null, [this.bounds.x, this.bounds.x + this.bounds.width - ctxt.neumeLineWeight].map(function (x) {
	        return QuickSvg.createFragment(\"rect\", _this8.getSvgProps(ctxt, x));
	      }).join(''));
	    }
	  }]);
	
	  return LineaVisualizer;
	}(ChantLayoutElement);
	
	var GlyphVisualizer = exports.GlyphVisualizer = function (_ChantLayoutElement5) {
	  _inherits(GlyphVisualizer, _ChantLayoutElement5);
	
	  function GlyphVisualizer(ctxt, glyphCode) {
	    _classCallCheck(this, GlyphVisualizer);
	
	    var _this9 = _possibleConstructorReturn(this, (GlyphVisualizer.__proto__ || Object.getPrototypeOf(GlyphVisualizer)).call(this));
	
	    _this9.glyph = null;
	
	    _this9.setGlyph(ctxt, glyphCode);
	    return _this9;
	  }
	
	  _createClass(GlyphVisualizer, [{
	    key: \"setGlyph\",
	    value: function setGlyph(ctxt, glyphCode) {
	      if (this.glyphCode !== glyphCode) {
	        if (typeof glyphCode === \"undefined\" || glyphCode === null || glyphCode === \"\") glyphCode = this.glyphCode = GlyphCode.None;else this.glyphCode = glyphCode;
	
	        var glyph = this.glyph = _ExsurgeGlyphs.Glyphs[glyphCode];
	
	        // if this glyph hasn't been used yet, then load it up in the defs section for sharing
	        if (!ctxt.defs.hasOwnProperty(glyphCode)) {
	          var getDefProps = function getDefProps() {
	            var options = {
	              id: glyphCode,
	              class: \"glyph\"
	            };
	            if (ctxt.scaleDefs === true) {
	              options.transform = \"scale(\" + ctxt.glyphScaling + \")\";
	            }
	            return options;
	          };
	          var makeDef = function makeDef() {
	            var options = getDefProps();
	            // create the ref
	            ctxt.defs[glyphCode] = QuickSvg.createFragment(\"g\", options, QuickSvg.svgFragmentForGlyph(glyph));
	
	            if (ctxt.defsNode) ctxt.defsNode.appendChild(QuickSvg.createNode(\"g\", options, QuickSvg.nodesForGlyph(glyph)));
	          };
	          makeDef.makeSvgTree = function () {
	            return QuickSvg.createSvgTree.apply(QuickSvg, [\"g\", getDefProps()].concat(_toConsumableArray(QuickSvg.nodesForGlyph(glyph, \"createSvgTree\"))));
	          };
	          makeDef.glyphCode = glyphCode;
	          makeDef();
	          ctxt.makeDefs.push(makeDef);
	        }
	
	        this.align = this.glyph.align;
	      }
	
	      this.origin.x = this.glyph.origin.x * ctxt.glyphScaling;
	      this.origin.y = this.glyph.origin.y * ctxt.glyphScaling;
	
	      this.bounds.x = 0;
	      this.bounds.y = -this.origin.y;
	      this.bounds.width = this.glyph.bounds.width * ctxt.glyphScaling;
	      this.bounds.height = this.glyph.bounds.height * ctxt.glyphScaling;
	    }
	  }, {
	    key: \"setStaffPosition\",
	    value: function setStaffPosition(ctxt, staffPosition) {
	      this.bounds.y = ctxt.calculateHeightFromStaffPosition(staffPosition) - this.origin.y;
	    }
	  }, {
	    key: \"draw\",
	    value: function draw(ctxt) {
	      var canvasCtxt = ctxt.canvasCtxt;
	
	      var x = this.bounds.x + this.origin.x;
	      var y = this.bounds.y + this.origin.y;
	      canvasCtxt.translate(x, y);
	      canvasCtxt.scale(ctxt.glyphScaling, ctxt.glyphScaling);
	
	      for (var i = 0; i < this.glyph.paths.length; i++) {
	        var path = this.glyph.paths[i];
	        canvasCtxt.fillStyle = path.type === \"negative\" ? \"#fff\" : ctxt.neumeLineColor;
	        canvasCtxt.fill(new Path2D(path.data));
	      }
	
	      canvasCtxt.scale(1.0 / ctxt.glyphScaling, 1.0 / ctxt.glyphScaling);
	      canvasCtxt.translate(-x, -y);
	    }
	  }, {
	    key: \"getSvgAttributes\",
	    value: function getSvgAttributes(ctxt, source) {
	      var className = \"\";
	      if (/^Porrectus\\d$/.test(this.glyphCode)) {
	        var notes = source.neume.notes,
	            noteIndex = notes.indexOf(source),
	            nextNote = notes[noteIndex + 1];
	        className = source.selected ? nextNote.selected ? \"selected\" : \"selectedA\" : nextNote.selected ? \"selectedB\" : \"\";
	      } else {
	        var isSelected = source && (source.selected || source.model && source.model.selected);
	        className = isSelected ? \"selected\" : \"\";
	      }
	      var result = {
	        \"xlink:href\": \"#\" + this.glyphCode,
	        class: className
	      };
	      if (source) {
	        result[\"source-index\"] = source.sourceIndex;
	        result[\"element-index\"] = source.elementIndex;
	        if ('noteIndex' in source) {
	          result.class += ' note';
	          result.id = ctxt.noteIdPrefix + (source.noteIndex + 1);
	          if (source.neume) {
	            var glyphCode = source.glyphVisualizer.glyphCode;
	            if (/^Porrectus/.test(glyphCode)) {
	              result.class += ' porrectus porrectus-start';
	            } else if (glyphCode === 'None') {
	              result.class += ' porrectus porrectus-end';
	            }
	          }
	        }
	      }
	      if (ctxt.scaleDefs === true) {
	        result.x = this.bounds.x + this.origin.x;
	        result.y = this.bounds.y + this.origin.y;
	      } else {
	        result.x = (this.bounds.x + this.origin.x) / ctxt.glyphScaling;
	        result.y = (this.bounds.y + this.origin.y) / ctxt.glyphScaling;
	        result.transform = \"scale(\" + ctxt.glyphScaling + \")\";
	      }
	      return result;
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt, source) {
	      var attributes = this.getSvgAttributes(ctxt, source);
	      attributes.source = source;
	      return QuickSvg.createNode(\"use\", attributes);
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt, source) {
	      var attributes = this.getSvgAttributes(ctxt, source);
	      if (source) attributes.source = source;
	      return QuickSvg.createSvgTree(\"use\", attributes);
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt, source) {
	      return QuickSvg.createFragment(\"use\", this.getSvgAttributes(ctxt, source));
	    }
	  }]);
	
	  return GlyphVisualizer;
	}(ChantLayoutElement);
	
	var RoundBraceVisualizer = exports.RoundBraceVisualizer = function (_ChantLayoutElement6) {
	  _inherits(RoundBraceVisualizer, _ChantLayoutElement6);
	
	  function RoundBraceVisualizer(ctxt, x1, x2, y, isAbove) {
	    _classCallCheck(this, RoundBraceVisualizer);
	
	    var _this10 = _possibleConstructorReturn(this, (RoundBraceVisualizer.__proto__ || Object.getPrototypeOf(RoundBraceVisualizer)).call(this));
	
	    if (x1 > x2) {
	      // swap the xs
	      var temp = x1;
	      x1 = x2;
	      x2 = temp;
	    }
	
	    _this10.isAbove = isAbove;
	    _this10.braceHeight = 3 * ctxt.staffInterval / 2;
	
	    _this10.bounds = new _ExsurgeCore.Rect(x1, isAbove ? y - _this10.braceHeight : y, x2 - x1, _this10.braceHeight);
	
	    _this10.origin.x = 0;
	    _this10.origin.y = 0;
	    return _this10;
	  }
	
	  _createClass(RoundBraceVisualizer, [{
	    key: \"getSvgPathProps\",
	    value: function getSvgPathProps(ctxt) {
	      return {
	        d: this.generatePathString(),
	        stroke: ctxt.neumeLineColor,
	        \"stroke-width\": ctxt.staffLineWeight + \"px\",
	        fill: \"none\",
	        class: \"brace\"
	      };
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      var node = QuickSvg.createNode(\"path\", this.getSvgPathProps(ctxt));
	      if (this.accent) {
	        return QuickSvg.createNode(\"g\", {
	          class: \"accentedBrace\"
	        }, [node, this.accent.createSvgNode(ctxt)]);
	      } else return node;
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt) {
	      var node = QuickSvg.createSvgTree(\"path\", this.getSvgPathProps(ctxt));
	      if (this.accent) {
	        return QuickSvg.createSvgTree(\"g\", {
	          class: \"accentedBrace\"
	        }, node, this.accent.createSvgTree(ctxt));
	      } else return node;
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      var fragment = QuickSvg.createFragment(\"path\", this.getSvgPathProps(ctxt));
	
	      if (this.accent) {
	        fragment += this.accent.createSvgFragment(ctxt);
	
	        return QuickSvg.createFragment(\"g\", {
	          class: \"accentedBrace\"
	        }, fragment);
	      } else return fragment;
	    }
	
	    // returns svg path d string
	
	  }, {
	    key: \"generatePathString\",
	    value: function generatePathString() {
	      var x1 = this.bounds.x;
	      var x2 = this.bounds.right();
	      var width = this.bounds.width;
	      var y, dx, dy;
	
	      dx = width / 6;
	      dy = this.bounds.height;
	      if (this.isAbove) {
	        y = this.bounds.bottom();
	        dy = -dy;
	      } else {
	        y = this.bounds.y;
	      }
	
	      //Calculate Control Points of path,
	      var cx1 = x1 + dx;
	      var cy = y + dy;
	      var cx2 = x2 - dx;
	
	      // two decimal points should be enough, but if we need more precision, we can
	      // up it here.
	      var dp = 2;
	      return \"M \" + x1.toFixed(dp) + \" \" + y.toFixed(dp) + \" C \" + cx1.toFixed(dp) + \" \" + cy.toFixed(dp) + \" \" + cx2.toFixed(dp) + \" \" + cy.toFixed(dp) + \" \" + x2.toFixed(dp) + \" \" + y.toFixed(dp);
	    }
	  }]);
	
	  return RoundBraceVisualizer;
	}(ChantLayoutElement);
	
	var CurlyBraceVisualizer = exports.CurlyBraceVisualizer = function (_ChantLayoutElement7) {
	  _inherits(CurlyBraceVisualizer, _ChantLayoutElement7);
	
	  function CurlyBraceVisualizer(ctxt, x1, x2, y) {
	    var isAbove = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
	    var addAcuteAccent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
	
	    _classCallCheck(this, CurlyBraceVisualizer);
	
	    var _this11 = _possibleConstructorReturn(this, (CurlyBraceVisualizer.__proto__ || Object.getPrototypeOf(CurlyBraceVisualizer)).call(this));
	
	    if (x1 > x2) {
	      // swap the xs
	      var temp = x1;
	      x1 = x2;
	      x2 = temp;
	    }
	
	    _this11.isAbove = isAbove;
	    _this11.braceHeight = ctxt.staffInterval / 2;
	
	    // y is the actual vertical start of the brace (left hand side)
	    // thus for a brace over notes, bounds.y is the bottom of brace,
	    // but for a brace under the notes, y is simply the y passed in.
	    if (isAbove) y -= _this11.braceHeight;
	
	    var bounds = new _ExsurgeCore.Rect(x1, y, x2 - x1, _this11.braceHeight);
	
	    if (addAcuteAccent && isAbove) {
	      _this11.accent = new GlyphVisualizer(ctxt, GlyphCode.AcuteAccent);
	      _this11.accent.bounds.x += bounds.x + (x2 - x1) / 2;
	      _this11.accent.bounds.y += bounds.y - ctxt.staffInterval / 4;
	
	      bounds.union(_this11.accent.bounds);
	    }
	
	    _this11.bounds = bounds;
	
	    _this11.origin.x = 0;
	    _this11.origin.y = 0;
	    return _this11;
	  }
	
	  _createClass(CurlyBraceVisualizer, [{
	    key: \"getSvgPathProps\",
	    value: function getSvgPathProps(ctxt) {
	      return {
	        d: this.generatePathString(),
	        stroke: ctxt.neumeLineColor,
	        \"stroke-width\": ctxt.staffLineWeight + \"px\",
	        fill: \"none\",
	        class: \"brace\"
	      };
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      var node = QuickSvg.createNode(\"path\", this.getSvgPathProps(ctxt));
	
	      if (this.accent) {
	        return QuickSvg.createNode(\"g\", {
	          class: \"accentedBrace\"
	        }, [node, this.accent.createSvgNode(ctxt)]);
	      } else return node;
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt) {
	      var node = QuickSvg.createSvgTree(\"path\", this.getSvgPathProps(ctxt));
	      if (this.accent) {
	        return QuickSvg.createSvgTree(\"g\", {
	          class: \"accentedBrace\"
	        }, node, this.accent.createSvgTree(ctxt));
	      } else return node;
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      var fragment = QuickSvg.createFragment(\"path\", this.getSvgPathProps(ctxt));
	
	      if (this.accent) {
	        fragment += this.accent.createSvgFragment(ctxt);
	
	        return QuickSvg.createFragment(\"g\", {
	          class: \"accentedBrace\"
	        }, fragment);
	      } else return fragment;
	    }
	
	    // code below inspired by: https://gist.github.com/alexhornbake
	    // optimized for braces that are only drawn horizontally.
	    // returns svg path d string
	
	  }, {
	    key: \"generatePathString\",
	    value: function generatePathString() {
	      var q = 0.6; // .5 is normal, higher q = more expressive bracket
	
	      var x1 = this.bounds.x;
	      var x2 = this.bounds.right();
	      var width = this.bounds.width;
	      var y, h;
	
	      if (this.isAbove) {
	        y = this.bounds.bottom();
	        h = -this.braceHeight;
	      } else {
	        y = this.bounds.y;
	        h = this.braceHeight;
	      }
	
	      // calculate Control Points of path
	      var qy1 = y + q * h;
	      var qx2 = x1 + 0.25 * width;
	      var qy2 = y + (1 - q) * h;
	      var tx1 = x1 + 0.5 * width;
	      var ty1 = y + h;
	      var qy3 = y + q * h;
	      var qx4 = x1 + 0.75 * width;
	      var qy4 = y + (1 - q) * h;
	
	      // two decimal points should be enough, but if we need more precision, we can
	      // up it here.
	      var dp = 2;
	      return \"M \" + x1.toFixed(dp) + \" \" + y.toFixed(dp) + \" Q \" + x1.toFixed(dp) + \" \" + qy1.toFixed(dp) + \" \" + qx2.toFixed(dp) + \" \" + qy2.toFixed(dp) + \" T \" + tx1.toFixed(dp) + \" \" + ty1.toFixed(dp) + \" M \" + x2.toFixed(dp) + \" \" + y.toFixed(dp) + \" Q \" + x2.toFixed(dp) + \" \" + qy3.toFixed(dp) + \" \" + qx4.toFixed(dp) + \" \" + qy4.toFixed(dp) + \" T \" + tx1.toFixed(dp) + \" \" + ty1.toFixed(dp);
	    }
	  }]);
	
	  return CurlyBraceVisualizer;
	}(ChantLayoutElement);
	
	var TextSpan = exports.TextSpan = function () {
	  function TextSpan(text, properties, activeTags) {
	    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	
	    _classCallCheck(this, TextSpan);
	
	    if (typeof properties === \"undefined\" || properties === null) properties = {};
	
	    this.text = text;
	    this.properties = properties;
	    this.activeTags = activeTags || [];
	    this.index = index;
	  }
	
	  _createClass(TextSpan, [{
	    key: \"clone\",
	    value: function clone() {
	      return new TextSpan(this.text, this.properties, this.activeTags, this.index);
	    }
	  }]);
	
	  return TextSpan;
	}();
	
	function MarkupStackFrame(tagName, startIndex) {
	  var properties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var symbol = arguments[3];
	
	  this.tagName = tagName;
	  this.startIndex = startIndex;
	  this.properties = properties;
	  if (symbol) this.symbol = symbol;
	}
	
	MarkupStackFrame.createStackFrame = function (ctxt, tagName, startIndex) {
	  var extraProperties = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	  var symbol = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '';
	
	  return new MarkupStackFrame(tagName, startIndex, Object.assign({}, ctxt.fontStyleDictionary[tagName], extraProperties), symbol);
	};
	
	// for escaping html strings before they go into the svgs
	// adapted from http://stackoverflow.com/a/12034334/5720160
	var __subsForTspans = {
	  \"&\": \"&amp;\",
	  \"<\": \"&lt;\",
	  \">\": \"&gt;\"
	};
	
	var TextElement = exports.TextElement = function (_ChantLayoutElement8) {
	  _inherits(TextElement, _ChantLayoutElement8);
	
	  function TextElement(ctxt, text, fontFamily, fontSize, textAnchor, sourceIndex, sourceGabc) {
	    _classCallCheck(this, TextElement);
	
	    // set these to some sane values for now...
	    var _this12 = _possibleConstructorReturn(this, (TextElement.__proto__ || Object.getPrototypeOf(TextElement)).call(this));
	
	    _this12.bounds.x = 0;
	    _this12.bounds.y = 0;
	    _this12.bounds.width = 0;
	    _this12.bounds.height = 0;
	    _this12.origin.x = 0;
	    _this12.origin.y = 0;
	
	    _this12.fontFamily = fontFamily;
	    _this12.fontSize = fontSize;
	    _this12.textAnchor = textAnchor;
	    _this12.sourceIndex = sourceIndex;
	    _this12.sourceGabc = sourceGabc;
	    _this12.dominantBaseline = \"baseline\"; // default placement
	
	    _this12.generateSpansFromText(ctxt, text);
	
	    _this12.recalculateMetrics(ctxt);
	    return _this12;
	  }
	
	  _createClass(TextElement, [{
	    key: \"getFromScore\",
	    value: function getFromScore(score) {
	      return this.textType.getFromScore(score, this);
	    }
	  }, {
	    key: \"generateSpansFromText\",
	    value: function generateSpansFromText(ctxt, text) {
	      var _this13 = this;
	
	      text = text.replace(/\\s+/g, \" \");
	      this.text = \"\";
	      this.spans = [];
	
	      // save ourselves a lot of grief for a very common text:
	      if (text === \"*\" || text === \"+\" || text === \"†\") {
	        var properties = text === \"*\" ? ctxt.asteriskProperties : text === \"+\" ? ctxt.plusProperties : null;
	        text = ctxt.specialCharText(text) || text;
	        this.spans.push(new TextSpan(text, properties));
	        return;
	      }
	
	      var markupStack = [];
	      var spanStartIndex = 0;
	      var newLineInNextSpan = 0;
	
	      var filterFrames = function filterFrames(frame, symbol) {
	        return frame.Symbol === symbol;
	      };
	
	      var closeSpan = function closeSpan(spanText, index, extraProperties) {
	        if (spanText === \"\" && !_this13.dropCap) return;
	
	        _this13.text += spanText;
	
	        var properties = {};
	        for (var i = 0; i < markupStack.length; i++) {
	          Object.assign(properties, markupStack[i].properties);
	        }if (extraProperties) Object.assign(properties, extraProperties);
	        if (newLineInNextSpan) {
	          properties.newLine = newLineInNextSpan;
	          newLineInNextSpan = 0;
	        }
	
	        _this13.spans.push(new TextSpan(spanText, properties, markupStack.map(function (frame) {
	          return frame.tagName;
	        }), index));
	      };
	
	      var markupRegex = /(<br\\/?>)|<v>([\\s\\S]*?)(?:<\\/v>|$)|(\\*)(?=\\s*\\*|[^*]*(?:$|<v>))|(\\+)|<sp>(?:(~)|(')?([ao]e|[æœaeiouy])|([arv])\\/)<\\/sp>|([arv])\\/\\.|([℣℟])\\.?|(?:([*_^%])|<(\\/)?([bciuv]|ul|sc|font)(?:\\s+(?:family=\"([^\"]+)\"|fill=\"([^\"]+)\"|class=\"([^\"]+)\"))*>)(?=(?:(.+?)(?:\\11|<\\/\\13>))?)/gi;
	      var vTagRegex = /(\\\\grecross)|\\{greextra\\}\\{([^}]*)\\}/g;
	      var match = null;
	      var openedAsterisk = false;
	      var closeCurrentSpan = function closeCurrentSpan() {
	        return closeSpan(text.substring(spanStartIndex, match.index), spanStartIndex);
	      };
	      while (match = markupRegex.exec(text)) {
	        var _match = match,
	            _match2 = _slicedToArray(_match, 18),
	            newLine = _match2[1],
	            vTag = _match2[2],
	            asterisk = _match2[3],
	            plus = _match2[4],
	            tilde = _match2[5],
	            accent = _match2[6],
	            vowelLigature = _match2[7],
	            specialChar = _match2[8],
	            specialChar2 = _match2[9],
	            specialChar3 = _match2[10],
	            markupSymbol = _match2[11],
	            closingTag = _match2[12],
	            tagName = _match2[13],
	            family = _match2[14],
	            fill = _match2[15],
	            cssClass = _match2[16],
	            enclosedText = _match2[17];
	
	        specialChar = specialChar || specialChar2 || specialChar3;
	        // non-matching symbols first
	        if (newLine) {
	          // close the current span, if any:
	          if (match.index > spanStartIndex) {
	            closeCurrentSpan();
	          }
	          // add the newline span:
	          newLineInNextSpan++;
	        } else if (vTag) {
	          closeCurrentSpan();
	          var vMatch = void 0;
	          var lastIndex = 0;
	          var iOffset = 0;
	          while (vMatch = vTagRegex.exec(vTag)) {
	            if (lastIndex < vMatch.index) {
	              closeSpan(vTag.slice(lastIndex, vMatch.index), match.index + lastIndex + iOffset);
	              iOffset = 3; // length of '<v>'
	            }
	
	            var _vMatch = vMatch,
	                _vMatch2 = _slicedToArray(_vMatch, 3),
	                grecross = _vMatch2[1],
	                greextra = _vMatch2[2];
	
	            if (grecross) {
	              // grecross is just the command for the Cross:
	              // set up greextra so it will get handled with it below:
	              greextra = 'Cross';
	            }
	            var char = _greextraGlyphs.greextraGlyphs[greextra];
	            if (char) {
	              closeSpan(char, match.index + vMatch.index + iOffset, { 'font-family': 'greextra' });
	            }
	            lastIndex = vTagRegex.lastIndex;
	            iOffset = 3; // length of '<v>'
	          }
	          if (lastIndex < vTag.length) {
	            closeSpan(vTag.slice(lastIndex), match.index + lastIndex + iOffset);
	          }
	        } else if (asterisk) {
	          closeCurrentSpan();
	          // first check if it is just a symbol to close:
	          if (markupStack.length > 0 && markupStack[markupStack.length - 1].symbol === asterisk) {
	            // close asterisk tag
	            markupStack.pop();
	          } else {
	            // add special asterisk:
	            closeSpan(ctxt.specialCharText(asterisk) || '*', match.index, ctxt.asteriskProperties);
	          }
	        } else if (plus) {
	          closeCurrentSpan();
	          closeSpan(ctxt.specialCharText(plus) || '+', match.index, ctxt.plusProperties);
	        } else if (tilde) {
	          closeCurrentSpan();
	          closeSpan('∼', match.index);
	        } else if (vowelLigature) {
	          var vowel = (0, _makeLigature.makeLigature)(vowelLigature);
	          if (accent) vowel = (0, _addAccent.addAccent)(vowel);
	          closeCurrentSpan();
	          closeSpan(vowel, match.index);
	        } else if (specialChar) {
	          closeCurrentSpan();
	          closeSpan(ctxt.textBeforeSpecialChar + ctxt.specialCharText(specialChar) + ctxt.textAfterSpecialChar, match.index, ctxt.specialCharProperties);
	        } else {
	          // otherwise we're dealing with matching markup delimeters
	          if (markupSymbol === \"*\") {
	            // we are only strict with the asterisk, because there are cases when it needs to be displayed rather than count as a markup symbol
	            if (enclosedText && /[^\\s*]/.test(enclosedText)) {
	              openedAsterisk = true;
	            } else if (openedAsterisk) {
	              openedAsterisk = false;
	            } else {
	              // actually use the asterisk, since it doesn't have a matching closing asterisk
	              continue;
	            }
	          }
	          if (markupSymbol) {
	            tagName = ctxt.markupSymbolDictionary[markupSymbol];
	            if (markupStack.length > 0 && markupStack[markupStack.length - 1].tagName === tagName && markupStack[markupStack.length - 1].symbol === markupSymbol) {
	              closingTag = true;
	            }
	          }
	          if (markupStack.length > 0 && markupStack[markupStack.length - 1].tagName === tagName) {
	            if (closingTag) {
	              // group close
	              closeCurrentSpan();
	              markupStack.pop();
	            }
	          } else if (markupStack.filter(filterFrames).length > 0) {
	            // trying to open a recursive group (or forgot to close a previous group)
	            // in either case, we just unwind to the previous stack frame
	            spanStartIndex = markupStack[markupStack.length - 1].startIndex;
	            markupStack.pop();
	            continue;
	          } else {
	            closeCurrentSpan();
	            if (closingTag) {
	              // out of order group close:
	              var index = markupStack.findIndex(function (frame) {
	                return frame.tagName === tagName;
	              });
	              if (index >= 0) {
	                markupStack.splice(index, 1);
	              }
	            } else {
	              // group open
	              var extraProperties = {};
	              if (family) extraProperties['font-family'] = family;
	              if (fill) extraProperties.fill = fill;
	              if (cssClass) extraProperties.class = cssClass;
	              markupStack.push(MarkupStackFrame.createStackFrame(ctxt, tagName, match.index, extraProperties, markupSymbol));
	            }
	          }
	        }
	
	        // advance the start index past the current markup
	        spanStartIndex = match.index + match[0].length;
	      }
	
	      // if we finished matches, and there is still some text left,
	      // or if we haven't generated any spans yet, create one final run
	      if (spanStartIndex < text.length || this.spans.length === 0) closeSpan(text.slice(spanStartIndex), spanStartIndex);
	    }
	  }, {
	    key: \"getCanvasFontForProperties\",
	    value: function getCanvasFontForProperties(ctxt) {
	      var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	
	      var font = \"\";
	      if (properties[\"font-style\"] === \"italic\") font += \"italic \";
	      if (properties[\"font-variant\"] === \"small-caps\") font += \"small-caps \";
	      if (properties[\"font-weight\"] === \"bold\") font += \"bold \";
	      var fontSize = parseFloat(properties[\"font-size\"]) || this.fontSize(ctxt);
	      if (/%$/.test(properties[\"font-size\"])) {
	        fontSize *= this.fontSize(ctxt) / 100;
	      }
	      font += fontSize * (this.resize || 1) + \"px \";
	      font += properties[\"font-family\"] || this.fontFamily(ctxt);
	      return font;
	    }
	  }, {
	    key: \"measureSubstringBBox\",
	    value: function measureSubstringBBox(ctxt, length) {
	      return this.measureSubstring(ctxt, length, true);
	    }
	
	    // if length is undefined and this.rightAligned === true, then offsets will be marked for each newLine span
	
	  }, {
	    key: \"measureSubstring\",
	    value: function measureSubstring(ctxt, length) {
	      var returnBBox = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	
	      if (length === 0) return 0;
	      if (!length) length = Infinity;
	      if (length < 0) {
	        var lines = -length;
	        length = Infinity;
	      }
	      var canvasCtxt = ctxt.canvasCtxt;
	      var width = 0;
	      var widths = [];
	      var newLineSpans = [this.spans[0]];
	      var subStringLength = 0;
	      var numLines = 1;
	      var fontSize = this.fontSize(ctxt) * (this.resize || 1);
	      var bbox = new _ExsurgeCore.Rect(0, 0, 0, 0);
	      for (var i = 0; i < this.spans.length; i++) {
	        var span = this.spans[i],
	            myText = span.text.slice(0, length - subStringLength);
	        if (span.properties.newLine) {
	          numLines += parseInt(span.properties.newLine) || 1;
	          if (!lines && this.rightAligned === true && length === Infinity) {
	            newLineSpans[newLineSpans.length - 1].properties.xOffset = this.firstLineMaxWidth - width;
	            newLineSpans.push(span);
	          } else if (--lines === 0) break;
	          widths.push(width);
	          width = 0;
	        }
	        if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Canvas) {
	          canvasCtxt.font = this.getCanvasFontForProperties(ctxt, span.properties);
	          var metrics = canvasCtxt.measureText(myText, width, fontSize * (numLines - 1));
	          if (\"actualBoundingBoxAscent\" in metrics) {
	            var left = metrics.actualBoundingBoxLeft;
	            bbox.union(new _ExsurgeCore.Rect(width - left, fontSize * (numLines - 1) - metrics.actualBoundingBoxAscent, metrics.width + left, metrics.actualBoundingBoxDescent + metrics.actualBoundingBoxAscent));
	            if (this instanceof DropCap) {
	              width += Math.max(0, left);
	            }
	          } else {
	            bbox.union(new _ExsurgeCore.Rect(width, fontSize * (numLines - 2), metrics.width, fontSize));
	          }
	          width += metrics.width;
	        } else if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.OpenTypeJS && ctxt.fontDictionary) {
	          // get the bounding box for the substring, placing it at x = width, y = fontSize * (numLines - 1)
	          var font = ctxt.getFontForProperties(span.properties, span.properties[\"font-family\"] || this.fontFamily(ctxt));
	          var options = { features: { liga: true } };
	          if (span.properties[\"font-variant\"] === \"small-caps\") {
	            options.features.smcp = true;
	          }
	          var spanFontSize = parseFloat(span.properties[\"font-size\"]) || fontSize;
	          if (/%$/.test(span.properties[\"font-size\"])) {
	            spanFontSize *= fontSize / 100;
	          }
	          var subBbox = font.getPath(myText, width, fontSize * (numLines - 1), spanFontSize, options).getBoundingBox();
	          var subWidth = font.getAdvanceWidth(myText, spanFontSize, options);
	
	          bbox.union(new _ExsurgeCore.Rect(width + subBbox.x1, subBbox.y1, subWidth - subBbox.x1, subBbox.y2 - subBbox.y1));
	          width += subWidth;
	          if (this instanceof DropCap) {
	            width -= subBbox.x1;
	          }
	        }
	        subStringLength += myText.length;
	        if (subStringLength === length) break;
	      }
	      if (!lines && width && newLineSpans.length && this.rightAligned === true && length === Infinity) {
	        newLineSpans[newLineSpans.length - 1].properties.xOffset = this.firstLineMaxWidth - width;
	      }
	      width = Math.max.apply(Math, [width].concat(widths));
	      if (returnBBox === true) {
	        var height = bbox.height;
	        var y = bbox.y,
	            x = bbox.x;
	        return { width: width, height: height, x: x, y: y };
	      } else {
	        return width;
	      }
	    }
	  }, {
	    key: \"recalculateMetrics\",
	    value: function recalculateMetrics(ctxt) {
	      var resetNewLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	      if (resetNewLines) {
	        delete this.maxWidth;
	        delete this.firstLineMaxWidth;
	        delete this.rightAligned;
	        delete this.resize;
	        delete this.numLines;
	        // replace newlines with spaces
	        this.spans.forEach(function (span) {
	          delete span.properties.xOffset;
	          if (span.properties.newLine === true) {
	            delete span.properties.newLine;
	            span.text = \" \" + span.text;
	          }
	        });
	      }
	
	      this.bounds.x = 0;
	      this.bounds.y = 0;
	
	      this.origin.x = 0;
	
	      if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Svg) {
	        while (ctxt.svgTextMeasurer.firstChild) {
	          ctxt.svgTextMeasurer.removeChild(ctxt.svgTextMeasurer.firstChild);
	        }ctxt.svgTextMeasurer.appendChild(this.createSvgNode(ctxt));
	        ctxt.svgTextMeasurer.appendChild(ctxt.createStyleNode());
	
	        var bbox = ctxt.svgTextMeasurer.firstChild.getBBox();
	        this.bounds.width = bbox.width;
	        this.bounds.height = bbox.height;
	        this.origin.y = -bbox.y; // offset to baseline from top
	        this.origin.x = -bbox.x;
	      } else {
	        var _bbox = this.measureSubstringBBox(ctxt);
	        this.bounds.width = _bbox.width;
	        this.bounds.height = _bbox.height;
	        this.origin.y = -_bbox.y;
	        this.origin.x = -_bbox.x;
	      }
	      this.numLines = this.spans.reduce(function (result, span) {
	        return result + (span.properties.newLine ? parseInt(span.properties.newLine) || 1 : 0);
	      }, 1);
	    }
	  }, {
	    key: \"setMaxWidth\",
	    value: function setMaxWidth(ctxt, maxWidth) {
	      var firstLineMaxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : maxWidth;
	
	      if (this.spans.filter(function (s) {
	        return s.properties.newLine === true;
	      }).length) {
	        // first get rid of any new lines set from a previous maxWidth
	        this.recalculateMetrics(ctxt);
	      }
	      if (this.bounds.width > maxWidth) {
	        this.maxWidth = maxWidth;
	        var percentage = maxWidth / this.bounds.width;
	        if (this instanceof Lyric && percentage >= 0.85) {
	          this.resize = percentage;
	        } else {
	          if (firstLineMaxWidth < 0) firstLineMaxWidth = maxWidth;
	          this.firstLineMaxWidth = firstLineMaxWidth;
	          var lastWidth = 0,
	              lastMatch = null,
	              regex = /\\s+|$/g,
	              max = firstLineMaxWidth,
	              match;
	          while ((match = regex.exec(this.text)) && (!lastMatch || match.index > lastMatch.index)) {
	            var width = this.measureSubstring(ctxt, match.index);
	            if (width > max && lastMatch) {
	              var _spans;
	
	              var spanIndex = 0,
	                  length = 0;
	              while (length < lastMatch.index && spanIndex < this.spans.length) {
	                var span = this.spans[spanIndex++];
	                length += span.text.length + (span.properties.newLine ? 1 : 0);
	              }
	              if (length > lastMatch.index) {
	                var _span = this.spans[--spanIndex];
	                length -= _span.text.length;
	              }
	              var splitSpan = this.spans[spanIndex],
	                  textLeft = splitSpan.text.slice(0, lastMatch.index - length),
	                  textRight = splitSpan.text.slice(lastMatch.index + lastMatch[0].length - length),
	                  newSpans = [];
	              this.rightAligned = max === firstLineMaxWidth && firstLineMaxWidth !== maxWidth;
	              if (textLeft) newSpans.push(new TextSpan(textLeft, splitSpan.properties, splitSpan.activeTags));
	              if (textRight) {
	                newSpans.push(new TextSpan(textRight, Object.assign({}, splitSpan.properties, { newLine: true }), splitSpan.activeTags));
	              } else if (this.spans[spanIndex + 1]) {
	                this.spans[spanIndex + 1].properties.newLine = true;
	              }
	              (_spans = this.spans).splice.apply(_spans, [spanIndex, 1].concat(newSpans));
	              this.needsLayout = true;
	              max = maxWidth;
	              if (match.index === this.text.length || this.measureSubstring(ctxt) <= maxWidth) break;
	              width = 0;
	              match = lastMatch = null;
	            }
	            lastWidth = width;
	            lastMatch = match;
	          }
	        }
	        this.recalculateMetrics(ctxt, false);
	      }
	    }
	  }, {
	    key: \"getCssClasses\",
	    value: function getCssClasses() {
	      return this.textType && this.textType.cssClass || \"\";
	    }
	  }, {
	    key: \"getExtraStyleProperties\",
	    value: function getExtraStyleProperties(ctxt) {
	      return ctxt.baseTextStyle || {};
	    }
	  }, {
	    key: \"draw\",
	    value: function draw(ctxt) {
	      var canvasCtxt = ctxt.canvasCtxt;
	
	      if (this.textAnchor === \"middle\") canvasCtxt.textAlign = \"center\";else canvasCtxt.textAlign = \"start\";
	
	      var translateWidth = 0,
	          translateHeight = 0;
	      for (var i = 0; i < this.spans.length; i++) {
	        var span = this.spans[i];
	        var xOffset = span.properties.xOffset || 0;
	        if (span.properties.newLine) {
	          count = parseInt(span.properties.newLine) || 1;
	          canvasCtxt.translate(translateWidth + xOffset, this.fontSize(ctxt) * count);
	          translateWidth = -xOffset;
	          translateHeight -= this.fontSize(ctxt);
	        } else if (xOffset) {
	          canvasCtxt.translate(translateWidth + xOffset, 0);
	          translateWidth = -xOffset;
	        }
	        var properties = Object.assign({}, this.getExtraStyleProperties(ctxt), span.properties);
	        canvasCtxt.font = this.getCanvasFontForProperties(ctxt, properties);
	        canvasCtxt.fillStyle = properties.fill || \"#000\";
	        canvasCtxt.fillText(span.text, this.bounds.x, this.bounds.y, span.properties.textLength || undefined);
	        var metrics = canvasCtxt.measureText(span.text, this.bounds.x, this.bounds.y);
	        translateWidth -= metrics.width;
	        canvasCtxt.translate(metrics.width, 0);
	      }
	      canvasCtxt.translate(translateWidth, translateHeight);
	    }
	  }, {
	    key: \"getSvgProps\",
	    value: function getSvgProps() {
	      return {
	        \"source-index\": this.sourceIndex,
	        x: this.bounds.x,
	        y: this.bounds.y,
	        class: this.getCssClasses().trim(),
	        \"text-anchor\": this.textAnchor
	        //'dominant-baseline': this.dominantBaseline, // hanging baseline doesn't work in Safari
	      };
	    }
	  }, {
	    key: \"getSpanOptions\",
	    value: function getSpanOptions(span, ctxt) {
	      var useStyleObject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	
	      var options = {
	        \"source-index\": span.index,
	        class: span.properties.class,
	        style: useStyleObject ? Object.assign({}, span.properties) : (0, _ExsurgeCore.getCssForProperties)(span.properties)
	      };
	
	      if (span.properties.newLine) {
	        var xOffset = span.properties.xOffset || 0;
	        options.dy = 1.1 * (parseInt(span.properties.newLine) || 1) + \"em\";
	        options.x = this.bounds.x + xOffset;
	      } else if (span.properties.xOffset) {
	        options.x = this.bounds.x + span.properties.xOffset;
	      }
	      if (span.properties.textLength) {
	        options.textLength = span.properties.textLength;
	        options.lengthAdjust = \"spacingAndGlyphs\";
	        options.y = this.bounds.y;
	      }
	      if (this.resize) {
	        options[\"font-size\"] = span.properties[\"font-size\"] || this.fontSize(ctxt) * this.resize;
	      }
	      // if (ctxt.setFontFamilyAttributes) {
	      //   options[\"font-family\"] =
	      //     span.properties[\"font-family\"] ||
	      //     getFontFilenameForProperties(span.properties, this.fontFamily(ctxt));
	      //   let properties = Object.assign({}, span.properties);
	      //   delete properties[\"font-weight\"];
	      //   delete properties[\"font-style\"];
	      //   options[\"style\"] = getCssForProperties(properties);
	      // } else {
	      //   options[\"style\"] = getCssForProperties(span.properties);
	      // }
	
	      return options;
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      var spans = [];
	
	      for (var i = 0; i < this.spans.length; i++) {
	        var span = this.spans[i];
	        var _options = this.getSpanOptions(span, ctxt);
	
	        spans.push(QuickSvg.createNode(\"tspan\", _options, span.text));
	      }
	
	      var options = this.getSvgProps();
	      var extraStyleProperties = this.getExtraStyleProperties(ctxt);
	      options.style = (0, _ExsurgeCore.getCssForProperties)(extraStyleProperties);
	      if (extraStyleProperties.class) {
	        options.class = extraStyleProperties.class + ' ' + options.class;
	      }
	      options.source = this;
	
	      return this.svgNode = QuickSvg.createNode(\"text\", options, spans);
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt) {
	      var spans = [];
	
	      for (var i = 0; i < this.spans.length; i++) {
	        var span = this.spans[i];
	        var _options2 = this.getSpanOptions(span, ctxt, true);
	
	        spans.push(QuickSvg.createSvgTree(\"tspan\", _options2, span.text));
	      }
	
	      var options = this.getSvgProps();
	      options.style = this.getExtraStyleProperties(ctxt);
	      if (options.style.class) {
	        options.class = options.style.class + ' ' + options.class;
	      }
	      options.source = this;
	
	      return QuickSvg.createSvgTree.apply(QuickSvg, [\"text\", options].concat(spans));
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      var spans = \"\";
	
	      for (var i = 0; i < this.spans.length; i++) {
	        var span = this.spans[i];
	        var _options3 = this.getSpanOptions(span, ctxt);
	
	        spans += QuickSvg.createFragment(\"tspan\", _options3, TextElement.escapeForTspan(span.text));
	      }
	
	      var options = this.getSvgProps();
	      var extraStyleProperties = this.getExtraStyleProperties(ctxt);
	      options.style = (0, _ExsurgeCore.getCssForProperties)(extraStyleProperties);
	      if (extraStyleProperties.class) {
	        options.class = extraStyleProperties.class + ' ' + options.class;
	      }
	      if (ctxt.setFontFamilyAttributes) {
	        options[\"font-size\"] = this.fontSize(ctxt);
	      }
	
	      return QuickSvg.createFragment(\"text\", options, spans);
	    }
	  }], [{
	    key: \"escapeForTspan\",
	    value: function escapeForTspan(string) {
	      return String(string).replace(/[&<>]/g, function (s) {
	        return __subsForTspans[s];
	      });
	    }
	  }]);
	
	  return TextElement;
	}(ChantLayoutElement);
	
	var LyricType = exports.LyricType = {
	  SingleSyllable: 0,
	  BeginningSyllable: 1,
	  MiddleSyllable: 2,
	  EndingSyllable: 3,
	
	  Directive: 4 // for asterisks, \"ij.\" elements, or other performance notes.
	};
	
	var LyricArray = exports.LyricArray = {
	  getLeft: function getLeft(lyricArray) {
	    if (lyricArray.length === 0) return NaN;
	
	    var x = Number.MAX_VALUE;
	    for (var i = 0; i < lyricArray.length; i++) {
	      if (lyricArray[i]) x = Math.min(x, lyricArray[i].notation.bounds.x + lyricArray[i].bounds.x);
	    }
	
	    return x;
	  },
	
	  getRight: function getRight(lyricArray, presumeConnectorNeeded) {
	    if (lyricArray.length === 0) return NaN;
	
	    var x = Number.MIN_VALUE;
	    for (var i = 0; i < lyricArray.length; i++) {
	      var l = lyricArray[i];
	      if (l) x = Math.max(x, l.notation.bounds.x + l.bounds.x + l.bounds.width + (presumeConnectorNeeded && l.allowsConnector() && !l.needsConnector ? l.getConnectorWidth() : 0));
	    }
	
	    return x;
	  },
	
	  hasOnlyOneLyric: function hasOnlyOneLyric(lyricArray) {
	    return lyricArray.filter(function (l) {
	      return l.originalText;
	    }).length === 1;
	  },
	
	  indexOfLyric: function indexOfLyric(lyricArray) {
	    return lyricArray.indexOf(lyricArray.filter(function (l) {
	      return l.originalText;
	    })[0]);
	  },
	
	  mergeIn: function mergeIn(lyricArray, newLyrics) {
	    for (var i = 0; i < newLyrics.length; ++i) {
	      if (newLyrics[i].originalText || !lyricArray[i]) lyricArray[i] = newLyrics[i];
	    }
	  },
	
	  mergeInArray: function mergeInArray(lyricArray, notations) {
	    for (var i = 0; i < notations.length; ++i) {
	      this.mergeIn(lyricArray, notations[i].lyrics);
	    }
	  },
	
	  setNotation: function setNotation(lyricArray, notation) {
	    notation.lyrics = lyricArray;
	    for (var i = 0; i < lyricArray.length; ++i) {
	      lyricArray[i].notation = notation;
	    }
	  }
	};
	
	var Lyric = exports.Lyric = function (_TextElement) {
	  _inherits(Lyric, _TextElement);
	
	  function Lyric(ctxt, text, lyricType, notation, notations, sourceIndex) {
	    _classCallCheck(this, Lyric);
	
	    var _this14 = _possibleConstructorReturn(this, (Lyric.__proto__ || Object.getPrototypeOf(Lyric)).call(this, ctxt, (ctxt.textStyles.lyric.prefix || \"\") + text, function (ctxt) {
	      return ctxt.textStyles.lyric.font;
	    }, function (ctxt) {
	      return ctxt.textStyles.lyric.size;
	    }, \"start\", sourceIndex, text));
	
	    _this14.textType = TextTypes.lyric;
	
	    // save the original text in case we need to later use the lyric
	    // in a dropcap...
	    _this14.originalText = text;
	
	    _this14.notation = notation;
	    _this14.notations = notations;
	
	    if (typeof lyricType === \"undefined\" || lyricType === null || lyricType === \"\") _this14.lyricType = LyricType.SingleSyllable;else _this14.lyricType = lyricType;
	
	    // Lyrics keep track of how to center them on notation elements.
	    // centerTextIndex is the index in this.text where the centering starts,
	    // centerLength is how many characters comprise the center point.
	    // performLayout will do the processing
	    _this14.centerStartIndex = -1;
	    _this14.centerLength = text.length;
	
	    _this14.needsConnector = false;
	
	    // Lyrics can have their own language defined, which affects the alignment
	    // of the text with the notation element
	    _this14.language = null;
	
	    if (_this14.allowsConnector) _this14.connectorSpan = new TextSpan(ctxt.syllableConnector);
	    return _this14;
	  }
	
	  _createClass(Lyric, [{
	    key: \"allowsConnector\",
	    value: function allowsConnector() {
	      return this.lyricType === LyricType.BeginningSyllable || this.lyricType === LyricType.MiddleSyllable;
	    }
	  }, {
	    key: \"setForceConnector\",
	    value: function setForceConnector(force) {
	      this.forceConnector = force && this.allowsConnector();
	    }
	  }, {
	    key: \"setNeedsConnector\",
	    value: function setNeedsConnector(needs, width) {
	      if (needs === true || this.forceConnector) {
	        this.needsConnector = true;
	        if (typeof width !== \"undefined\") {
	          this.setConnectorWidth(width);
	        } else {
	          this.bounds.width = this.widthWithoutConnector + this.getConnectorWidth();
	        }
	
	        if (this.spans.length > 0 && this.spans[this.spans.length - 1] !== this.connectorSpan) this.spans.push(this.connectorSpan);
	      } else {
	        this.connectorWidth = 0;
	        this.needsConnector = false;
	        this.bounds.width = this.widthWithoutConnector;
	
	        var span = this.spans.pop();
	        if (span && span !== this.connectorSpan) this.spans.push(span);
	      }
	    }
	  }, {
	    key: \"setConnectorWidth\",
	    value: function setConnectorWidth(width) {
	      this.connectorWidth = width;
	      this.connectorSpan.properties = Object.assign({}, this.connectorSpan.properties, { textLength: width });
	      if (this.needsConnector) this.bounds.width = this.widthWithoutConnector + this.getConnectorWidth();
	    }
	  }, {
	    key: \"getConnectorWidth\",
	    value: function getConnectorWidth() {
	      return this.connectorWidth || this.defaultConnectorWidth;
	    }
	  }, {
	    key: \"getLeft\",
	    value: function getLeft() {
	      return this.notation.bounds.x + this.bounds.x;
	    }
	  }, {
	    key: \"getRight\",
	    value: function getRight() {
	      return this.notation.bounds.x + this.bounds.x + this.bounds.width;
	    }
	  }, {
	    key: \"recalculateMetrics\",
	    value: function recalculateMetrics(ctxt) {
	      var resetNewLines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	      this.setNeedsConnector();
	
	      _get(Lyric.prototype.__proto__ || Object.getPrototypeOf(Lyric.prototype), \"recalculateMetrics\", this).call(this, ctxt, resetNewLines);
	
	      this.widthWithoutConnector = this.bounds.width;
	
	      this.connectorWidth = 0;
	      this.defaultConnectorWidth = ctxt.hyphenWidth;
	
	      var activeLanguage = this.language || ctxt.defaultLanguage;
	
	      // calculate the point where the text lines up to the staff notation
	      // and offset the rect that much. By default we just center the text,
	      // but the logic below allows for smarter lyric alignment based
	      // on manual override or language control.
	      var offset = this.widthWithoutConnector / 2,
	          x1,
	          x2,
	          vowelSegmentWidth = this.widthWithoutConnector;
	
	      // some simple checks for sanity, and disable manual centering if the numbers are bad
	      if (this.centerStartIndex >= 0 && (this.centerStartIndex >= this.text.length || this.centerLength < 0 || this.centerStartIndex + this.centerLength > this.text.length)) this.centerStartIndex = -1;
	
	      if (this.text.length === 0) {
	        // if we have no text to work with, then there's nothing to do!
	        // Unless it's a drop cap, in which case we center the connector:
	        if (this.dropCap && this.originalText) {
	          offset = ctxt.hyphenWidth / 2;
	          vowelSegmentWidth = ctxt.hyphenWidth;
	        }
	      } else if (this.centerStartIndex >= 0) {
	        // if we have manually overriden the centering logic for this lyric,
	        // then always use that.
	        if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Svg) {
	          // svgTextMeasurer still has the current lyric in it...
	          x1 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(0, this.centerStartIndex);
	          x2 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(0, this.centerStartIndex + this.centerLength);
	        } else {
	          x1 = this.measureSubstring(ctxt, this.centerStartIndex);
	          x2 = this.measureSubstring(ctxt, this.centerStartIndex + this.centerLength);
	        }
	        offset = (x1 + x2) / 2;
	        vowelSegmentWidth = x2 - x1;
	      } else {
	        // if it's a directive with no manual centering override, then
	        // just center the text.
	        if (this.lyricType !== LyricType.Directive) {
	          // only consider text content after the last space (if any)
	          var startIndex = this.text.lastIndexOf(\" \") + 1;
	
	          // unless there are no text characters following the space:
	          if (startIndex > 0 && !this.text.slice(startIndex).match(/[a-záéíóúýäëïöüÿàèìòùỳāēīōūȳăĕĭŏŭ]/i)) {
	            startIndex = 0;
	          }
	
	          // Non-directive elements are lined up to the chant notation based on vowel segments,
	          var result = activeLanguage.findVowelSegment(this.text, startIndex);
	
	          if (result.found !== true) {
	            var match = this.text.slice(startIndex).match(/[a-z]+/i);
	            if (match) {
	              result.startIndex = startIndex + match.index;
	              result.length = match[0].length;
	            } else {
	              result.startIndex = startIndex;
	              result.length = this.text.length - startIndex;
	            }
	          }
	          if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Svg) {
	            // svgTextMeasurer still has the current lyric in it...
	            x1 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(0, result.startIndex);
	            x2 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(0, result.startIndex + result.length);
	          } else {
	            x1 = this.measureSubstring(ctxt, result.startIndex);
	            x2 = this.measureSubstring(ctxt, result.startIndex + result.length);
	          }
	          offset = (x1 + x2) / 2;
	          vowelSegmentWidth = x2 - x1;
	        }
	      }
	
	      this.vowelSegmentWidth = vowelSegmentWidth;
	
	      this.bounds.x = -offset;
	      this.bounds.y = 0;
	
	      this.origin.x = offset;
	    }
	  }, {
	    key: \"generateDropCap\",
	    value: function generateDropCap(ctxt) {
	      if (this.dropCap) return this.dropCap;
	      // disallow special characters:
	      if (this.spans[0].properties['font-family'] === ctxt.specialCharProperties['font-family']) {
	        return null;
	      }
	      var dropCapSpan = this.spans[0].clone();
	      dropCapSpan.text = dropCapSpan.text.slice(0, 1).toUpperCase();
	      var dropCapLowerCase = dropCapSpan.text.toLowerCase();
	      // disallow any characters that do not change from .toUpperCase():
	      if (dropCapSpan.text === dropCapLowerCase) return null;
	
	      if (dropCapSpan.activeTags.indexOf(\"sc\") >= 0) dropCapSpan.text = dropCapLowerCase;
	
	      var dropCap = this.dropCap = new DropCap(ctxt, \"\", this.sourceIndex);
	      dropCap.spans = [dropCapSpan];
	      var dropCapSourceGabcLength = this.sourceGabc.match(/^(?:<\\/?[^>]>)*.?(?:<\\/[^>]>)*/)[0].length;
	      dropCap.sourceGabc = this.sourceGabc.slice(0, dropCapSourceGabcLength);
	      this.sourceIndex += dropCap.sourceGabc.length;
	      this.sourceGabc = this.sourceGabc.slice(dropCapSourceGabcLength);
	
	      this.spans[0].text = this.spans[0].text.slice(1);
	      this.text = this.text.slice(1);
	      this.centerStartIndex--; // lost a letter, so adjust centering accordingly
	
	      return dropCap;
	    }
	  }, {
	    key: \"getCssClasses\",
	    value: function getCssClasses() {
	      var classes = this.lyricType === LyricType.Directive ? \"directive \" : \"\";
	
	      return classes + _get(Lyric.prototype.__proto__ || Object.getPrototypeOf(Lyric.prototype), \"getCssClasses\", this).call(this);
	    }
	  }, {
	    key: \"getExtraStyleProperties\",
	    value: function getExtraStyleProperties(ctxt) {
	      var props = _get(Lyric.prototype.__proto__ || Object.getPrototypeOf(Lyric.prototype), \"getExtraStyleProperties\", this).call(this, ctxt);
	
	      if (this.lyricType === LyricType.Directive && ctxt.autoColor === true) props = Object.assign({}, props, { fill: ctxt.rubricColor });
	
	      return props;
	    }
	  }]);
	
	  return Lyric;
	}(TextElement);
	
	var ChoralSign = exports.ChoralSign = function (_TextElement2) {
	  _inherits(ChoralSign, _TextElement2);
	
	  function ChoralSign(ctxt, text, note, sourceIndex) {
	    _classCallCheck(this, ChoralSign);
	
	    var _this15 = _possibleConstructorReturn(this, (ChoralSign.__proto__ || Object.getPrototypeOf(ChoralSign)).call(this, ctxt, (ctxt.textStyles.choralSign.prefix || \"\") + text, function (ctxt) {
	      return ctxt.textStyles.choralSign.font;
	    }, TextTypes.choralSign.size, \"start\", sourceIndex, text));
	
	    _this15.positionHint = MarkingPositionHint.Default;
	    _this15.note = note;
	    _this15.textType = TextTypes.choralSign;
	    return _this15;
	  }
	
	  _createClass(ChoralSign, [{
	    key: \"recalculateMetrics\",
	    value: function recalculateMetrics(ctxt) {
	      _get(ChoralSign.prototype.__proto__ || Object.getPrototypeOf(ChoralSign.prototype), \"recalculateMetrics\", this).call(this, ctxt);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      this.recalculateMetrics(ctxt);
	      this.bounds.x = this.note.bounds.x + Math.max(0, (ctxt.staffInterval - this.bounds.width) / 2); // center on the note itself
	
	      var offset = void 0,
	          staffPosition = void 0;
	      if (this.positionHint === MarkingPositionHint.Below) {
	        offset = -1;
	        staffPosition = this.note.staffPosition + 2 * offset;
	        staffPosition += staffPosition % 2 === 0 ? 0.3 : 1;
	      } else {
	        offset = 1;
	        staffPosition = this.note.staffPosition + 2 * offset;
	        staffPosition += staffPosition % 2 === 0 ? 0.3 : -0.4;
	      }
	      // if (staffPosition % 2 === 0) staffPosition += offset;
	      this.bounds.y = ctxt.calculateHeightFromStaffPosition(staffPosition) + this.origin.y;
	    }
	  }]);
	
	  return ChoralSign;
	}(TextElement);
	
	var AboveLinesText = exports.AboveLinesText = function (_TextElement3) {
	  _inherits(AboveLinesText, _TextElement3);
	
	  /**
	   * @param {String} text
	   */
	  function AboveLinesText(ctxt, text, notation, sourceIndex) {
	    _classCallCheck(this, AboveLinesText);
	
	    var _this16 = _possibleConstructorReturn(this, (AboveLinesText.__proto__ || Object.getPrototypeOf(AboveLinesText)).call(this, ctxt, (ctxt.textStyles.al.prefix || \"\") + text, function (ctxt) {
	      return ctxt.textStyles.al.font;
	    }, function (ctxt) {
	      return ctxt.textStyles.al.size;
	    }, \"start\", sourceIndex, text));
	
	    _this16.notation = notation;
	    _this16.textType = TextTypes.al;
	
	    _this16.padding = ctxt.staffInterval / 2;
	    return _this16;
	  }
	
	  return AboveLinesText;
	}(TextElement);
	
	var TranslationText = exports.TranslationText = function (_TextElement4) {
	  _inherits(TranslationText, _TextElement4);
	
	  /**
	   * @param {String} text
	   */
	  function TranslationText(ctxt, text, notation, sourceIndex) {
	    _classCallCheck(this, TranslationText);
	
	    var gabcSource = text;
	    var anchor = \"start\";
	    if (text === \"/\") {
	      text = \"\";
	      anchor = \"end\";
	    } else {
	      text = (ctxt.textStyles.translation.prefix || \"\") + text;
	    }
	
	    var _this17 = _possibleConstructorReturn(this, (TranslationText.__proto__ || Object.getPrototypeOf(TranslationText)).call(this, ctxt, text, function (ctxt) {
	      return ctxt.textStyles.translation.font;
	    }, function (ctxt) {
	      return ctxt.textStyles.translation.size;
	    }, anchor, sourceIndex, gabcSource));
	
	    _this17.notation = notation;
	    _this17.textType = TextTypes.translation;
	
	    _this17.padding = ctxt.staffInterval / 2;
	    return _this17;
	  }
	
	  return TranslationText;
	}(TextElement);
	
	var DropCap = exports.DropCap = function (_TextElement5) {
	  _inherits(DropCap, _TextElement5);
	
	  /**
	   * @param {String} text
	   */
	  function DropCap(ctxt, text, sourceIndex) {
	    _classCallCheck(this, DropCap);
	
	    var _this18 = _possibleConstructorReturn(this, (DropCap.__proto__ || Object.getPrototypeOf(DropCap)).call(this, ctxt, (ctxt.textStyles.dropCap.prefix || \"\") + text, function (ctxt) {
	      return ctxt.textStyles.dropCap.font;
	    }, function (ctxt) {
	      return ctxt.textStyles.dropCap.size;
	    }, \"middle\", sourceIndex, text));
	
	    _this18.textType = TextTypes.dropCap;
	
	    _this18.padding = ctxt.staffInterval * ctxt.textStyles.dropCap.padding;
	    return _this18;
	  }
	
	  return DropCap;
	}(TextElement);
	
	var TitleTextElement = exports.TitleTextElement = function (_TextElement6) {
	  _inherits(TitleTextElement, _TextElement6);
	
	  function TitleTextElement(ctxt, text, fontFamily, fontSize, textAnchor, sourceIndex, sourceGabc) {
	    _classCallCheck(this, TitleTextElement);
	
	    return _possibleConstructorReturn(this, (TitleTextElement.__proto__ || Object.getPrototypeOf(TitleTextElement)).call(this, ctxt, text, fontFamily, fontSize, textAnchor, sourceIndex, sourceGabc));
	  }
	
	  return TitleTextElement;
	}(TextElement);
	
	var Supertitle = exports.Supertitle = function (_TitleTextElement) {
	  _inherits(Supertitle, _TitleTextElement);
	
	  function Supertitle(ctxt, text, sourceIndex) {
	    _classCallCheck(this, Supertitle);
	
	    var _this20 = _possibleConstructorReturn(this, (Supertitle.__proto__ || Object.getPrototypeOf(Supertitle)).call(this, ctxt, (ctxt.textStyles.supertitle.prefix || \"\") + text, function (ctxt) {
	      return ctxt.textStyles.supertitle.font;
	    }, function (ctxt) {
	      return ctxt.textStyles.supertitle.size;
	    }, \"middle\", sourceIndex, text));
	
	    _this20.textType = TextTypes.supertitle;
	
	    _this20.padding = function (ctxt) {
	      return (Number(ctxt.textStyles.supertitle.padding) || 1) * ctxt.textStyles.supertitle.size / 3;
	    };
	    return _this20;
	  }
	
	  return Supertitle;
	}(TitleTextElement);
	
	var Title = exports.Title = function (_TitleTextElement2) {
	  _inherits(Title, _TitleTextElement2);
	
	  function Title(ctxt, text, sourceIndex) {
	    _classCallCheck(this, Title);
	
	    var _this21 = _possibleConstructorReturn(this, (Title.__proto__ || Object.getPrototypeOf(Title)).call(this, ctxt, (ctxt.textStyles.title.prefix || \"\") + text, function (ctxt) {
	      return ctxt.textStyles.title.font;
	    }, function (ctxt) {
	      return ctxt.textStyles.title.size;
	    }, \"middle\", sourceIndex, text));
	
	    _this21.textType = TextTypes.title;
	
	    _this21.padding = function (ctxt) {
	      return (Number(ctxt.textStyles.title.padding) || 1) * ctxt.textStyles.title.size / 3;
	    };
	    return _this21;
	  }
	
	  return Title;
	}(TitleTextElement);
	
	var Subtitle = exports.Subtitle = function (_TitleTextElement3) {
	  _inherits(Subtitle, _TitleTextElement3);
	
	  function Subtitle(ctxt, text, sourceIndex) {
	    _classCallCheck(this, Subtitle);
	
	    var _this22 = _possibleConstructorReturn(this, (Subtitle.__proto__ || Object.getPrototypeOf(Subtitle)).call(this, ctxt, (ctxt.textStyles.subtitle.prefix || \"\") + text, function (ctxt) {
	      return ctxt.textStyles.subtitle.font;
	    }, function (ctxt) {
	      return ctxt.textStyles.subtitle.size;
	    }, \"middle\", sourceIndex, text));
	
	    _this22.textType = TextTypes.subtitle;
	
	    _this22.padding = function (ctxt) {
	      return (Number(ctxt.textStyles.subtitle.padding) || 1) * ctxt.textStyles.subtitle.size / 3;
	    };
	    return _this22;
	  }
	
	  return Subtitle;
	}(TitleTextElement);
	
	var TextLeftRight = exports.TextLeftRight = function (_TitleTextElement4) {
	  _inherits(TextLeftRight, _TitleTextElement4);
	
	  function TextLeftRight(ctxt, text, type, sourceIndex) {
	    _classCallCheck(this, TextLeftRight);
	
	    var _this23 = _possibleConstructorReturn(this, (TextLeftRight.__proto__ || Object.getPrototypeOf(TextLeftRight)).call(this, ctxt, (ctxt.textStyles.leftRight.prefix || \"\") + text, function (ctxt) {
	      return ctxt.textStyles.leftRight.font;
	    }, function (ctxt) {
	      return ctxt.textStyles.leftRight.size;
	    }, type === \"textLeft\" ? \"start\" : \"end\", sourceIndex, text));
	
	    _this23.textType = TextTypes.leftRight;
	    _this23.extraClass = type === \"textLeft\" ? \"textLeft\" : \"textRight\";
	    _this23.headerKey = type === \"textLeft\" ? \"text-left\" : \"text-right\";
	    _this23.padding = function (ctxt) {
	      return (Number(ctxt.textStyles.leftRight.padding) || 1) * ctxt.textStyles.leftRight.size / 5;
	    };
	    return _this23;
	  }
	
	  _createClass(TextLeftRight, [{
	    key: \"getCssClasses\",
	    value: function getCssClasses() {
	      return this.extraClass + \" \" + _get(TextLeftRight.prototype.__proto__ || Object.getPrototypeOf(TextLeftRight.prototype), \"getCssClasses\", this).call(this);
	    }
	  }]);
	
	  return TextLeftRight;
	}(TitleTextElement);
	
	var Annotation = exports.Annotation = function (_TextElement7) {
	  _inherits(Annotation, _TextElement7);
	
	  /**
	   * @param {String} text
	   */
	  function Annotation(ctxt, text) {
	    _classCallCheck(this, Annotation);
	
	    var _this24 = _possibleConstructorReturn(this, (Annotation.__proto__ || Object.getPrototypeOf(Annotation)).call(this, ctxt, (ctxt.textStyles.annotation.prefix || \"\") + text, function (ctxt) {
	      return ctxt.textStyles.annotation.font;
	    }, function (ctxt) {
	      return ctxt.textStyles.annotation.size;
	    }, \"middle\"));
	
	    _this24.textType = TextTypes.annotation;
	    _this24.padding = ctxt.staffInterval * ctxt.textStyles.annotation.padding;
	    _this24.dominantBaseline = \"hanging\"; // so that annotations can be aligned at the top.
	    return _this24;
	  }
	
	  return Annotation;
	}(TextElement);
	
	var Annotations = exports.Annotations = function (_ChantLayoutElement9) {
	  _inherits(Annotations, _ChantLayoutElement9);
	
	  /**
	   * @param {String} text
	   */
	  function Annotations(ctxt) {
	    _classCallCheck(this, Annotations);
	
	    var _this25 = _possibleConstructorReturn(this, (Annotations.__proto__ || Object.getPrototypeOf(Annotations)).call(this));
	
	    _this25.lineHeight = 1.1;
	
	    for (var _len2 = arguments.length, texts = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	      texts[_key2 - 1] = arguments[_key2];
	    }
	
	    _this25.annotations = texts.map(function (text) {
	      return new Annotation(ctxt, text);
	    });
	    _this25.padding = Math.max.apply(null, _this25.annotations.map(function (annotation) {
	      return annotation.padding;
	    }));
	    return _this25;
	  }
	
	  _createClass(Annotations, [{
	    key: \"updateBounds\",
	    value: function updateBounds(multiplier) {
	      if (!multiplier) multiplier = 1;
	      for (var i = 0; i < this.annotations.length; ++i) {
	        var annotation = this.annotations[i];
	        annotation.bounds.x += this.bounds.x * multiplier;
	        annotation.bounds.y += this.bounds.y * multiplier;
	      }
	    }
	  }, {
	    key: \"recalculateMetrics\",
	    value: function recalculateMetrics(ctxt) {
	      this.bounds.x = 0;
	      this.bounds.y = 0;
	
	      this.bounds.width = 0;
	      this.bounds.height = 0;
	
	      this.origin.x = 0;
	      this.origin.y = 0;
	
	      var y = 0;
	      for (var i = 0; i < this.annotations.length; ++i) {
	        var annotation = this.annotations[i];
	        annotation.recalculateMetrics(ctxt);
	        this.bounds.width = Math.max(this.bounds.width, annotation.bounds.width);
	        annotation.bounds.y += y;
	        this.bounds.height = annotation.bounds.bottom();
	        this.origin.y = this.origin.y || annotation.origin.y;
	        y += annotation.fontSize(ctxt) * (annotation.resize || 1) * this.lineHeight;
	      }
	    }
	  }, {
	    key: \"draw\",
	    value: function draw(ctxt) {
	      this.updateBounds();
	      this.annotations.forEach(function (annotation) {
	        annotation.draw(ctxt);
	      });
	      this.updateBounds(-1);
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      this.updateBounds();
	      var result = this.annotations.map(function (annotation) {
	        return annotation.createSvgNode(ctxt);
	      });
	      this.updateBounds(-1);
	      return result;
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt) {
	      this.updateBounds();
	      var result = this.annotations.map(function (annotation) {
	        return annotation.createSvgTree(ctxt);
	      });
	      this.updateBounds(-1);
	      return { children: result };
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      this.updateBounds();
	      var result = this.annotations.map(function (annotation) {
	        return annotation.createSvgFragment(ctxt);
	      }).join(\"\");
	      this.updateBounds(-1);
	      return result;
	    }
	  }]);
	
	  return Annotations;
	}(ChantLayoutElement);
	
	var ChantNotationElement = exports.ChantNotationElement = function (_ChantLayoutElement10) {
	  _inherits(ChantNotationElement, _ChantLayoutElement10);
	
	  function ChantNotationElement() {
	    _classCallCheck(this, ChantNotationElement);
	
	    //double
	    var _this26 = _possibleConstructorReturn(this, (ChantNotationElement.__proto__ || Object.getPrototypeOf(ChantNotationElement)).call(this));
	
	    _this26.leadingSpace = 0.0;
	    _this26.trailingSpace = DefaultTrailingSpace;
	    _this26.keepWithNext = false;
	    _this26.needsLayout = true;
	
	    _this26.lyrics = [];
	
	    _this26.score = null; // the ChantScore
	    _this26.line = null; // the ChantLine
	
	    _this26.visualizers = [];
	    return _this26;
	  }
	
	  _createClass(ChantNotationElement, [{
	    key: \"hasLyrics\",
	    value: function hasLyrics() {
	      return this.lyrics.length !== 0;
	    }
	  }, {
	    key: \"getAllLyricsLeft\",
	    value: function getAllLyricsLeft() {
	      if (this.lyrics.length === 0) return this.bounds.right();
	
	      var x = Number.MAX_VALUE;
	      for (var i = 0; i < this.lyrics.length; i++) {
	        if (this.lyrics[i]) x = Math.min(x, this.lyrics[i].bounds.x);
	      }
	
	      return this.bounds.x + x;
	    }
	  }, {
	    key: \"getAllLyricsRight\",
	    value: function getAllLyricsRight() {
	      if (this.lyrics.length === 0) return this.bounds.x;
	
	      var x = Number.MIN_VALUE;
	      for (var i = 0; i < this.lyrics.length; i++) {
	        if (this.lyrics[i]) x = Math.max(x, this.lyrics[i].bounds.x + this.lyrics[i].bounds.width);
	      }
	
	      return this.bounds.x + x;
	    }
	
	    // used by subclasses while building up the chant notations.
	
	  }, {
	    key: \"addVisualizer\",
	    value: function addVisualizer(chantLayoutElement) {
	      if (!chantLayoutElement.ignoreBounds) {
	        if (this.bounds.isEmpty()) this.bounds = chantLayoutElement.bounds.clone();else this.bounds.union(chantLayoutElement.bounds);
	      }
	
	      this.visualizers.push(chantLayoutElement);
	    }
	
	    // same as addVisualizer, except the element is unshifted to the front
	    // of the visualizer array rather than the end. This way, some
	    // visualizers can be placed behind the others...ledger lines for example.
	
	  }, {
	    key: \"prependVisualizer\",
	    value: function prependVisualizer(chantLayoutElement) {
	      if (this.bounds.isEmpty()) this.bounds = chantLayoutElement.bounds.clone();else this.bounds.union(chantLayoutElement.bounds);
	
	      this.visualizers.unshift(chantLayoutElement);
	    }
	
	    // chant notation elements are given an opportunity to perform their layout via this function.
	    // subclasses should call this function first in overrides of this function.
	    // on completion, exsurge presumes that the bounds, the origin, and the fragment objects are
	    // all valid and prepared for higher level layout.
	
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      if (typeof this.trailingSpace === \"function\") this.calculatedTrailingSpace = this.trailingSpace(ctxt);else this.calculatedTrailingSpace = this.trailingSpace;
	
	      // reset the bounds and the staff notations before doing a layout
	      this.visualizers = [];
	      this.bounds = new _ExsurgeCore.Rect(Infinity, Infinity, -Infinity, -Infinity);
	
	      for (var i = 0; i < this.lyrics.length; i++) {
	        this.lyrics[i].recalculateMetrics(ctxt);
	      }if (this.alText) for (i = 0; i < this.alText.length; i++) {
	        this.alText[i].recalculateMetrics(ctxt);
	      }if (this.translationText) for (i = 0; i < this.translationText.length; i++) {
	        this.translationText[i].recalculateMetrics(ctxt);
	      }
	    }
	
	    // some subclasses have internal dependencies on other notations (for example,
	    // a custos can depend on a later neume which it uses to set its height).
	    // subclasses can override this function so that when the notations are
	    // altered, the subclass can correctly invalidate (and later restore) its own
	    // depedencies
	
	  }, {
	    key: \"resetDependencies\",
	    value: function resetDependencies() {}
	
	    // a helper function for subclasses to call after they are done performing layout...
	
	  }, {
	    key: \"finishLayout\",
	    value: function finishLayout(ctxt) {
	      var _this27 = this;
	
	      this.bounds.x = 0;
	
	      var language = this.lyrics[0] && this.lyrics[0].language || ctxt.defaultLanguage;
	      // center the neume itself over the syllable, or just the first punctum
	      // if the neume is wider than the syllable + the width of a punctum, we always revert to centering just over the punctum
	      var calculateLyricX = language.centerNeume ? function (lyric) {
	        return lyric.bounds.x = _this27.bounds.width + ctxt.staffInterval < lyric.vowelSegmentWidth ? _this27.bounds.width / 2 - lyric.origin.x : _this27.origin.x - lyric.origin.x;
	      } : function (lyric) {
	        return lyric.bounds.x = _this27.origin.x - lyric.origin.x;
	      };
	      this.lyrics.forEach(calculateLyricX);
	
	      this.needsLayout = false;
	    }
	  }, {
	    key: \"draw\",
	    value: function draw(ctxt) {
	      var canvasCtxt = ctxt.canvasCtxt;
	      canvasCtxt.translate(this.bounds.x, 0);
	
	      for (var i = 0; i < this.visualizers.length; i++) {
	        this.visualizers[i].draw(ctxt);
	      }for (i = 0; i < this.lyrics.length; i++) {
	        this.lyrics[i].draw(ctxt);
	      }if (this.translationText) for (i = 0; i < this.translationText.length; i++) {
	        this.translationText[i].draw(ctxt);
	      }if (this.alText) for (i = 0; i < this.alText.length; i++) {
	        this.alText[i].draw(ctxt);
	      }canvasCtxt.translate(-this.bounds.x, 0);
	    }
	  }, {
	    key: \"getInnerSvgNodes\",
	    value: function getInnerSvgNodes(ctxt) {
	      var functionName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"createSvgNode\";
	
	      var inner = [];
	
	      for (i = 0; i < this.lyrics.length; i++) {
	        inner.push(this.lyrics[i][functionName](ctxt));
	      }if (this.translationText) for (i = 0; i < this.translationText.length; i++) {
	        inner.push(this.translationText[i][functionName](ctxt));
	      }if (this.alText) for (i = 0; i < this.alText.length; i++) {
	        inner.push(this.alText[i][functionName](ctxt));
	      }if (this.visualizers.length) {
	        var visualizers = [];
	        for (var i = 0; i < this.visualizers.length; i++) {
	          visualizers.push(this.visualizers[i][functionName](ctxt, this));
	        }if (functionName === \"createSvgTree\") {
	          inner.push(QuickSvg.createSvgTree.apply(QuickSvg, [\"g\", { class: \"Notations\" }].concat(visualizers)));
	        } else {
	          inner.push(QuickSvg.createNode(\"g\", { class: \"Notations\" }, visualizers));
	        }
	      }
	      return inner;
	    }
	  }, {
	    key: \"getSvgProps\",
	    value: function getSvgProps() {
	      return {
	        // this.constructor.name will not be the same after being mangled by UglifyJS
	        class: \"ChantNotationElement \" + this.constructor.name,
	        transform: \"translate(\" + this.bounds.x + \",\" + 0 + \")\"
	      };
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      var inner = this.getInnerSvgNodes(ctxt, \"createSvgNode\");
	      var svgProps = this.getSvgProps();
	      svgProps.source = this;
	      return QuickSvg.createNode(\"g\", svgProps, inner);
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt) {
	      var inner = this.getInnerSvgNodes(ctxt, \"createSvgTree\");
	      var svgProps = this.getSvgProps();
	      svgProps.source = this;
	      return QuickSvg.createSvgTree.apply(QuickSvg, [\"g\", svgProps].concat(_toConsumableArray(inner)));
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      var inner = \"\";
	
	      for (i = 0; i < this.lyrics.length; i++) {
	        inner += this.lyrics[i].createSvgFragment(ctxt);
	      }if (this.translationText) for (i = 0; i < this.translationText.length; i++) {
	        inner += this.translationText[i].createSvgFragment(ctxt);
	      }if (this.alText) for (i = 0; i < this.alText.length; i++) {
	        inner += this.alText[i].createSvgFragment(ctxt);
	      }for (var i = 0; i < this.visualizers.length; i++) {
	        inner += this.visualizers[i].createSvgFragment(ctxt, this);
	      }return QuickSvg.createFragment(\"g\", this.getSvgProps(), inner);
	    }
	  }]);
	
	  return ChantNotationElement;
	}(ChantLayoutElement);

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	var addAccent = exports.addAccent = function addAccent(vowel) {
	  return {
	    \"Æ\": \"Ǽ\",
	    \"Œ\": \"Œ́\",
	    \"A\": \"Á\",
	    \"E\": \"É\",
	    \"I\": \"Í\",
	    \"O\": \"Ó\",
	    \"U\": \"Ú\",
	    \"Y\": \"Ý\",
	    \"æ\": \"ǽ\",
	    \"œ\": \"œ́\",
	    \"a\": \"á\",
	    \"e\": \"é\",
	    \"i\": \"í\",
	    \"o\": \"ó\",
	    \"u\": \"ú\",
	    \"y\": \"ý\"
	  }[vowel] || vowel;
	};

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	var makeLigature = exports.makeLigature = function makeLigature(vowels) {
	  return {
	    AE: \"Æ\",
	    Ae: \"Æ\",
	    ae: \"æ\",
	    OE: \"Œ\",
	    Oe: \"Œ\",
	    oe: \"œ\"
	  }[vowels] || vowels;
	};

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	var greextraGlyphs = exports.greextraGlyphs = {
	  MedicaeaFlat: \"\",
	  HufnagelCustosUpShort: \"\",
	  HufnagelCustosUpLong: \"\",
	  HufnagelCustosUpMedium: \"\",
	  HufnagelCustosDownShort: \"\",
	  HufnagelCustosDownLong: \"\",
	  HufnagelCustosDownMedium: \"\",
	  MedicaeaCustosUpShort: \"\",
	  MedicaeaCustosUpLong: \"\",
	  MedicaeaCustosUpMedium: \"\",
	  MedicaeaCustosDownShort: \"\",
	  MedicaeaCustosDownLong: \"\",
	  MedicaeaCustosDownMedium: \"\",
	  MensuralCustosUpShort: \"\",
	  MensuralCustosUpLong: \"\",
	  MensuralCustosUpMedium: \"\",
	  MensuralCustosDownShort: \"\",
	  MensuralCustosDownLong: \"\",
	  MensuralCustosDownMedium: \"\",
	  MensuralFlat: \"\",
	  HufnagelFlat: \"\",
	  MedicaeaCClef: \"\",
	  MedicaeaCClefChange: \"\",
	  MedicaeaFClef: \"\",
	  MedicaeaFClefChange: \"\",
	  HufnagelCClef: \"\",
	  HufnagelCClefChange: \"\",
	  HufnagelFClef: \"\",
	  HufnagelFClefChange: \"\",
	  HugnagelCFClef: \"\",
	  HufnagelCFClefChange: \"\",
	  MensuralFlatHole: \"\",
	  HufnagelFlatHole: \"\",
	  MedicaeaFlatHole: \"\",
	  StarSix: \"\",
	  Dagger: \"\",
	  \"Bar.alt\": \"\",
	  StarHeight: \"\",
	  Cross: \"\",
	  \"RBar.alt\": \"\",
	  \"VBar.alt\": \"\",
	  Drawing1: \"\",
	  Drawing2: \"\",
	  RWithBarGoth: \"\",
	  VWithBarGoth: \"\",
	  Line1: \"\",
	  Line2: \"\",
	  Line3: \"\",
	  Line4: \"\",
	  Line5: \"\",
	  \"Cross.alt\": \"\",
	  ABarCaption: \"\",
	  RBarCaption: \"\",
	  VBarCaption: \"\",
	  ABarCaptionSC: \"\",
	  RBarCaptionSC: \"\",
	  VBarCaptionSC: \"\",
	  ABar: \"\",
	  RBar: \"\",
	  VBar: \"\",
	  ABarSC: \"\",
	  RBarSC: \"\",
	  VBarSC: \"\",
	  ABarSmall: \"\",
	  RBarSmall: \"\",
	  VBarSmall: \"\",
	  ABarSmallSC: \"\",
	  RBarSmallSC: \"\",
	  VBarSmallSC: \"\",
	  \"RBar.alt2\": \"\",
	  \"VBar.alt2\": \"\",
	  ABarCaptionSlant: \"\",
	  RBarCaptionSlant: \"\",
	  VBarCaptionSlant: \"\",
	  ABarSlant: \"\",
	  RBarSlant: \"\",
	  VBarSlant: \"\",
	  ABarSmallSlant: \"\",
	  RBarSmallSlant: \"\",
	  VBarSmallSlant: \"\"
	};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	exports.ChantDocument = exports.ChantScore = exports.ChantMapping = exports.ChantLineBreak = exports.TextOnly = exports.FaClef = exports.DoClef = exports.Clef = exports.Note = exports.NoteShapeModifiers = exports.NoteShape = exports.LiquescentType = undefined;
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ExsurgeChantChantLine = __webpack_require__(9);
	
	var _ExsurgeChantSigns = __webpack_require__(11);
	
	var _ExsurgeCore = __webpack_require__(1);
	
	var _ExsurgeDrawing = __webpack_require__(4);
	
	var _ExsurgeGabc = __webpack_require__(12);
	
	var _ExsurgeTitles = __webpack_require__(14);
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //
	// Author(s):
	// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
	//
	// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the \"Software\"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	//
	
	var LiquescentType = exports.LiquescentType = {
	  None: 0,
	
	  // flags that can be combined, though of course it
	  // it doesn't make sense to combine some!
	  Large: 1 << 0,
	  Small: 1 << 1,
	  Ascending: 1 << 2,
	  Descending: 1 << 3,
	  InitioDebilis: 1 << 4,
	
	  // handy liquescent types
	  LargeAscending: 1 << 0 | 1 << 2,
	  LargeDescending: 1 << 0 | 1 << 3,
	  SmallAscending: 1 << 1 | 1 << 2,
	  SmallDescending: 1 << 1 | 1 << 3
	};
	
	var NoteShape = exports.NoteShape = {
	  // shapes
	  Default: 0,
	  Virga: 1,
	  Inclinatum: 2,
	  Quilisma: 3,
	  Stropha: 4,
	  Oriscus: 5
	};
	
	var NoteShapeModifiers = exports.NoteShapeModifiers = {
	  // flags which modify the shape
	  // not all of them apply to every shape of course
	  None: 0,
	  Ascending: 1 << 0,
	  Descending: 1 << 1,
	  Cavum: 1 << 2,
	  Stemmed: 1 << 3,
	  Linea: 1 << 4,
	  Reverse: 1 << 5
	};
	
	/**
	 * @class
	 */
	
	var Note = exports.Note = function (_ChantLayoutElement) {
	  _inherits(Note, _ChantLayoutElement);
	
	  /**
	   * @para {Pitch} pitch
	   */
	  function Note(pitch) {
	    _classCallCheck(this, Note);
	
	    var _this = _possibleConstructorReturn(this, (Note.__proto__ || Object.getPrototypeOf(Note)).call(this));
	
	    if (typeof pitch !== \"undefined\") _this.pitch = pitch;else _this.pitch = null;
	
	    _this.glyphVisualizer = null;
	
	    // The staffPosition on a note is an integer that indicates the vertical position on the staff.
	    // 0 is the center space on the staff (equivalent to gabc 'g'). Positive numbers go up
	    // the staff, and negative numbers go down, i.e., 1 is gabc 'h', 2 is gabc 'i', -1 is gabc 'f', etc.
	    _this.staffPosition = 0;
	    _this.liquescent = LiquescentType.None;
	    _this.shape = NoteShape.Default;
	    _this.shapeModifiers = NoteShapeModifiers.None;
	
	    // notes keep track of the neume they belong to in order to facilitate layout
	    // this.neume gets set when a note is added to a neume via Neume.addNote()
	    _this.neume = null;
	
	    // various markings that can exist on a note, organized by type
	    // for faster access and simpler code logic
	    _this.episemata = [];
	    _this.morae = []; // silly to have an array of these, but gabc allows multiple morae per note!
	
	    // these are set on the note when they are needed, otherwise, they're undefined
	    // this.ictus
	    // this.accuteAccent
	    // this.braceStart
	    // this.braceEnd
	    return _this;
	  }
	
	  _createClass(Note, [{
	    key: \"setGlyph\",
	    value: function setGlyph(ctxt, glyphCode) {
	      if (this.glyphVisualizer) this.glyphVisualizer.setGlyph(ctxt, glyphCode);else this.glyphVisualizer = new _ExsurgeDrawing.GlyphVisualizer(ctxt, glyphCode);
	
	      this.glyphVisualizer.setStaffPosition(ctxt, this.staffPosition);
	
	      // assign glyphvisualizer metrics to this note
	      this.bounds.x = this.glyphVisualizer.bounds.x;
	      this.bounds.y = this.glyphVisualizer.bounds.y;
	      this.bounds.width = this.glyphVisualizer.bounds.width;
	      this.bounds.height = this.glyphVisualizer.bounds.height;
	
	      this.origin.x = this.glyphVisualizer.origin.x;
	      this.origin.y = this.glyphVisualizer.origin.y;
	    }
	
	    // a utility function for modifiers
	
	  }, {
	    key: \"shapeModifierMatches\",
	    value: function shapeModifierMatches(shapeModifier) {
	      if (shapeModifier === NoteShapeModifiers.None) return this.shapeModifier === NoteShapeModifiers.None;else return this.shapeModifier & shapeModifier !== 0;
	    }
	  }, {
	    key: \"draw\",
	    value: function draw(ctxt) {
	      this.glyphVisualizer.bounds.x = this.bounds.x;
	      this.glyphVisualizer.bounds.y = this.bounds.y;
	
	      this.glyphVisualizer.draw(ctxt);
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      this.glyphVisualizer.bounds.x = this.bounds.x;
	      this.glyphVisualizer.bounds.y = this.bounds.y;
	      this.svgNode = this.glyphVisualizer.createSvgNode(ctxt, this);
	      return this.svgNode;
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt) {
	      this.glyphVisualizer.bounds.x = this.bounds.x;
	      this.glyphVisualizer.bounds.y = this.bounds.y;
	      return this.glyphVisualizer.createSvgTree(ctxt, this);
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      this.glyphVisualizer.bounds.x = this.bounds.x;
	      this.glyphVisualizer.bounds.y = this.bounds.y;
	      return this.glyphVisualizer.createSvgFragment(ctxt, this);
	    }
	  }]);
	
	  return Note;
	}(_ExsurgeDrawing.ChantLayoutElement);
	
	var Clef = exports.Clef = function (_ChantNotationElement) {
	  _inherits(Clef, _ChantNotationElement);
	
	  function Clef(staffPosition, octave) {
	    var defaultAccidental = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	
	    _classCallCheck(this, Clef);
	
	    var _this2 = _possibleConstructorReturn(this, (Clef.__proto__ || Object.getPrototypeOf(Clef)).call(this));
	
	    _this2.isClef = true;
	    _this2.staffPosition = staffPosition;
	    _this2.octave = octave;
	    _this2.defaultAccidental = defaultAccidental;
	    _this2.activeAccidental = defaultAccidental;
	    _this2.keepWithNext = true;
	    return _this2;
	  }
	
	  _createClass(Clef, [{
	    key: \"resetAccidentals\",
	    value: function resetAccidentals() {
	      this.activeAccidental = this.defaultAccidental;
	    }
	  }, {
	    key: \"pitchToStaffPosition\",
	    value: function pitchToStaffPosition(pitch) {}
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      ctxt.activeClef = this;
	
	      if (this.defaultAccidental) this.defaultAccidental.performLayout(ctxt);
	
	      _get(Clef.prototype.__proto__ || Object.getPrototypeOf(Clef.prototype), \"performLayout\", this).call(this, ctxt);
	    }
	  }, {
	    key: \"finishLayout\",
	    value: function finishLayout(ctxt) {
	      // if we have a default accidental, then add a glyph for it now
	      if (this.defaultAccidental) {
	        var accidentalGlyph = this.defaultAccidental.createGlyphVisualizer(ctxt);
	        accidentalGlyph.bounds.x += this.visualizers[0].bounds.right() + ctxt.intraNeumeSpacing;
	        this.addVisualizer(accidentalGlyph);
	      }
	
	      _get(Clef.prototype.__proto__ || Object.getPrototypeOf(Clef.prototype), \"finishLayout\", this).call(this, ctxt);
	    }
	  }, {
	    key: \"clone\",
	    value: function clone() {
	      if (this.model) return this.model.clone();
	      var clone = new this.constructor(this.staffPosition, this.octave, this.defaultAccidental);
	      clone.sourceGabc = this.sourceGabc;
	      clone.sourceIndex = this.sourceIndex;
	      clone.elementIndex = this.elementIndex;
	      clone.model = this;
	      return clone;
	    }
	  }], [{
	    key: \"default\",
	    value: function _default() {
	      return __defaultDoClef;
	    }
	  }]);
	
	  return Clef;
	}(_ExsurgeDrawing.ChantNotationElement);
	
	var DoClef = exports.DoClef = function (_Clef) {
	  _inherits(DoClef, _Clef);
	
	  function DoClef(staffPosition, octave) {
	    var defaultAccidental = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	
	    _classCallCheck(this, DoClef);
	
	    var _this3 = _possibleConstructorReturn(this, (DoClef.__proto__ || Object.getPrototypeOf(DoClef)).call(this, staffPosition, octave, defaultAccidental));
	
	    _this3.leadingSpace = 0.0;
	    return _this3;
	  }
	
	  _createClass(DoClef, [{
	    key: \"pitchToStaffPosition\",
	    value: function pitchToStaffPosition(pitch) {
	      return (pitch.octave - this.octave) * 7 + this.staffPosition + _ExsurgeCore.Pitch.stepToStaffOffset(pitch.step) - _ExsurgeCore.Pitch.stepToStaffOffset(_ExsurgeCore.Step.Do);
	    }
	  }, {
	    key: \"staffPositionToPitch\",
	    value: function staffPositionToPitch(staffPosition) {
	      var offset = staffPosition - this.staffPosition;
	      var octaveOffset = Math.floor(offset / 7);
	
	      var step = _ExsurgeCore.Pitch.staffOffsetToStep(offset);
	
	      if (this.activeAccidental && this.activeAccidental.staffPosition === staffPosition) step += this.activeAccidental.accidentalType;
	
	      return new _ExsurgeCore.Pitch(step, this.octave + octaveOffset);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(DoClef.prototype.__proto__ || Object.getPrototypeOf(DoClef.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var glyph = new _ExsurgeDrawing.GlyphVisualizer(ctxt, _ExsurgeDrawing.GlyphCode.DoClef);
	      glyph.setStaffPosition(ctxt, this.staffPosition);
	      this.addVisualizer(glyph);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return DoClef;
	}(Clef);
	
	var __defaultDoClef = new DoClef(3, 2);
	
	var FaClef = exports.FaClef = function (_Clef2) {
	  _inherits(FaClef, _Clef2);
	
	  function FaClef(staffPosition, octave) {
	    var defaultAccidental = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	
	    _classCallCheck(this, FaClef);
	
	    var _this4 = _possibleConstructorReturn(this, (FaClef.__proto__ || Object.getPrototypeOf(FaClef)).call(this, staffPosition, octave, defaultAccidental));
	
	    _this4.octave = octave;
	
	    _this4.leadingSpace = 0;
	    return _this4;
	  }
	
	  _createClass(FaClef, [{
	    key: \"pitchToStaffPosition\",
	    value: function pitchToStaffPosition(pitch) {
	      return (pitch.octave - this.octave) * 7 + this.staffPosition + _ExsurgeCore.Pitch.stepToStaffOffset(pitch.step) - _ExsurgeCore.Pitch.stepToStaffOffset(_ExsurgeCore.Step.Fa);
	    }
	  }, {
	    key: \"staffPositionToPitch\",
	    value: function staffPositionToPitch(staffPosition) {
	      var offset = staffPosition - this.staffPosition + 3; // + 3 because it's a fa clef (3 == offset from Do)
	      var octaveOffset = Math.floor(offset / 7);
	
	      var step = _ExsurgeCore.Pitch.staffOffsetToStep(offset);
	
	      if (this.activeAccidental && this.activeAccidental.staffPosition === staffPosition) step += this.activeAccidental.accidentalType;
	
	      return new _ExsurgeCore.Pitch(step, this.octave + octaveOffset);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(FaClef.prototype.__proto__ || Object.getPrototypeOf(FaClef.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var glyph = new _ExsurgeDrawing.GlyphVisualizer(ctxt, _ExsurgeDrawing.GlyphCode.FaClef);
	      glyph.setStaffPosition(ctxt, this.staffPosition);
	      this.addVisualizer(glyph);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return FaClef;
	}(Clef);
	
	/*
	 * TextOnly
	 */
	
	
	var TextOnly = exports.TextOnly = function (_ChantNotationElement2) {
	  _inherits(TextOnly, _ChantNotationElement2);
	
	  function TextOnly(sourceIndex, sourceLength) {
	    _classCallCheck(this, TextOnly);
	
	    var _this5 = _possibleConstructorReturn(this, (TextOnly.__proto__ || Object.getPrototypeOf(TextOnly)).call(this));
	
	    _this5.sourceIndex = sourceIndex;
	    _this5.sourceLength = sourceLength;
	    _this5.sourceGabc = \"\";
	    _this5.trailingSpace = 0;
	    return _this5;
	  }
	
	  _createClass(TextOnly, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(TextOnly.prototype.__proto__ || Object.getPrototypeOf(TextOnly.prototype), \"performLayout\", this).call(this, ctxt);
	
	      // add an empty glyph as a placeholder
	      this.addVisualizer(new _ExsurgeDrawing.GlyphVisualizer(ctxt, _ExsurgeDrawing.GlyphCode.None));
	
	      this.origin.x = 0;
	      this.origin.y = 0;
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return TextOnly;
	}(_ExsurgeDrawing.ChantNotationElement);
	
	var ChantLineBreak = exports.ChantLineBreak = function (_ChantNotationElement3) {
	  _inherits(ChantLineBreak, _ChantNotationElement3);
	
	  function ChantLineBreak(justify) {
	    _classCallCheck(this, ChantLineBreak);
	
	    var _this6 = _possibleConstructorReturn(this, (ChantLineBreak.__proto__ || Object.getPrototypeOf(ChantLineBreak)).call(this));
	
	    _this6.calculatedTrailingSpace = _this6.trailingSpace = 0;
	    _this6.justify = justify;
	    return _this6;
	  }
	
	  _createClass(ChantLineBreak, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      // reset the bounds before doing a layout
	      this.bounds = new _ExsurgeCore.Rect(0, 0, 0, 0);
	    }
	  }, {
	    key: \"clone\",
	    value: function clone() {
	      var lb = new ChantLineBreak();
	      lb.justify = this.justify;
	
	      return lb;
	    }
	  }]);
	
	  return ChantLineBreak;
	}(_ExsurgeDrawing.ChantNotationElement);
	
	// a chant mapping is a lightweight format independent way of
	// tracking how a chant language (e.g., gabc) has been
	// mapped to exsurge notations.
	
	
	var ChantMapping =
	// source can be any object type. in the case of gabc, source is a text
	// string that maps to a gabc word (e.g.: \"no(g)bis(fg)\").
	// notations is an array of ChantNotationElements
	exports.ChantMapping = function ChantMapping(source, notations, sourceIndex) {
	  _classCallCheck(this, ChantMapping);
	
	  this.source = source;
	  this.notations = notations;
	  this.sourceIndex = sourceIndex;
	};
	
	var __connectorSpan = new _ExsurgeDrawing.TextSpan(\" • \"),
	    __mergeAnnotationWithTextLeft = function __mergeAnnotationWithTextLeft() {
	  for (var _len = arguments.length, annotationSpans = Array(_len), _key = 0; _key < _len; _key++) {
	    annotationSpans[_key] = arguments[_key];
	  }
	
	  return annotationSpans.reduce(function (result, spans) {
	    if (result && result.length) {
	      if (spans && spans.length) return result.concat(__connectorSpan, spans);else return result;
	    } else if (spans && spans.length) {
	      return spans;
	    }
	    return [];
	  });
	};
	
	/*
	 * Score, document
	 */
	
	var ChantScore = exports.ChantScore = function () {
	  // mappings is an array of ChantMappings.
	  function ChantScore(ctxt) {
	    var mappings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	    var useDropCap = arguments[2];
	
	    _classCallCheck(this, ChantScore);
	
	    this.mappings = mappings;
	
	    this.lines = [];
	    this.notes = [];
	    if (ctxt) this.titles = new _ExsurgeTitles.Titles(ctxt, this);
	
	    this.startingClef = null;
	
	    this.useDropCap = useDropCap;
	    this.dropCap = null;
	
	    this.annotation = null;
	
	    this.compiled = false;
	
	    this.autoColoring = true;
	    this.needsLayout = true;
	
	    // valid after chant lines are created...
	    this.bounds = new _ExsurgeCore.Rect();
	
	    this.mergeAnnotationWithTextLeft = __mergeAnnotationWithTextLeft;
	
	    if (ctxt) this.updateNotations(ctxt);
	  }
	
	  /**
	   * Make a copy of the score, only including the specified lines
	   * @param  {number} startLine starting index
	   * @param  {number} endLine   ending index
	   * @return {ChantScore}           the partial score
	   */
	
	
	  _createClass(ChantScore, [{
	    key: \"copyLines\",
	    value: function copyLines(startLine, endLine) {
	      var result = new ChantScore();
	      result.lines = this.lines.slice(startLine, endLine);
	      result.bounds = this.bounds.clone();
	      var lastLine = result.lines.slice(-1)[0];
	      result.bounds.height = lastLine.bounds.bottom() - lastLine.origin.y;
	      if (startLine === 0) {
	        result.titles = this.titles;
	        result.dropCap = this.dropCap;
	        result.annotation = this.annotation;
	      }
	      return result;
	    }
	  }, {
	    key: \"updateSelection\",
	    value: function updateSelection(selection) {
	      this.selection = selection;
	      var elementSelection = selection && selection.element || {
	        indices: []
	      };
	      var selectedIndices = elementSelection.indices;
	      var insertion = elementSelection.insertion;
	      if (!insertion && selectedIndices.length === 1 && this.notes[selectedIndices[0]] instanceof TextOnly) {
	        // if there is only one selection, and its a text only, it should display as an insertion cursor:
	        insertion = { afterElementIndex: selectedIndices[0] };
	      }
	      // update the selected elements so that they can be given a .selected class when rendered
	      for (var i = 0; i < this.notes.length; ++i) {
	        var element = this.notes[i];
	        element.selected = selectedIndices.includes(i);
	      }
	      (this.startingClef.model || this.startingClef).selected = selectedIndices.includes(-1);
	      for (var _i = 0; _i < this.lines.length; ++_i) {
	        this.lines[_i].insertionCursor = null;
	      }
	      // update the insertion cursor, so it can be drawn on the correct system
	      this.insertionElement = null;
	      var insertionLine = null;
	      if (insertion) {
	        if (typeof insertion.chantLine === \"number\") {
	          insertionLine = this.lines[insertion.chantLine];
	          this.insertionElement = insertionLine.startingClef;
	          insertionLine.insertionCursor = new _ExsurgeChantSigns.InsertionCursor();
	        } else if (typeof insertion.afterElementIndex === \"number\") {
	          this.insertionElement = this.notes[insertion.afterElementIndex];
	          if (!this.insertionElement) {
	            insertionLine = this.lines[0];
	            this.insertionElement = insertionLine.startingClef;
	          } else if (this.insertionElement.neume) {
	            this.insertionElement = this.insertionElement.neume;
	          }
	          if (!insertionLine) {
	            insertionLine = this.insertionElement.line || this.lines[this.lines.length - 1];
	          }
	          insertionLine.insertionCursor = new _ExsurgeChantSigns.InsertionCursor();
	        }
	      }
	    }
	  }, {
	    key: \"updateNotations\",
	    value: function updateNotations(ctxt) {
	      var i, j, mapping, notation;
	
	      // flatten all mappings into one array for N(0) access to notations
	      this.notations = [];
	      this.notes = [];
	      this.hasLyrics = false;
	      this.hasAboveLinesText = false;
	      this.hasTranslations = false;
	      var elementSelection = this.selection && this.selection.element || {
	        indices: []
	      };
	      var selectedIndices = elementSelection.indices;
	      var nonNoteElementCount = 0;
	
	      // find the starting clef...
	      // start with a default clef in case the notations don't provide one.
	      this.startingClef = null;
	
	      for (i = 0; i < this.mappings.length; i++) {
	        mapping = this.mappings[i];
	        for (j = 0; j < mapping.notations.length; j++) {
	          notation = mapping.notations[j];
	          notation.score = this;
	          notation.mapping = mapping;
	
	          if (!this.startingClef) {
	            if (notation.isNeume) {
	              this.startingClef = Clef.default();
	            } else if (notation.isClef) {
	              this.startingClef = notation;
	              continue;
	            }
	          }
	
	          notation.notationIndex = this.notations.push(notation) - 1;
	          if (!this.hasLyrics && notation.hasLyrics()) this.hasLyrics = true;
	          if (!this.hasAboveLinesText && notation.alText) this.hasAboveLinesText = true;
	          if (!this.hasTranslations && notation.translationText) this.hasTranslations = true;
	
	          // Update this.notes and find element indices:
	          var elements = notation.notes || [notation];
	          var _iteratorNormalCompletion = true;
	          var _didIteratorError = false;
	          var _iteratorError = undefined;
	
	          try {
	            for (var _iterator = elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              var element = _step.value;
	
	              var elementIndex = element.elementIndex = this.notes.push(element) - 1;
	              if (element instanceof Note) {
	                element.noteIndex = elementIndex - nonNoteElementCount;
	              } else {
	                ++nonNoteElementCount;
	              }
	
	              element.selected = selectedIndices.includes(elementIndex);
	            }
	          } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	              }
	            } finally {
	              if (_didIteratorError) {
	                throw _iteratorError;
	              }
	            }
	          }
	        }
	      }
	
	      // if we've reached this far and we *still* don't have a clef, then there aren't even
	      // any neumes in the score. still, set the default clef just for good measure
	      if (!this.startingClef) this.startingClef = Clef.default();
	      this.startingClef.elementIndex = -1;
	
	      // update drop cap
	      if (this.useDropCap) this.recreateDropCap(ctxt);else this.dropCap = null;
	
	      this.needsLayout = true;
	    }
	  }, {
	    key: \"recreateDropCap\",
	    value: function recreateDropCap(ctxt) {
	      this.dropCap = null;
	
	      // find the first notation with lyrics to use
	      for (var i = 0; i < this.notations.length; i++) {
	        if (this.notations[i].hasLyrics() && this.notations[i].lyrics[0] !== null && this.notations[i].lyrics[0].spans && this.notations[i].lyrics[0].spans.length) {
	          var notation = this.notations[i],
	              lyrics = notation.lyrics[0];
	          if (this.useDropCap) {
	            this.dropCap = lyrics.generateDropCap(ctxt);
	          } else {
	            lyrics.dropCap = null;
	            lyrics.generateSpansFromText(ctxt, lyrics.originalText);
	          }
	          notation.needsLayout = true;
	          return;
	        }
	      }
	    }
	
	    /**
	     * Shared layout initialization method for performLayout() and performLayoutAsync()
	     * @param  {ChantContext} ctxt
	     */
	
	  }, {
	    key: \"initializeLayout\",
	    value: function initializeLayout(ctxt) {
	      // setup the context
	      ctxt.activeClef = this.startingClef;
	      ctxt.notations = this.notations;
	      ctxt.currNotationIndex = 0;
	
	      if (this.dropCap) this.dropCap.recalculateMetrics(ctxt);
	
	      if (this.annotation) this.annotation.recalculateMetrics(ctxt);
	    }
	
	    // this is the the synchronous version of performLayout that
	    // process everything without yielding to any other workers/threads.
	    // good for server side processing or very small chant pieces.
	
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt, force) {
	      if (!force && this.needsLayout === false) return; // nothing to do here!
	
	      ctxt.updateHyphenWidth();
	
	      this.initializeLayout(ctxt);
	
	      for (var i = 0; i < this.notations.length; i++) {
	        var notation = this.notations[i];
	        if (force || notation.needsLayout) {
	          ctxt.currNotationIndex = i;
	          notation.performLayout(ctxt);
	        }
	      }
	
	      this.needsLayout = false;
	    }
	
	    // for web applications, probably performLayoutAsync would be more
	    // apppropriate that the above performLayout, since it will process
	    // the notations without locking up the UI thread.
	
	  }, {
	    key: \"performLayoutAsync\",
	    value: function performLayoutAsync(ctxt, finishedCallback) {
	      var _this7 = this;
	
	      if (this.needsLayout === false) {
	        if (finishedCallback) setTimeout(function () {
	          return finishedCallback();
	        }, 0);
	
	        return; // nothing to do here!
	      }
	
	      if (ctxt.onFontLoaded) {
	        ctxt.onFontLoaded.push(function () {
	          return _this7.performLayoutAsync(ctxt, finishedCallback);
	        });
	        return;
	      }
	
	      // check for sane value of hyphen width:
	      ctxt.updateHyphenWidth();
	      if (!ctxt.hyphenWidth || ctxt.hyphenWidth / ctxt.textStyles.lyric.size > 0.6) {
	        setTimeout(function () {
	          _this7.performLayoutAsync(ctxt, finishedCallback);
	        }, 100);
	        return;
	      }
	
	      this.initializeLayout(ctxt);
	
	      setTimeout(function () {
	        return _this7.layoutElementsAsync(ctxt, 0, finishedCallback);
	      }, 0);
	    }
	  }, {
	    key: \"layoutElementsAsync\",
	    value: function layoutElementsAsync(ctxt, index, finishedCallback) {
	      var _this8 = this;
	
	      if (index >= this.notations.length) {
	        this.needsLayout = false;
	
	        if (finishedCallback) setTimeout(function () {
	          return finishedCallback();
	        }, 0);
	
	        return;
	      }
	
	      if (index === 0) ctxt.activeClef = this.startingClef;
	
	      var timeout = new Date().getTime() + 50; // process for fifty milliseconds
	      do {
	        var notation = this.notations[index];
	        if (notation.needsLayout) {
	          ctxt.currNotationIndex = index;
	          notation.performLayout(ctxt);
	        }
	
	        index++;
	      } while (index < this.notations.length && new Date().getTime() < timeout);
	
	      // schedule the next block of processing
	      setTimeout(function () {
	        return _this8.layoutElementsAsync(ctxt, index, finishedCallback);
	      }, 0);
	    }
	  }, {
	    key: \"layoutChantLines\",
	    value: function layoutChantLines(ctxt, width, finishedCallback) {
	      this.lines = [];
	
	      if (this.mergeAnnotationWithTextLeft && this.annotation && !this.dropCap) {
	        var annotation = this.annotation,
	            annotationSpans = annotation.annotations ? annotation.annotations.map(function (annotation) {
	          return annotation.spans;
	        }) : [annotation.spans];
	        this.overrideTextLeft = new _ExsurgeDrawing.TextLeftRight(ctxt, \"\", \"textLeft\");
	        if (ctxt.mapAnnotationSpansToTextLeft) {
	          annotationSpans = annotationSpans.map(ctxt.mapAnnotationSpansToTextLeft);
	        }
	        this.overrideTextLeft.spans = this.mergeAnnotationWithTextLeft.apply(this, _toConsumableArray(annotationSpans).concat([this.titles.textLeft && this.titles.textLeft.spans]));
	      } else {
	        this.overrideTextLeft = null;
	      }
	
	      var y = width > 0 ? this.titles.layoutTitles(ctxt, width) : 0;
	      var currIndex = 0;
	
	      ctxt.activeClef = this.startingClef;
	
	      var spaceBetweenSystems = ctxt.staffInterval * ctxt.spaceBetweenSystems;
	
	      do {
	        var line = new _ExsurgeChantChantLine.ChantLine(this);
	
	        line.buildFromChantNotationIndex(ctxt, currIndex, width);
	        currIndex = line.notationsStartIndex + line.numNotationsOnLine;
	        line.performLayout(ctxt);
	        line.elementIndex = this.lines.length;
	        this.lines.push(line);
	
	        line.bounds.y = -line.bounds.y + y;
	        y += line.bounds.height + spaceBetweenSystems;
	      } while (currIndex < this.notations.length);
	
	      var lastLine = this.lines[this.lines.length - 1];
	
	      this.bounds.x = 0;
	      this.bounds.y = 0;
	      this.bounds.width = lastLine.bounds.width;
	      this.bounds.height = y - spaceBetweenSystems;
	
	      this.pages = [this];
	
	      if (this.selection) {
	        this.updateSelection(this.selection);
	      }
	
	      if (finishedCallback) finishedCallback(this);
	    }
	  }, {
	    key: \"paginate\",
	    value: function paginate(height) {
	      if (!height) return;
	      this.pages = [];
	      var pageHeightOffset = 0,
	          startLineIndex = 0;
	      for (var i = 1; i < this.lines.length; ++i) {
	        var line = this.lines[i];
	        var pageHeight = line.bounds.bottom() - pageHeightOffset - line.origin.y;
	
	        if (pageHeight > height) {
	          // this line will be the first on the new page
	          this.pages.push(this.copyLines(startLineIndex, i));
	          startLineIndex = i;
	          pageHeightOffset = line.bounds.y - line.origin.y;
	          line.bounds.y = line.origin.y;
	        } else {
	          // not a new page yet...update the bounds:
	          line.bounds.y -= pageHeightOffset;
	        }
	      }
	      this.pages.push(this.copyLines(startLineIndex, this.lines.length));
	    }
	  }, {
	    key: \"draw\",
	    value: function draw(ctxt) {
	      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	
	      ctxt.setCanvasSize(this.bounds.width, this.bounds.height, scale);
	
	      var canvasCtxt = ctxt.canvasCtxt;
	
	      canvasCtxt.clearRect(0, 0, ctxt.canvas.width, ctxt.canvas.height);
	
	      canvasCtxt.translate(this.bounds.x, this.bounds.y);
	
	      if (this.titles) this.titles.draw(ctxt);
	
	      for (var i = 0; i < this.lines.length; i++) {
	        this.lines[i].draw(ctxt);
	      }canvasCtxt.translate(-this.bounds.x, -this.bounds.y);
	    }
	  }, {
	    key: \"getSvgProps\",
	    value: function getSvgProps(ctxt, zoom) {
	      var width = typeof zoom === \"number\" ? zoom * this.bounds.width : zoom ? undefined : this.bounds.width,
	          height = zoom ? undefined : this.bounds.height;
	
	      return {
	        xmlns: \"http://www.w3.org/2000/svg\",
	        version: \"1.1\",
	        class: \"Exsurge ChantScore\" + (ctxt.editable ? \" EditableChantScore\" : \"\"),
	        width: width,
	        height: height,
	        viewBox: [0, 0, this.bounds.width, this.bounds.height].join(\" \")
	      };
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      // create defs section
	      var node = [ctxt.defsNode.cloneNode(true)];
	      node[0].appendChild(ctxt.createStyleNode());
	
	      if (this.titles) node.push(this.titles.createSvgNode(ctxt));
	
	      for (var i = 0; i < this.lines.length; i++) {
	        node.push(this.lines[i].createSvgNode(ctxt));
	      }node = _ExsurgeDrawing.QuickSvg.createNode(\"g\", {}, node);
	
	      node = _ExsurgeDrawing.QuickSvg.createNode(\"svg\", this.getSvgProps(ctxt), node);
	
	      node.source = this;
	      this.svg = node;
	
	      return node;
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt, zoom) {
	      // create defs section
	      var node = [_ExsurgeDrawing.QuickSvg.createSvgTree.apply(_ExsurgeDrawing.QuickSvg, [\"defs\", {}].concat(_toConsumableArray(ctxt.makeDefs.map(function (makeDef) {
	        return makeDef.makeSvgTree();
	      })), [ctxt.createStyleTree()]))];
	
	      if (this.titles) node.push(this.titles.createSvgTree(ctxt));
	
	      for (var i = 0; i < this.lines.length; i++) {
	        node.push(this.lines[i].createSvgTree(ctxt));
	      }node = _ExsurgeDrawing.QuickSvg.createSvgTree.apply(_ExsurgeDrawing.QuickSvg, [\"g\", {}].concat(_toConsumableArray(node)));
	      var svgProps = this.getSvgProps(ctxt, zoom);
	      svgProps.source = this;
	      node = _ExsurgeDrawing.QuickSvg.createSvgTree(\"svg\", svgProps, node);
	
	      return node;
	    }
	  }, {
	    key: \"createSvg\",
	    value: function createSvg(ctxt) {
	      var fragment = \"\";
	
	      // create defs section
	      for (var def in ctxt.defs) {
	        if (ctxt.defs.hasOwnProperty(def)) fragment += ctxt.defs[def];
	      }fragment += ctxt.createStyle();
	
	      fragment = _ExsurgeDrawing.QuickSvg.createFragment(\"defs\", {}, fragment);
	
	      if (this.titles) fragment += this.titles.createSvgFragment(ctxt);
	
	      for (var i = 0; i < this.lines.length; i++) {
	        fragment += this.lines[i].createSvgFragment(ctxt);
	      }fragment = _ExsurgeDrawing.QuickSvg.createFragment(\"g\", {}, fragment);
	
	      fragment = _ExsurgeDrawing.QuickSvg.createFragment(\"svg\", this.getSvgProps(ctxt), fragment);
	
	      return fragment;
	    }
	  }, {
	    key: \"createSvgNodeForEachLine\",
	    value: function createSvgNodeForEachLine(ctxt) {
	      var node = [];
	
	      var top = 0;
	      for (var i = 0; i < this.lines.length; i++) {
	        var lineFragment = [ctxt.defsNode.cloneNode(true), this.lines[i].createSvgNode(ctxt, top)];
	        lineFragment[0].appendChild(ctxt.createStyleNode());
	        var height = this.lines[i].bounds.height + ctxt.staffInterval * 1.5;
	        lineFragment = _ExsurgeDrawing.QuickSvg.createNode(\"g\", {}, lineFragment);
	        lineFragment = _ExsurgeDrawing.QuickSvg.createNode(\"svg\", {
	          xmlns: \"http://www.w3.org/2000/svg\",
	          version: \"1.1\",
	          class: \"Exsurge ChantScore\",
	          width: this.bounds.width,
	          height: height,
	          viewBox: [0, 0, this.bounds.width, height].join(\" \")
	        }, lineFragment);
	        node.push(lineFragment);
	        top += height;
	      }
	      return node;
	    }
	  }, {
	    key: \"createSvgForEachLine\",
	    value: function createSvgForEachLine(ctxt) {
	      var fragment = \"\",
	          fragmentDefs = \"\";
	
	      // create defs section
	      for (var def in ctxt.defs) {
	        if (ctxt.defs.hasOwnProperty(def)) fragmentDefs += ctxt.defs[def];
	      }fragmentDefs += ctxt.createStyle();
	
	      fragmentDefs = _ExsurgeDrawing.QuickSvg.createFragment(\"defs\", {}, fragmentDefs);
	      var top = 0;
	      for (var i = 0; i < this.lines.length; i++) {
	        var lineFragment = fragmentDefs + this.lines[i].createSvgFragment(ctxt, top);
	        var height = this.lines[i].bounds.height + ctxt.staffInterval * 1.5;
	        lineFragment = _ExsurgeDrawing.QuickSvg.createFragment(\"g\", {}, lineFragment);
	        lineFragment = _ExsurgeDrawing.QuickSvg.createFragment(\"svg\", {
	          xmlns: \"http://www.w3.org/2000/svg\",
	          version: \"1.1\",
	          \"xmlns:xlink\": \"http://www.w3.org/1999/xlink\",
	          class: \"Exsurge ChantScore\",
	          width: this.bounds.width,
	          height: height
	        }, lineFragment);
	        fragment += lineFragment;
	        top += height;
	      }
	      return fragment;
	    }
	  }, {
	    key: \"unserializeFromJson\",
	    value: function unserializeFromJson(data, ctxt) {
	      this.autoColoring = data[\"auto-coloring\"];
	
	      if (data.annotation !== null && data.annotation !== \"\") {
	        // create the annotation
	        this.annotation = new _ExsurgeDrawing.Annotation(ctxt, data.annotation);
	      } else this.annotation = null;
	
	      var createDropCap = data[\"drop-cap\"] === \"auto\" ? true : false;
	
	      _ExsurgeGabc.Gabc.parseChantNotations(data.notations, this, createDropCap);
	    }
	  }, {
	    key: \"serializeToJson\",
	    value: function serializeToJson() {
	      var data = {};
	
	      data[\"type\"] = \"score\";
	      data[\"auto-coloring\"] = true;
	
	      if (this.annotation !== null) data.annotation = this.annotation.unsanitizedText;else data.annotation = \"\";
	
	      return data;
	    }
	  }]);
	
	  return ChantScore;
	}();
	
	var ChantDocument = exports.ChantDocument = function () {
	  function ChantDocument() {
	    _classCallCheck(this, ChantDocument);
	
	    var defaults = {
	      layout: {
	        units: \"mm\",
	        \"default-font\": {
	          \"font-family\": \"Crimson\",
	          \"font-size\": 14
	        },
	        page: {
	          width: 8.5,
	          height: 11,
	          \"margin-left\": 0,
	          \"margin-top\": 0,
	          \"margin-right\": 0,
	          \"margin-bottom\": 0
	        }
	      },
	      scores: []
	    };
	
	    // default layout
	    this.copyLayout(this, defaults);
	
	    this.scores = defaults.scores;
	  }
	
	  _createClass(ChantDocument, [{
	    key: \"copyLayout\",
	    value: function copyLayout(to, from) {
	      to.layout = {
	        units: from.layout.units,
	        \"default-font\": {
	          \"font-family\": from.layout[\"default-font\"][\"font-family\"],
	          \"font-size\": from.layout[\"default-font\"][\"font-size\"]
	        },
	        page: {
	          width: from.layout.page.width,
	          height: from.layout.page.height,
	          \"margin-left\": from.layout.page[\"margin-left\"],
	          \"margin-top\": from.layout.page[\"margin-top\"],
	          \"margin-right\": from.layout.page[\"margin-right\"],
	          \"margin-bottom\": from.layout.page[\"margin-bottom\"]
	        }
	      };
	    }
	  }, {
	    key: \"unserializeFromJson\",
	    value: function unserializeFromJson(data) {
	      this.copyLayout(this, data);
	
	      this.scores = [];
	
	      // read in the scores
	      for (var i = 0; i < data.scores.length; i++) {
	        var score = new ChantScore();
	
	        score.unserializeFromJson(data.scores[i]);
	        this.scores.push(score);
	      }
	    }
	  }, {
	    key: \"serializeToJson\",
	    value: function serializeToJson() {
	      var data = {};
	
	      this.copyLayout(data, this);
	
	      data.scores = [];
	
	      // save scores...
	      for (var i = 0; i < this.scores.length; i++) {
	        data.scores.push(this.scores[i].serializeToJson());
	      }return data;
	    }
	  }]);

	  return ChantDocument;
	}();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	exports.ChantLine = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ExsurgeChant = __webpack_require__(8);
	
	var _ExsurgeChantMarkings = __webpack_require__(10);
	
	var _ExsurgeChantSigns = __webpack_require__(11);
	
	var _ExsurgeCore = __webpack_require__(1);
	
	var _ExsurgeDrawing = __webpack_require__(4);
	
	var _ExsurgeGlyphs = __webpack_require__(3);
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //
	// Author(s):
	// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
	//
	// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the \"Software\"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	//
	
	// a chant line represents one staff line on the page. ChantLines are created by the score
	// and laid out by the page
	var ChantLine = exports.ChantLine = function (_ChantLayoutElement) {
	  _inherits(ChantLine, _ChantLayoutElement);
	
	  function ChantLine(score) {
	    _classCallCheck(this, ChantLine);
	
	    var _this = _possibleConstructorReturn(this, (ChantLine.__proto__ || Object.getPrototypeOf(ChantLine)).call(this));
	
	    _this.score = score;
	
	    _this.notationsStartIndex = 0;
	    _this.numNotationsOnLine = 0;
	    _this.notationBounds = null; // Rect
	
	    _this.staffLeft = 0;
	    _this.staffRight = 0;
	
	    _this.startingClef = null; // necessary for the layout process
	    _this.custos = null;
	
	    _this.justify = true;
	
	    // these are markings that exist at the chant line level rather than at the neume level.
	    _this.ledgerLines = [];
	    _this.braces = [];
	
	    _this.nextLine = null;
	    _this.previousLine = null; // for layout assistance
	
	    _this.lyricLineHeight = 0; // height of each text line
	    _this.lyricLineBaseline = 0; // offsets from the top of the text line to the baseline
	    _this.numLyricLines = 0; // maximum count of lyrics on the same syllable
	
	    // fixme: make these configurable values from the score
	    _this.spaceAfterNotations = 0; // the space between the notation bounds and the first text track
	    _this.spaceBetweenTextTracks = 0; // spacing between each text track
	
	    _this.lastLyrics = [];
	    return _this;
	  }
	
	  _createClass(ChantLine, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      // start off with a rectangle that holds at least the four staff lines
	      this.notationBounds = new _ExsurgeCore.Rect(this.staffLeft, -(ctxt.staffLineWeight / 2 + 3 + ctxt.minSpaceAboveStaff) * ctxt.staffInterval, this.staffRight - this.staffLeft, (ctxt.staffLineWeight + 6 + ctxt.minSpaceAboveStaff) * ctxt.staffInterval);
	
	      // run through all the elements of the line and calculate the bounds of the notations,
	      // as well as the bounds of each text track we will use
	      var i;
	      var notations = this.score.notations;
	      var lastNeumeIndex = this.extraTextOnlyIndex === null ? this.notationsStartIndex + this.numNotationsOnLine : this.extraTextOnlyIndex;
	      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;
	      var notation = null;
	
	      this.notationBounds.union(this.startingClef.bounds);
	
	      // reset the lyric line offsets before we [re]calculate them now
	      this.lyricLineHeight = ctxt.textStyles.lyric.size * 1.1;
	      this.lyricLineBaseline = 0;
	      this.numLyricLines = 0;
	
	      this.altLineHeight = 0;
	      this.altLineBaseline = 0;
	      this.numAltLines = 0;
	
	      this.translationLineHeight = ctxt.textStyles.translation.size * 1.1;
	      this.translationLineBaseline = 0;
	      this.numTranslationLines = 0;
	
	      for (i = this.notationsStartIndex; i < lastNeumeIndex; i++) {
	        notation = notations[i];
	
	        this.notationBounds.union(notation.bounds);
	
	        // keep track of lyric line offsets
	        if (notation.lyrics.length && notation.lyrics[0].text) {
	          // if (notation.lyrics[0].bounds.height > this.lyricLineHeight)
	          //   this.lyricLineHeight = notation.lyrics[0].bounds.height;
	          if (notation.lyrics[0].origin.y > this.lyricLineBaseline) this.lyricLineBaseline = notation.lyrics[0].origin.y;
	          if (notation.lyrics.length > this.numLyricLines) this.numLyricLines = notation.lyrics.length;
	        }
	
	        if (notation.alText && this.numAltLines < notation.alText.length) {
	          if (notation.alText[0].bounds.height > this.altLineHeight) this.altLineHeight = notation.alText[0].bounds.height;
	          if (notation.alText[0].origin.y > this.altLineBaseline) this.altLineBaseline = notation.alText[0].origin.y;
	          if (notation.alText.length > this.numAltLines) this.numAltLines = notation.alText.length;
	        }
	
	        if (notation.translationText && notation.translationText[0] && notation.translationText[0].text) {
	          // if (
	          //   notation.translationText[0].bounds.height > this.translationLineHeight
	          // )
	          //   this.translationLineHeight =
	          //     notation.translationText[0].bounds.height;
	          if (notation.translationText[0].origin.y > this.translationLineBaseline) this.translationLineBaseline = notation.translationText[0].origin.y;
	          if (notation.translationText.length > this.numTranslationLines) this.numTranslationLines = notation.translationText.length;
	        }
	      }
	
	      if (this.custos) this.notationBounds.union(this.custos.bounds);
	
	      // add any braces to the notationBounds as well
	      for (i = 0; i < this.braces.length; i++) {
	        this.notationBounds.union(this.braces[i].bounds);
	      } // finalize the lyrics placement
	      var notationBoundsOffset = this.notationBounds.bottom() + ctxt.minSpaceBelowStaff * ctxt.staffInterval;
	      this.lyricLineBaseline += notationBoundsOffset;
	      this.translationLineBaseline += notationBoundsOffset;
	      this.altLineBaseline += this.notationBounds.y - this.altLineHeight - ctxt.staffInterval * 0.5;
	
	      for (i = this.notationsStartIndex; i < lastNeumeIndex; i++) {
	        notation = notations[i];
	        var offset = 0;
	        for (var j = 0; j < notation.lyrics.length; j++) {
	          notation.lyrics[j].bounds.y = offset + this.lyricLineBaseline;
	          offset += this.lyricLineHeight;
	        }
	
	        if (notation.translationText) {
	          for (j = 0; j < notation.translationText.length; j++) {
	            notation.translationText[j].bounds.y = offset + this.translationLineBaseline;
	            offset += this.translationLineHeight;
	          }
	        }
	
	        if (notation.alText) {
	          offset = 0;
	          for (j = 0; j < notation.alText.length; j++) {
	            notation.alText[j].bounds.y = offset + this.altLineBaseline;
	            offset -= ctxt.textStyles.al.size * 1.1;
	          }
	        }
	      }
	
	      this.extraTextOnlyHeight = 0;
	      // handle placement of extra TextOnly elements:
	      if (ctxt.useExtraTextOnly) {
	        var extraTextOnlyLyricIndex = this.extraTextOnlyLyricIndex;
	        if (this.extraTextOnlyIndex === null) {
	          // even if extraTextOnlyIndex is null, there might be extra lines on the last lyric if it is TextOnly:
	          var lastNotation = notations[lastNeumeIndex - 1] || {};
	          if (lastNotation.constructor === _ExsurgeChant.ChantLineBreak) lastNotation = notations[lastNeumeIndex - 2];
	          if (lastNotation.constructor === _ExsurgeChant.TextOnly && lastNotation.lyrics.length === 1 && lastNotation.lyrics[0].bounds.height > this.lyricLineHeight) {
	            this.extraTextOnlyHeight = this.lyricLineHeight;
	          }
	        } else {
	          var lastLyrics = null;
	          var xOffset = 0;
	          offset = (this.numLyricLines - 1) * this.lyricLineHeight;
	          offset += this.numTranslationLines * this.translationLineHeight;
	          var extraLines = 0;
	          for (i = this.extraTextOnlyIndex; i < lastIndex; i++) {
	            notation = notations[i];
	            if (!notation.lyrics[extraTextOnlyLyricIndex]) continue;
	            lastLyrics = notation.lyrics[extraTextOnlyLyricIndex];
	            if (lastLyrics.lineWidth) {
	              xOffset = this.staffRight - lastLyrics.lineWidth;
	              offset += this.lyricLineHeight;
	              extraLines++;
	            }
	            extraLines += lastLyrics.numLines - 1;
	            lastLyrics.bounds.y = offset + this.lyricLineBaseline;
	            notation.bounds.x += xOffset;
	          }
	          this.extraTextOnlyHeight = this.lyricLineHeight * extraLines;
	        }
	      }
	
	      if (this.startingClef.hasLyrics()) {
	        offset = 0;
	        for (j = 0; j < this.startingClef.lyrics.length; j++) {
	          this.startingClef.lyrics[j].bounds.y = offset + this.lyricLineBaseline;
	          offset += this.lyricLineHeight;
	        }
	      }
	
	      // dropCap and the annotations
	      if (this.notationsStartIndex === 0) {
	        if (this.score.annotation !== null) {
	          // annotations use dominant-baseline to align text to the top
	          this.score.annotation.bounds.x = this.staffLeft / 2;
	          this.score.annotation.bounds.y = -ctxt.staffInterval * 3;
	          if (this.score.dropCap !== null) {
	            var lowestPossibleAnnotationY = this.lyricLineBaseline - this.score.annotation.bounds.height - ctxt.staffInterval * ctxt.textStyles.annotation.padding - this.score.dropCap.origin.y;
	            // if the annotation would overlap with the drop cap, move the annotation higher.
	            // otherwise, center the annotation in the vertical space between the top of the drop cap and the top of the staff.
	            if (lowestPossibleAnnotationY < this.score.annotation.bounds.y) {
	              this.score.annotation.bounds.y = lowestPossibleAnnotationY;
	            } else {
	              this.score.annotation.bounds.y = (this.score.annotation.bounds.y + lowestPossibleAnnotationY) / 2;
	            }
	            if (this.score.annotation.bounds.y < this.notationBounds.y) {
	              this.notationBounds.y = this.score.annotation.bounds.y;
	              this.notationBounds.height += this.notationBounds.y - this.score.annotation.bounds.y;
	            }
	          }
	          this.score.annotation.bounds.y += this.score.annotation.origin.y;
	        }
	
	        if (this.score.dropCap !== null) {
	          // drop caps and annotations are drawn from their center, so aligning them
	          // horizontally is as easy as this.staffLeft / 2
	          this.score.dropCap.bounds.x = this.staffLeft / 2;
	          this.score.dropCap.bounds.y = this.lyricLineBaseline - this.score.dropCap.origin.y;
	          this.notationBounds.union(this.score.dropCap.bounds);
	          this.score.dropCap.bounds.y = this.lyricLineBaseline;
	        }
	      }
	
	      if (this.numLyricLines > 0) {
	        // add up the lyric line heights to get the total height of the chant line
	        var lyricAndTextRect = new _ExsurgeCore.Rect(0, notationBoundsOffset, 0, this.lyricLineHeight * this.numLyricLines + this.extraTextOnlyHeight + this.translationLineHeight * this.numTranslationLines);
	        this.notationBounds.union(lyricAndTextRect);
	      }
	      if (this.numAltLines > 0) {
	        var altLineTextRect = new _ExsurgeCore.Rect(0, this.notationBounds.y - this.altLineHeight - 0.5 * ctxt.staffInterval - ctxt.textStyles.al.size * 1.1 * (this.numAltLines - 1), 0, ctxt.textStyles.al.size * 1.1 * this.numAltLines);
	        this.notationBounds.union(altLineTextRect);
	      }
	      // Ensure that there is at least minSpaceBelowStaff below the lowest staff line:
	      this.notationBounds.union(new _ExsurgeCore.Rect(0, 0, 0, (3 + ctxt.staffLineWeight / 2 + ctxt.minSpaceBelowStaff) * ctxt.staffInterval));
	      var totalHeight = this.notationBounds.height;
	
	      this.bounds.x = 0;
	      this.bounds.y = this.notationBounds.y;
	      this.bounds.width = this.notationBounds.right();
	      this.bounds.height = totalHeight;
	
	      // the origin of the chant line's coordinate space is at the center line of the left extremity of the staff
	      this.origin = new _ExsurgeCore.Point(this.staffLeft, -this.notationBounds.y);
	    }
	
	    // TODO: remove if not necsessary
	
	  }, {
	    key: \"layoutInsertionCursor\",
	    value: function layoutInsertionCursor(ctxt) {
	      if (this.insertionCursor) {
	        // we have either a Notation to draw the cursor after, or the ChantLine itself when the cursor is the first thing on the line
	        this.insertionCursor.performLayout(ctxt);
	        this.insertionCursor.bounds.x = this.score.insertionElement.bounds.right() + (this.score.insertionElement.trailingSpace && this.score.insertionElement.calculatedTrailingSpace || 0) / 2 - this.insertionCursor.origin.x;
	      }
	      return this.insertionCursor;
	    }
	  }, {
	    key: \"draw\",
	    value: function draw(ctxt) {
	      var canvasCtxt = ctxt.canvasCtxt;
	
	      canvasCtxt.translate(this.bounds.x, this.bounds.y);
	
	      // draw the staff lines
	      var i,
	          x1 = this.staffLeft,
	          x2 = this.staffRight,
	          y;
	      canvasCtxt.lineWidth = ctxt.staffLineWeight;
	      canvasCtxt.strokeStyle = ctxt.staffLineColor;
	
	      for (i = -3; i <= 3; i += 2) {
	        y = ctxt.staffInterval * i;
	
	        canvasCtxt.beginPath();
	        canvasCtxt.moveTo(x1, y);
	        canvasCtxt.lineTo(x2, y);
	        canvasCtxt.stroke();
	      }
	
	      if (this.layoutInsertionCursor(ctxt)) {
	        this.insertionCursor.draw(ctxt);
	      }
	
	      // draw the ledger lines
	      for (i = 0; i < this.ledgerLines.length; i++) {
	        var ledgerLine = this.ledgerLines[i];
	        y = ctxt.calculateHeightFromStaffPosition(ledgerLine.staffPosition);
	
	        canvasCtxt.beginPath();
	        canvasCtxt.moveTo(ledgerLine.x1, y);
	        canvasCtxt.lineTo(ledgerLine.x2, y);
	        canvasCtxt.stroke();
	      }
	
	      // fixme: draw the braces
	
	      // draw the dropCap and the annotations
	      if (this.notationsStartIndex === 0) {
	        if (this.score.dropCap !== null) this.score.dropCap.draw(ctxt);
	
	        if (this.score.annotation !== null && (!this.score.mergeAnnotationWithTextLeft || this.score.dropCap))
	          // only draw it if there is a dropCap or there is no mergeAnnotationWithTextLeft
	          this.score.annotation.draw(ctxt);
	      }
	
	      // draw the notations
	      var notations = this.score.notations;
	      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;
	
	      for (i = this.notationsStartIndex; i < lastIndex; i++) {
	        notations[i].draw(ctxt);
	      }this.startingClef.draw(ctxt);
	
	      if (this.custos) this.custos.draw(ctxt);
	
	      canvasCtxt.translate(-this.bounds.x, -this.bounds.y);
	    }
	  }, {
	    key: \"getInnerNodes\",
	    value: function getInnerNodes(ctxt) {
	      var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var functionNames = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { quickSvg: \"createNode\", elements: \"createSvgNode\" };
	
	      var inner = [];
	
	      // add the chant lines
	      var i,
	          x1 = this.staffLeft,
	          x2 = this.staffRight;
	
	      if (ctxt.editable) {
	        inner.push(_ExsurgeDrawing.QuickSvg[functionNames.quickSvg](\"rect\", {
	          key: \"insertion\",
	          x: x1,
	          y: ctxt.staffInterval * -3,
	          width: x2 - x1,
	          height: ctxt.staffInterval * 6,
	          fill: \"none\"
	        }));
	      }
	
	      // create the staff lines
	      for (i = -3; i <= 3; i += 2) {
	        inner.push(_ExsurgeDrawing.QuickSvg[functionNames.quickSvg](\"line\", {
	          key: i,
	          x1: x1,
	          y1: ctxt.staffInterval * i,
	          x2: x2,
	          y2: ctxt.staffInterval * i,
	          stroke: ctxt.staffLineColor,
	          \"stroke-width\": ctxt.staffLineWeight,
	          class: \"staffLine\"
	        }));
	      }
	
	      inner = [_ExsurgeDrawing.QuickSvg[functionNames.quickSvg](\"g\", { class: \"staffLines\" }, inner)];
	
	      if (this.layoutInsertionCursor(ctxt)) {
	        inner.push(this.insertionCursor[functionNames.elements](ctxt));
	      }
	
	      // create the ledger lines
	      for (i = 0; i < this.ledgerLines.length; i++) {
	        var ledgerLine = this.ledgerLines[i];
	        var y = ctxt.calculateHeightFromStaffPosition(ledgerLine.staffPosition);
	
	        inner.push(_ExsurgeDrawing.QuickSvg[functionNames.quickSvg](\"line\", {
	          x1: ledgerLine.x1,
	          y1: y,
	          x2: ledgerLine.x2,
	          y2: y,
	          stroke: ctxt.staffLineColor,
	          \"stroke-width\": ctxt.staffLineWeight,
	          class: \"ledgerLine\"
	        }));
	      }
	
	      // add any braces
	      for (i = 0; i < this.braces.length; i++) {
	        inner.push(this.braces[i][functionNames.elements](ctxt));
	      } // dropCap and the annotations
	      if (this.notationsStartIndex === 0) {
	        if (this.score.dropCap !== null) inner.push(this.score.dropCap[functionNames.elements](ctxt));
	
	        if (this.score.annotation !== null && (!this.score.mergeAnnotationWithTextLeft || this.score.dropCap))
	          // only draw it if there is a dropCap or there is no mergeAnnotationWithTextLeft
	          inner = inner.concat(this.score.annotation[functionNames.elements](ctxt));
	      }
	
	      inner.push(this.startingClef[functionNames.elements](ctxt));
	
	      var notations = this.score.notations;
	      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;
	
	      // add all of the notations
	      for (i = this.notationsStartIndex; i < lastIndex; i++) {
	        inner.push(notations[i][functionNames.elements](ctxt));
	      }if (this.custos) inner.push(this.custos[functionNames.elements](ctxt));
	      return inner;
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	
	      var inner = this.getInnerNodes(ctxt, top, {
	        quickSvg: \"createNode\",
	        elements: \"createSvgNode\"
	      });
	
	      return _ExsurgeDrawing.QuickSvg.createNode(\"g\", {
	        class: \"chantLine\",
	        transform: \"translate(\" + this.bounds.x + \",\" + (this.bounds.y - top) + \")\",
	        \"element-index\": this.elementIndex,
	        source: this
	      }, inner);
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt) {
	      var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	
	      var inner = this.getInnerNodes(ctxt, top, {
	        quickSvg: \"createSvgTree\",
	        elements: \"createSvgTree\"
	      });
	
	      return _ExsurgeDrawing.QuickSvg.createSvgTree.apply(_ExsurgeDrawing.QuickSvg, [\"g\", {
	        class: \"chantLine\",
	        transform: \"translate(\" + this.bounds.x + \",\" + (this.bounds.y - top) + \")\",
	        \"element-index\": this.elementIndex
	      }].concat(_toConsumableArray(inner)));
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	
	      var inner = \"\";
	
	      // add the chant lines
	      var i,
	          x1 = this.staffLeft,
	          x2 = this.staffRight;
	
	      // create the staff lines
	      for (i = -3; i <= 3; i += 2) {
	        inner += _ExsurgeDrawing.QuickSvg.createFragment(\"line\", {
	          x1: x1,
	          y1: ctxt.staffInterval * i,
	          x2: x2,
	          y2: ctxt.staffInterval * i,
	          stroke: ctxt.staffLineColor,
	          \"stroke-width\": ctxt.staffLineWeight,
	          class: \"staffLine\"
	        });
	      }
	
	      inner = _ExsurgeDrawing.QuickSvg.createFragment(\"g\", { class: \"staffLines\" }, inner);
	
	      if (this.layoutInsertionCursor(ctxt)) {
	        inner += this.insertionCursor.createSvgFragment(ctxt);
	      }
	
	      // create the ledger lines
	      for (i = 0; i < this.ledgerLines.length; i++) {
	        var ledgerLine = this.ledgerLines[i];
	        var y = ctxt.calculateHeightFromStaffPosition(ledgerLine.staffPosition);
	
	        inner += _ExsurgeDrawing.QuickSvg.createFragment(\"line\", {
	          x1: ledgerLine.x1,
	          y1: y,
	          x2: ledgerLine.x2,
	          y2: y,
	          stroke: ctxt.staffLineColor,
	          \"stroke-width\": ctxt.staffLineWeight,
	          class: \"ledgerLine\"
	        });
	      }
	
	      // add any braces
	      for (i = 0; i < this.braces.length; i++) {
	        inner += this.braces[i].createSvgFragment(ctxt);
	      } // dropCap and the annotations
	      if (this.notationsStartIndex === 0) {
	        if (this.score.dropCap !== null) inner += this.score.dropCap.createSvgFragment(ctxt);
	
	        if (this.score.annotation !== null && (!this.score.mergeAnnotationWithTextLeft || this.score.dropCap))
	          // only draw it if there is a dropCap or there is no mergeAnnotationWithTextLeft
	          inner += this.score.annotation.createSvgFragment(ctxt);
	      }
	
	      inner += this.startingClef.createSvgFragment(ctxt);
	
	      var notations = this.score.notations;
	      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;
	
	      // add all of the notations
	      for (i = this.notationsStartIndex; i < lastIndex; i++) {
	        inner += notations[i].createSvgFragment(ctxt);
	      }if (this.custos) inner += this.custos.createSvgFragment(ctxt);
	
	      return _ExsurgeDrawing.QuickSvg.createFragment(\"g\", {
	        class: \"chantLine\",
	        transform: \"translate(\" + this.bounds.x + \",\" + (this.bounds.y - top) + \")\",
	        \"element-index\": this.elementIndex
	      }, inner);
	    }
	
	    // code below based on code by: https://gist.github.com/alexhornbake
	    //
	    // optimized for braces that are only drawn horizontally.
	    // returns svg path string ready to insert into svg doc
	
	  }, {
	    key: \"generateCurlyBraceDrawable\",
	    value: function generateCurlyBraceDrawable(ctxt, x1, x2, y, isAbove) {
	      var h;
	
	      if (isAbove) h = -ctxt.staffInterval / 2;else h = ctxt.staffInterval / 2;
	
	      // and q factor, .5 is normal, higher q = more expressive bracket
	      var q = 0.6;
	
	      var len = x2 - x1;
	
	      //Calculate Control Points of path,
	      var qx1 = x1;
	      var qy1 = y + q * h;
	      var qx2 = x1 + 0.25 * len;
	      var qy2 = y + (1 - q) * h;
	      var tx1 = x1 + 0.5 * len;
	      var ty1 = y + h;
	      var qx3 = x2;
	      var qy3 = y + q * h;
	      var qx4 = x1 + 0.75 * len;
	      var qy4 = y + (1 - q) * h;
	      var d = \"M \" + x1 + \" \" + y + \" Q \" + qx1 + \" \" + qy1 + \" \" + qx2 + \" \" + qy2 + \" T \" + tx1 + \" \" + ty1 + \" M \" + x2 + \" \" + y + \" Q \" + qx3 + \" \" + qy3 + \" \" + qx4 + \" \" + qy4 + \" T \" + tx1 + \" \" + ty1;
	
	      return _ExsurgeDrawing.QuickSvg.createFragment(\"path\", {
	        d: d,
	        stroke: ctxt.neumeLineColor,
	        \"stroke-width\": ctxt.neumeLineWeight + \"px\",
	        fill: \"none\"
	      });
	    }
	  }, {
	    key: \"buildFromChantNotationIndex\",
	    value: function buildFromChantNotationIndex(ctxt, newElementStart, width) {
	      // todo: reset / clear the children we have in case they have data
	      var notations = this.score.notations,
	          beginningLyrics = null,
	          prev = null,
	          prevNeume = null,
	          prevLyrics = [];
	      var condensableSpaces = [];
	      this.notationsStartIndex = newElementStart;
	      this.numNotationsOnLine = 0;
	
	      this.staffLeft = 0;
	      this.paddingLeft = 0;
	
	      this.extraTextOnlyIndex = null;
	      this.extraTextOnlyLyricIndex = 0;
	
	      if (width > 0) this.staffRight = width;else this.staffRight = Infinity; // no limit to staff size
	
	      // If this is the first chant line, then we have to make room for a
	      // drop cap and/or annotation, if present
	      if (this.notationsStartIndex === 0) {
	        var padding = 0;
	
	        if (this.score.dropCap !== null) padding = this.score.dropCap.bounds.width + this.score.dropCap.padding * 2;
	
	        if (this.score.annotation !== null && (!this.score.mergeAnnotationWithTextLeft || this.score.dropCap)) padding = Math.max(padding, this.score.annotation.bounds.width + this.score.annotation.padding * 2);
	
	        this.staffLeft += padding;
	        if (this.score.dropCap !== null) this.paddingLeft = (padding - this.score.dropCap.bounds.width) / 2;
	      } else {
	        prev = notations[newElementStart - 1];
	        if (prev.constructor === _ExsurgeChantSigns.DoubleBar && prev.hasLyrics() && (prev.lyrics.length > 1 || !prev.lyrics[0].text.match(/^(i\\.?)+j\\.?/))) {
	          beginningLyrics = prev.lyrics.map(function (lyric) {
	            var newLyric = new _ExsurgeDrawing.Lyric(ctxt, lyric.originalText, lyric.lyricType, lyric.notation, lyric.notations, lyric.sourceIndex);
	            newLyric.elidesToNext = lyric.elidesToNext;
	            // Hide the original lyric by setting its bounds.y to an extremely high number.
	            // If the chant is re-laid out, this value will be recalculated so that it won't stay hidden.
	            lyric.bounds.y = Number.MAX_SAFE_INTEGER;
	            return newLyric;
	          });
	          var minX = beginningLyrics.map(function (l) {
	            return l.bounds.x;
	          }).reduce(function (a, b) {
	            return a < b ? a : b;
	          });
	          beginningLyrics.forEach(function (l) {
	            l.bounds.x -= minX;
	          });
	        }
	      }
	
	      // set up the clef...
	      // if the first notation on the line is a starting clef, then we treat it a little differently...
	      // the clef becomes this line's starting clef and we skip over the clef in the notations array
	      if (notations.length && notations[newElementStart].isClef) {
	        ctxt.activeClef = notations[newElementStart];
	        newElementStart++;
	        this.notationsStartIndex++;
	      }
	
	      // make a copy for this line to use at the beginning
	      this.startingClef = ctxt.activeClef.clone();
	      this.startingClef.performLayout(ctxt);
	      this.startingClef.bounds.x = this.staffLeft;
	
	      var curr = this.startingClef;
	
	      if (beginningLyrics) {
	        _ExsurgeDrawing.LyricArray.setNotation(beginningLyrics, curr);
	      }
	
	      // estimate how much space we have available to us
	      var rightNotationBoundary = this.staffRight - _ExsurgeGlyphs.Glyphs.CustosLong.bounds.width * ctxt.glyphScaling; // possible custos on the line
	      var lastTranslationTextWithEndNeume = null;
	
	      // iterate through the notations, fittng what we can on this line
	      var i,
	          j,
	          lastNotationIndex = notations.length - 1;
	
	      if (curr.hasLyrics()) _ExsurgeDrawing.LyricArray.mergeIn(this.lastLyrics, curr.lyrics);
	
	      // if we already have a start brace on the context, we must be continuing it from the previous system.
	      if (ctxt.lastStartBrace && !ctxt.lastStartBrace.note) {
	        ctxt.lastStartBrace.note = this.startingClef;
	      }
	      var lastLyricsBeforeTextOnly;
	      var textOnlyStartIndex;
	
	      for (i = newElementStart; i <= lastNotationIndex; i++) {
	        prev = curr;
	        if (curr.constructor !== _ExsurgeChant.TextOnly) prevNeume = curr;
	
	        curr = notations[i];
	
	        var actualRightBoundary;
	        if (i === lastNotationIndex || curr.constructor === _ExsurgeChantSigns.Custos || prev.constructor === _ExsurgeChantSigns.Custos && curr.isDivider || curr.constructor === _ExsurgeChant.ChantLineBreak && prevNeume.constructor === _ExsurgeChantSigns.Custos) {
	          // on the last notation of the score, we don't need a custos or trailing space, so we use staffRight as the
	          // right boundary.
	          // Also, if the current notation is a divider and the previous was a custos, we don't need extra space
	          // because if the following notation won't fit, we can switch the order and use the custos as the end-of-the-line custos
	          // Ditto in the case of the current element being a chant line break and the previous neume a custos, because that custos will become our end-of-line custos
	          actualRightBoundary = this.staffRight;
	        } else if (i === lastNotationIndex - 1) {
	          // on the penultimate notation, make sure there is at least enough room for whichever takes up less space,
	          // between the final notation and a custos:
	          actualRightBoundary = Math.max(rightNotationBoundary, this.staffRight - notations[lastNotationIndex].bounds.width);
	        } else {
	          // Otherwise, we use rightNotationBoundary, which leaves room for a custos...
	          actualRightBoundary = rightNotationBoundary;
	        }
	
	        // First check if we're already beyond the rightNotationBoundary (due to condensing that hasn't yet happened) and have a good element to end with
	        // but if we have 2 or fewer elements, or if the current element is a line break or a custos, we'll go ahead and try for them anyway.
	        var forceBreak = !curr.isDivider && curr.constructor !== _ExsurgeChant.ChantLineBreak && curr.constructor !== _ExsurgeChantSigns.Custos && !(curr.constructor === _ExsurgeChant.TextOnly && curr.hasLyrics() && /^(?:[*†]|i+j\\.?)$/.test(curr.lyrics[0].text)) && lastNotationIndex - i > 1 && !prevNeume.keepWithNext && prevNeume.bounds.right() >= rightNotationBoundary;
	
	        // also force a break if we've run into extra TextOnly elements, but the current notation is not a TextOnly and has lyrics
	        forceBreak = forceBreak || this.extraTextOnlyIndex !== null && curr.constructor !== _ExsurgeChant.TextOnly && curr.constructor !== _ExsurgeChant.ChantLineBreak && curr.constructor !== _ExsurgeChantSigns.Custos && curr.hasLyrics();
	
	        if (curr instanceof _ExsurgeChant.TextOnly && prev === prevNeume) {
	          lastLyricsBeforeTextOnly = this.lastLyrics.slice();
	          textOnlyStartIndex = i;
	        }
	        if (curr instanceof _ExsurgeChant.TextOnly && notations[textOnlyStartIndex] && !notations[textOnlyStartIndex].hasLyrics()) {
	          // we want textOnlyStartIndex to be the first TextOnly that actually has lyrics,
	          // so if the current \"textOnlyStart\" element does not have lyrics, and we have another textOnly
	          // that does have lyrics, we will use it instead
	          textOnlyStartIndex = i;
	        }
	
	        if (curr.hasLyrics() && curr.lyrics[0].needsLayout) {
	          curr.lyrics[0].recalculateMetrics(ctxt);
	        }
	
	        // try to fit the curr element on this line.
	        // if it doesn't fit, we finish up here.
	        var fitsOnLine = !forceBreak && this.positionNotationElement(ctxt, this.lastLyrics, prevNeume, curr, actualRightBoundary, this.extraTextOnlyIndex ? [] : condensableSpaces // no spaces are condensable once we are on extra text only lyrics
	        );
	        var candidateForExtraTextOnlyLine = ctxt.useExtraTextOnly && curr.constructor === _ExsurgeChant.TextOnly && _ExsurgeDrawing.LyricArray.hasOnlyOneLyric(curr.lyrics) && (fitsOnLine === false || this.extraTextOnlyIndex !== null);
	        var extraTextOnlyLyricIndex;
	        if (candidateForExtraTextOnlyLine && this.extraTextOnlyIndex === null) {
	          // check to make sure there is enough text to put on the text only line:
	          extraTextOnlyLyricIndex = _ExsurgeDrawing.LyricArray.indexOfLyric(curr.lyrics);
	          if (textOnlyStartIndex === i) {
	            var currentLyric = notations[i].lyrics[extraTextOnlyLyricIndex].text;
	            if (currentLyric.length <= 1) {
	              var nextNotation = notations[i + 1];
	              candidateForExtraTextOnlyLine = nextNotation && nextNotation.constructor === _ExsurgeChant.TextOnly && nextNotation.lyrics[extraTextOnlyLyricIndex] && nextNotation.lyrics[extraTextOnlyLyricIndex].text.length > 0;
	            }
	          }
	        }
	        if (candidateForExtraTextOnlyLine) {
	          // a special case for TextOnly elements that don't fit on the line: since they don't have neumes associated with them, we can place this
	          // and any additional TextOnly elements just below the current lyric lines, but we can only do this if the TextOnly elements have only one
	          // line of lyrics associated with them.
	          var firstOnLine;
	          extraTextOnlyLyricIndex = this.extraTextOnlyLyricIndex;
	          if (this.extraTextOnlyIndex === null && notations[textOnlyStartIndex].lyrics.length) {
	            if (textOnlyStartIndex === this.notationsStartIndex || !ctxt.startExtraTextOnlyFromFirst) {
	              textOnlyStartIndex = i;
	              var lastNotationWithLyrics = notations.slice(this.notationsStartIndex, i).reverse().find(function (notation) {
	                return notation.hasLyrics();
	              });
	              lastLyricsBeforeTextOnly = lastNotationWithLyrics && lastNotationWithLyrics.lyrics.slice() || [];
	            }
	            // go back to the first in this string of consecutive TextOnly elements.
	            this.extraTextOnlyIndex = textOnlyStartIndex;
	            extraTextOnlyLyricIndex = this.extraTextOnlyLyricIndex = _ExsurgeDrawing.LyricArray.indexOfLyric(curr.lyrics);
	            this.lastLyricsBeforeTextOnly = lastLyricsBeforeTextOnly;
	            this.lastLyrics = [];
	            i = textOnlyStartIndex - 1;
	            this.numNotationsOnLine = textOnlyStartIndex - this.notationsStartIndex;
	            continue;
	          }
	          delete curr.lyrics[extraTextOnlyLyricIndex].lineWidth;
	          if (!fitsOnLine || i === this.extraTextOnlyIndex) {
	            curr.bounds.x = curr.lyrics[extraTextOnlyLyricIndex].origin.x;
	            var lastLyricRight = ctxt.startExtraTextOnlyFromFirst ? _ExsurgeDrawing.LyricArray.getRight(this.lastLyrics) + (ctxt.minLyricWordSpacing || 0) : 0;
	            curr.lyrics[extraTextOnlyLyricIndex].setMaxWidth(ctxt, this.staffRight, this.staffRight - lastLyricRight);
	            firstOnLine = curr;
	          }
	          if (firstOnLine) firstOnLine.lyrics[extraTextOnlyLyricIndex].lineWidth = curr.lyrics[extraTextOnlyLyricIndex].getRight();
	        } else if (fitsOnLine === false) {
	          var isTextOnlyBeforeDivider = function isTextOnlyBeforeDivider(i) {
	            var curr = notations[i];
	            if (curr.constructor !== _ExsurgeChant.TextOnly) return false;
	            var firstDivider = notations.slice(i + 1).findIndex(function (notation) {
	              return notation.isDivider;
	            });
	            if (firstDivider < 0) return false;
	            return notations.slice(i + 1, i + 1 + firstDivider).every(function (notation) {
	              return notation.constructor === _ExsurgeChant.TextOnly;
	            });
	          };
	          // first check for elements that cannot begin a system: dividers and custodes
	          while (this.numNotationsOnLine > 1 && (curr.isDivider || curr.constructor === _ExsurgeChantSigns.Custos || isTextOnlyBeforeDivider(i))) {
	            curr = notations[--i];
	            this.numNotationsOnLine--;
	            if (this.lastLyricsBeforeTextOnly && isTextOnlyBeforeDivider(i)) {
	              delete this.lastLyricsBeforeTextOnly;
	            }
	          }
	
	          if (lastTranslationTextWithEndNeume) {}
	          // console.info(notations[i - 1], lastTranslationTextWithEndNeume);
	          // TODO?: need to go back to before the last translation text start:
	
	
	          // count syllables and notes
	          var notationsAfterBreak = notations.slice(i + 1);
	          var countSyllables = 0;
	          var countNotes = 0;
	          if (ctxt.minSyllablesLastLine && ctxt.minNotesLastLine) {
	            countSyllables = notationsAfterBreak.filter(function (notation) {
	              return notation.hasLyrics();
	            }).length;
	            countNotes = notationsAfterBreak.flatMap(function (notation) {
	              return notation.notes;
	            }).filter(function (note) {
	              return !!note;
	            }).length;
	          }
	
	          // check if the prev elements want to be kept with this one
	          for (j = i - 1; j > this.notationsStartIndex; j--) {
	            var cne = notations[j];
	            curr = notations[j + 1];
	
	            // curr is the first notation on the next line
	            // cne is the last notation on this line
	            if (ctxt.minSyllablesLastLine && ctxt.minNotesLastLine) {
	              countSyllables += curr.hasLyrics() ? 1 : 0;
	              countNotes += (curr.notes || []).length;
	            }
	
	            if (cne.firstWithNoWidth) {
	              this.numNotationsOnLine--;
	              continue;
	            }
	
	            // don't let a line break occur in the middle of a translation
	            if (lastTranslationTextWithEndNeume) {
	              this.numNotationsOnLine--;
	              if (cne === lastTranslationTextWithEndNeume) {
	                lastTranslationTextWithEndNeume = null;
	              }
	              continue;
	            }
	
	            // force any notations starting with a quilisma or inclinatum (diamond) to be kept with the previous notation:
	            if (curr && curr.notes && (curr.notes[0].shape === _ExsurgeChant.NoteShape.Quilisma || curr.notes[0].shape === _ExsurgeChant.NoteShape.Inclinatum)) {
	              this.numNotationsOnLine--;
	              continue;
	            }
	
	            if (countSyllables < ctxt.minSyllablesLastLine && countNotes < ctxt.minNotesLastLine) {
	              this.numNotationsOnLine--;
	              continue;
	            }
	
	            // if the line break is allowed (cne.allowLineBreakBeforeNext), keep this number of notations around so we can check during justification
	            // whether there would be too much space introduced between
	            if (cne.keepWithNext === true) {
	              if (cne.allowLineBreakBeforeNext && !this.maxNumNotationsOnLine) this.maxNumNotationsOnLine = this.numNotationsOnLine;
	              this.numNotationsOnLine--;
	            } else break;
	          }
	          if (this.extraTextOnlyIndex && this.notationsStartIndex + this.numNotationsOnLine <= this.extraTextOnlyIndex) {
	            // we've cut back to before the extra text only index, so we have to remove it:
	            this.extraTextOnlyIndex = null;
	          }
	
	          // if for some reason not a single notation can fit on the line, we'd better put it on anyway, to avoid an infinite loop:
	          if (this.numNotationsOnLine === 0) this.numNotationsOnLine = 1;
	
	          // determine the neumes we can space apart, if we do end up justifying
	          curr = this.findNeumesToJustify(prevLyrics);
	
	          this.lastLyrics = prevLyrics;
	          if (this.maxNumNotationsOnLine) {
	            // Check whether we should squeeze some extra notations on the line to avoid too much space after justification:
	            // Check how much space we would have without the extra notations
	            var extraSpace = this.getWhitespaceOnRight(ctxt);
	            if (extraSpace / this.toJustify.length > ctxt.staffInterval * ctxt.maxExtraSpaceInStaffIntervals) {
	              _ExsurgeDrawing.LyricArray.mergeInArray(prevLyrics, notations.slice(this.notationsStartIndex + this.numNotationsOnLine, this.notationsStartIndex + this.maxNumNotationsOnLine));
	              this.numNotationsOnLine = this.maxNumNotationsOnLine;
	              delete this.maxNumNotationsOnLine;
	            }
	          }
	
	          // if the next line begins with a fresh word, than there can be extra space between the last notation on this line and the custos:
	          var next = this.score.notations[this.extraTextOnlyIndex === null ? this.notationsStartIndex + this.numNotationsOnLine : this.extraTextOnlyIndex];
	          if (next && next.hasLyrics() && (next.lyrics[0].lyricType === _ExsurgeDrawing.LyricType.BeginningSyllable || next.lyrics[0].lyricType === _ExsurgeDrawing.LyricType.SingleSyllable)) {
	            this.toJustify.push(this.custos);
	          }
	
	          if (j >= 1 && notations[j].isDivider && notations[j - 1].constructor === _ExsurgeChantSigns.Custos) {
	            // reverse the order: put the divider first, and end the line with the custos.
	            prevLyrics = [];
	            for (i = j - 2; i >= this.notationsStartIndex; i--) {
	              if (notations[i].hasLyrics()) {
	                _ExsurgeDrawing.LyricArray.mergeIn(prevLyrics, notations[i].lyrics);
	                break;
	              }
	            }
	            // remove the custos and divider from the condensable spaces list, before adding the divider back, when repositioning it.
	            condensableSpaces.sum -= condensableSpaces.pop().condensable;
	            condensableSpaces.sum -= condensableSpaces.pop().condensable;
	            this.positionNotationElement(ctxt, prevLyrics, notations[j - 2], notations[j], this.staffRight, condensableSpaces);
	            this.custos = notations[j - 1];
	            this.custos.bounds.x = this.staffRight - this.custos.bounds.width - this.custos.leadingSpace;
	          }
	
	          // we are at the end of the line!
	          break;
	        }
	
	        if (curr.hasLyrics()) _ExsurgeDrawing.LyricArray.mergeIn(this.lastLyrics, curr.lyrics);
	
	        if (lastTranslationTextWithEndNeume && curr === lastTranslationTextWithEndNeume.translationText[0].endNeume) {
	          lastTranslationTextWithEndNeume = null;
	        } else if (curr.translationText && curr.translationText.length && curr.translationText[0].endNeume) {
	          lastTranslationTextWithEndNeume = curr;
	        }
	
	        curr.line = this;
	        this.numNotationsOnLine++;
	
	        if (curr.isClef) ctxt.activeClef = curr;
	
	        // line breaks are a special case indicating to stop processing here
	        if (curr.constructor === _ExsurgeChant.ChantLineBreak && width > 0) {
	          this.justify = curr.justify || this.extraTextOnlyIndex !== null || this.getWhitespaceOnRight(ctxt) < 0;
	          if (this.justify) this.findNeumesToJustify(prevLyrics);
	          break;
	        }
	
	        if (curr.constructor === _ExsurgeChantSigns.Custos) {
	          this.custos = curr;
	        } else if (curr.isNeume) {
	          this.custos = null;
	        }
	      }
	
	      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine - 1;
	      var last = notations[lastIndex] || {};
	      while (lastIndex > 0 && (last.constructor === _ExsurgeChant.ChantLineBreak || last.constructor === _ExsurgeChantSigns.Custos || last.constructor === _ExsurgeChant.TextOnly)) {
	        last = notations[--lastIndex];
	      }
	      var isLastLine = this.notationsStartIndex + this.numNotationsOnLine === notations.length;
	      if (this.justify && this.extraTextOnlyIndex !== null || width > 0 && isLastLine) {
	        // this is the last chant line, or it has extra TextOnly elements at the end
	        if (!this.toJustify) this.findNeumesToJustify(prevLyrics);
	        this.justify = (!isLastLine || last.isDivider) && this.getWhitespaceOnRight(ctxt) / (this.toJustify.length || 1) <= ctxt.staffInterval * ctxt.maxExtraSpaceInStaffIntervals;
	      }
	
	      if (!this.custos) {
	        // create the automatic custos at the end of the line if there are neumes left in the notations
	        for (i = this.notationsStartIndex + this.numNotationsOnLine; i < notations.length; i++) {
	          var notation = notations[i];
	
	          if (notation.isNeume) {
	            this.custos = new _ExsurgeChantSigns.Custos(true);
	            ctxt.currNotationIndex = i - 1; // make sure the context knows where the custos is
	            this.custos.performLayout(ctxt);
	
	            if (this.justify) {
	              // Put the custos at the very end of the line
	              this.custos.bounds.x = this.staffRight - this.custos.bounds.width - this.custos.leadingSpace;
	            } else {
	              this.custos.bounds.x = prevNeume.bounds.right() + prevNeume.calculatedTrailingSpace;
	            }
	            // nothing more to see here...
	            break;
	          }
	        }
	      }
	
	      if (this.lastLyricsBeforeTextOnly) {
	        this.lastLyrics = this.lastLyricsBeforeTextOnly;
	        delete this.lastLyricsBeforeTextOnly;
	      }
	
	      // find the final lyric and mark it as connecting if needed.
	      if (width > 0) {
	        var whitespace = this.getWhitespaceOnRight();
	        var rightEdge = this.staffRight;
	        if (whitespace < 0) {
	          rightEdge -= whitespace;
	        }
	      }
	      i = 0;
	      while (this.lastLyrics && this.lastLyrics[i]) {
	        var lyrics = this.lastLyrics[i];
	        if (lyrics.allowsConnector()) {
	          lyrics.setNeedsConnector(true, 0);
	          if (width > 0 && ctxt.minLyricWordSpacing < ctxt.hyphenWidth) {
	            whitespace = rightEdge - lyrics.getRight();
	            // shrink the hyphen if we are already out of whitespace or if we would be if we used a regular hyphen:
	            if (whitespace < 0) {
	              var minHyphenWidth = Math.max(ctxt.hyphenWidth + whitespace, this.lastLyrics.length > 1 ? ctxt.intraNeumeSpacing : ctxt.minLyricWordSpacing);
	              // we might not need to shift the syllable, but we do want to shrink the hyphen...
	              lyrics.setConnectorWidth(minHyphenWidth);
	            }
	          }
	        }
	        ++i;
	      }
	
	      // if the provided width is less than zero, then set the width of the line
	      // based on the last notation
	      if (width <= 0) {
	        this.staffRight = notations[this.notationsStartIndex + this.numNotationsOnLine - 1].bounds.right();
	        this.justify = false;
	      }
	
	      // Justify the line if we need to
	      this.justifyElements(ctxt, this.justify, condensableSpaces);
	
	      this.centerDividers();
	
	      this.finishLayout(ctxt);
	    }
	  }, {
	    key: \"centerDividers\",
	    value: function centerDividers() {
	      var lastIndex = this.extraTextOnlyIndex === null ? this.notationsStartIndex + this.numNotationsOnLine : this.extraTextOnlyIndex,
	          curr;
	      for (var i = this.notationsStartIndex; i < lastIndex; i++) {
	        curr = this.score.notations[i];
	
	        if (curr && curr.isDivider) {
	          var j = 1;
	          var prev = this.score.notations[i - 1];
	          var next = i + 1 === lastIndex ? this.custos : this.score.notations[i + 1];
	          if (prev === next && next === this.custos) {
	            prev = this.score.notations[i - 2];
	            // force custos to right edge in this case, since it is a custos that exists
	            // regardless of line break, and would normally be before the double bar, but in this case it ends the line:
	            next.bounds.x = this.staffRight - next.bounds.width;
	          }
	          if (prev && next) {
	            //if (prev instanceof TextOnly || next instanceof TextOnly) continue;
	            var oldBoundsX = curr.bounds.x;
	            var barWidth = curr.bounds.width;
	            var leftPoint = prev instanceof _ExsurgeChant.TextOnly && prev.hasLyrics() ? prev.lyrics[0].getRight() : prev.bounds.right(),
	                rightPoint = next instanceof _ExsurgeChant.TextOnly && next.hasLyrics() ? next.lyrics[0].getLeft() : next.bounds.x;
	            if (prev instanceof _ExsurgeChant.TextOnly) {
	              var _prev = this.score.notations.slice(this.notationsStartIndex, i).reverse().find(function (notation) {
	                return !(notation instanceof _ExsurgeChant.TextOnly);
	              });
	              leftPoint = _prev ? _prev.bounds.right() : 0;
	            }
	            if (leftPoint) {
	              curr.bounds.x = (leftPoint + rightPoint - barWidth) / 2;
	            }
	            if (curr.hasLyrics()) {
	              var offset = oldBoundsX - curr.bounds.x;
	              for (j = curr.lyrics.length - 1; j >= 0; j--) {
	                curr.lyrics[j].bounds.x += offset;
	                curr.lyrics[j].needsLayout = true;
	              }
	            }
	          } else if (i === lastIndex - 1 && this.justify && (curr.constructor === _ExsurgeChantSigns.DoubleBar || curr.constructor === _ExsurgeChantSigns.FullBar)) {
	            curr.bounds.x = this.staffRight - curr.bounds.width;
	          }
	        }
	      }
	    }
	  }, {
	    key: \"findNeumesToJustify\",
	    value: function findNeumesToJustify(prevLyrics) {
	      this.toJustify = [];
	      var prev,
	          curr = null,
	          next = null,
	          nextOrCurr = null,
	          lastIndex = this.notationsStartIndex + this.numNotationsOnLine;
	      for (var i = this.notationsStartIndex; i < lastIndex; i++) {
	        prev = nextOrCurr;
	        curr = this.score.notations[i];
	        next = curr.isAccidental && this.score.notations[++i];
	        nextOrCurr = next || curr;
	        var hasLyrics = nextOrCurr.hasLyrics();
	
	        if (!curr || !prev) continue;
	
	        if (this.extraTextOnlyIndex !== null && i >= this.extraTextOnlyIndex && curr.constructor === _ExsurgeChant.TextOnly) continue;
	
	        if (prev !== null) {
	          _ExsurgeDrawing.LyricArray.mergeIn(prevLyrics, prev.lyrics);
	          if (prev.keepWithNext === true) continue;
	        }
	
	        if (!curr.isDivider && prevLyrics.length && prevLyrics[0].allowsConnector() && hasLyrics) continue;
	
	        if (nextOrCurr.constructor === _ExsurgeChant.ChantLineBreak) continue;
	
	        if (nextOrCurr === this.custos && !hasLyrics) continue;
	
	        if (i === 0 && this.score.useDropCap && hasLyrics) continue;
	
	        // otherwise, we can add space before this element
	        this.toJustify.push(curr);
	      }
	      if (nextOrCurr !== null) _ExsurgeDrawing.LyricArray.mergeIn(prevLyrics, nextOrCurr.lyrics);
	      return nextOrCurr;
	    }
	  }, {
	    key: \"getWhitespaceOnRight\",
	    value: function getWhitespaceOnRight(ctxt) {
	      var notations = this.score.notations;
	      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;
	      var last = notations[lastIndex - 1];
	      if (this.extraTextOnlyIndex !== null && last.constructor === _ExsurgeChant.TextOnly) {
	        lastIndex = this.extraTextOnlyIndex;
	        last = notations[lastIndex - 1];
	      }
	      var lastRightNeume = last ? last.bounds.right() + last.calculatedTrailingSpace : 0;
	      var lastLyrics = this.lastLyricsBeforeTextOnly || this.lastLyrics;
	      var lastRightLyric = lastLyrics.length ? _ExsurgeDrawing.LyricArray.getRight(lastLyrics) : 0;
	
	      if (this.custos) {
	        lastRightNeume += this.custos.bounds.width + this.custos.leadingSpace;
	        if (this.custos.hasLyrics()) {
	          lastRightLyric = _ExsurgeDrawing.LyricArray.getRight(this.custos.lyrics);
	        }
	      } else if (ctxt && lastIndex < notations.length) {
	        lastRightNeume += _ExsurgeGlyphs.Glyphs.CustosLong.bounds.width * ctxt.glyphScaling;
	      }
	      return this.staffRight - Math.max(lastRightLyric, lastRightNeume);
	    }
	  }, {
	    key: \"justifyElements\",
	    value: function justifyElements(ctxt, doJustify, condensableSpaces) {
	      var i;
	      var toJustify = this.toJustify || [];
	      var notations = this.score.notations;
	      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;
	
	      // if it wasn't an ideal line break, and the last note is further from the custos than it would have been from its next punctum,
	      // move the custos over.
	      // We do this first so that if it opens up any new whitespace, that gets accounted for when we do the justification
	      var lastNotation = notations[this.notationsStartIndex + this.numNotationsOnLine - 1];
	      var extraSpaceBeforeCustos = this.staffRight < Infinity && this.custos && lastNotation.keepWithNext && this.custos.bounds.x - lastNotation.bounds.right() - lastNotation.calculatedTrailingSpace;
	      if (extraSpaceBeforeCustos > 0) {
	        // first, shrink the hyphen(s) if applicable, to move the neumes closer to the custos:
	        i = 0;
	        while (this.lastLyrics && this.lastLyrics[i]) {
	          var lyrics = this.lastLyrics[i];
	          if (lyrics.allowsConnector()) {
	            var connectorWidth = lyrics.getConnectorWidth();
	            if (ctxt.minLyricWordSpacing < connectorWidth) {
	              var minHyphenWidth = Math.max(connectorWidth - extraSpaceBeforeCustos, this.lastLyrics.length > 1 ? ctxt.intraNeumeSpacing : ctxt.minLyricWordSpacing);
	              // we might not need to shift the syllable, but we do want to shrink the hyphen...
	              lyrics.setConnectorWidth(minHyphenWidth);
	            }
	          }
	          ++i;
	        }
	        this.custos.bounds.x = lastNotation.bounds.right() + lastNotation.calculatedTrailingSpace;
	      }
	
	      // first step of justification is to determine how much space we have to use up
	      var extraSpace = this.getWhitespaceOnRight();
	
	      if (Math.abs(extraSpace) < 0.5 || extraSpace > 0 && (doJustify && toJustify.length === 0 || !doJustify)) return;
	
	      this.condensableSpaces = condensableSpaces;
	
	      var curr, prev;
	      var offset = 0;
	      var increment = extraSpace / toJustify.length;
	      var multiplier = 0;
	      var toJustifyIndex = 0;
	      if (extraSpace < 0) {
	        toJustify = condensableSpaces.filter(function (s) {
	          return s.condensable > 0;
	        });
	        multiplier = extraSpace / condensableSpaces.sum;
	        increment = 0;
	      }
	      var nextToJustify = toJustify[toJustifyIndex++];
	      var incrementOffsetAtNextChance = false;
	      for (i = this.notationsStartIndex; i < lastIndex; i++) {
	        prev = curr;
	        curr = notations[i];
	
	        if (this.extraTextOnlyIndex !== null && i >= this.extraTextOnlyIndex && curr.constructor === _ExsurgeChant.TextOnly) {
	          continue;
	        }
	
	        if (!multiplier && curr === this.custos) {
	          if (curr.hasLyrics()) {
	            curr.bounds.x = Math.min(curr.bounds.x + (this.staffRight - _ExsurgeDrawing.LyricArray.getRight(curr.lyrics)), this.staffRight - curr.bounds.width);
	            offset += increment;
	          } else {
	            curr.bounds.x = Math.min(curr.bounds.x + offset, this.staffRight - curr.bounds.width);
	          }
	          continue;
	        }
	
	        if (multiplier) {
	          if (nextToJustify && nextToJustify.notation === curr) {
	            offset += multiplier * nextToJustify.condensable;
	            nextToJustify = toJustify[toJustifyIndex++];
	          }
	        } else if (nextToJustify === curr) {
	          if (prev.hasNoWidth) {
	            incrementOffsetAtNextChance = true;
	          } else {
	            offset += increment;
	          }
	          nextToJustify = toJustify[toJustifyIndex++];
	        } else if (incrementOffsetAtNextChance && !prev.hasNoWidth) {
	          incrementOffsetAtNextChance = false;
	          offset += increment;
	        }
	
	        curr.bounds.x += offset;
	      }
	
	      if (extraSpaceBeforeCustos > 0) {
	        this.custos.bounds.x = lastNotation.bounds.right() + lastNotation.calculatedTrailingSpace;
	      }
	    }
	  }, {
	    key: \"handleEndBrace\",
	    value: function handleEndBrace(ctxt, note, i) {
	      var startBrace = ctxt.lastStartBrace;
	      if (!startBrace) return;
	      // calculate the y value of the brace by iterating over all notations
	      // under/over the brace.
	      var y;
	      var k = startBrace.notationIndex;
	      var notations = this.score.notations;
	      var dy = ctxt.intraNeumeSpacing / 2; // some safe space between brace and notes.
	      var startNote = startBrace.note;
	
	      if (startBrace.isAbove) {
	        y = Math.min.apply(Math, [ctxt.calculateHeightFromStaffPosition(4)].concat(_toConsumableArray([startNote, note].concat(notations.slice(k, i + 1)).map(function (n) {
	          return n.bounds.y - dy;
	        }))));
	      } else {
	        y = Math.max.apply(Math, [ctxt.calculateHeightFromStaffPosition(-4)].concat(_toConsumableArray([startNote, note].concat(notations.slice(k, i + 1)).map(function (n) {
	          return n.bounds.bottom() + dy;
	        }))));
	      }
	
	      var addAcuteAccent = false;
	
	      if (startBrace.shape === _ExsurgeChantMarkings.BraceShape.RoundBrace) {
	        this.braces.push(new _ExsurgeDrawing.RoundBraceVisualizer(ctxt, startBrace.getAttachmentX(startNote), note.braceEnd.getAttachmentX(note), y, startBrace.isAbove));
	      } else {
	        if (startBrace.shape === _ExsurgeChantMarkings.BraceShape.AccentedCurlyBrace) addAcuteAccent = true;
	
	        this.braces.push(new _ExsurgeDrawing.CurlyBraceVisualizer(ctxt, startBrace.getAttachmentX(startNote), note.braceEnd.getAttachmentX(note), y, startBrace.isAbove, addAcuteAccent));
	      }
	
	      delete ctxt.lastStartBrace;
	    }
	  }, {
	    key: \"finishLayout\",
	    value: function finishLayout(ctxt) {
	      var _this2 = this;
	
	      this.ledgerLines = []; // clear any existing ledger lines
	
	      var notations = this.score.notations;
	      var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;
	
	      // an element needs to have a staffPosition property, as well as the standard
	      // bounds property. so it could be a note, or it could be a custos
	      // offsetX can be used to add to the position info for the element,
	      // useful in the case of notes.
	      var processElementForLedgerLine = function processElementForLedgerLine(element) {
	        var endElem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : element;
	        var staffPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : element.staffPosition;
	        var offsetX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : element.neume ? element.neume.bounds.x : 0;
	
	        // do we need a ledger line for this note?
	
	        if (staffPosition >= 5 || staffPosition <= -5) {
	          var x1 = offsetX + element.bounds.x - ctxt.intraNeumeSpacing;
	          var x2 = offsetX + endElem.bounds.x + endElem.bounds.width + ctxt.intraNeumeSpacing;
	
	          // round the staffPosition to the nearest line
	          if (staffPosition > 0) staffPosition = staffPosition - (staffPosition - 1) % 2;else staffPosition = staffPosition - (staffPosition + 1) % 2;
	
	          // if we have a ledger line close by, then average out the distance between the two
	          var minLedgerSeparation = ctxt.staffInterval * ctxt.minLedgerSeparation;
	
	          if (_this2.ledgerLines.length > 0 && _this2.ledgerLines[_this2.ledgerLines.length - 1].x2 + minLedgerSeparation >= x1) {
	            // average out the distance
	            var half = (x1 - _this2.ledgerLines[_this2.ledgerLines.length - 1].x2) / 2;
	            _this2.ledgerLines[_this2.ledgerLines.length - 1].x2 += half;
	            x1 -= half;
	          }
	
	          // never let a ledger line extend past the staff width
	          if (x2 > _this2.staffRight) x2 = _this2.staffRight;
	
	          // finally, add the ledger line
	          _this2.ledgerLines.push({
	            x1: x1,
	            x2: x2,
	            staffPosition: staffPosition
	          });
	        }
	      };
	
	      var episemata = []; // keep track of episemata in case we can connect some
	      var startBrace = null;
	      var minY = Number.MAX_VALUE,
	          maxY = Number.MIN_VALUE; // for braces
	
	      var positionNonLyricText = function positionNonLyricText(text, neume, rightX) {
	        text.setMaxWidth(ctxt, _this2.staffRight);
	        //text.bounds.x = neume.hasLyrics()? Math.min(...neume.lyrics.map(l => l.bounds.x)) : 0;
	        text.bounds.x = 0;
	        if (rightX) text.bounds.x = (text.bounds.x + rightX - text.bounds.width) / 2;
	        var beyondStaffRight = neume.bounds.x + text.bounds.right() - _this2.staffRight;
	        if (beyondStaffRight > 0) {
	          text.bounds.x -= beyondStaffRight;
	        }
	        if (neume.bounds.x + text.bounds.x < 0) {
	          text.bounds.x = -neume.bounds.x;
	        }
	      };
	
	      // make a final pass over all of the notes to add any necessary
	      // ledger lines and to smooth out episemata
	      for (var i = this.notationsStartIndex; i < lastIndex; i++) {
	        var neume = notations[i];
	
	        minY = Math.min(minY, neume.bounds.y);
	        maxY = Math.max(maxY, neume.bounds.bottom());
	
	        if (neume.constructor === _ExsurgeChantSigns.Custos) {
	          processElementForLedgerLine(neume);
	          continue;
	        }
	
	        // if the AboveLinesText would extend beyond the right edge of the staff, right align it instead
	        if (neume.alText) {
	          for (var j = 0; j < neume.alText.length; j++) {
	            positionNonLyricText(neume.alText[j], neume);
	          }
	        }
	
	        // set up horizontal position of translations
	        if (neume.translationText) {
	          for (j = 0; j < neume.translationText.length; j++) {
	            var text = neume.translationText[j];
	            if (text.endNeume) {
	              var rightX = text.endNeume.hasLyrics() ? text.endNeume.bounds.x + Math.max.apply(Math, _toConsumableArray(text.endNeume.lyrics.map(function (l) {
	                return l.bounds.right();
	              }))) : text.endNeume.bounds.right();
	              rightX -= neume.bounds.x;
	              positionNonLyricText(text, neume, rightX);
	            } else {
	              positionNonLyricText(text, neume);
	            }
	          }
	        }
	
	        // if it's not a neume then just skip here
	        if (!neume.isNeume) continue;
	
	        for (j = 0; j < neume.ledgerLines.length; j++) {
	          var ll = neume.ledgerLines[j];
	          processElementForLedgerLine(ll.element, ll.endElem, ll.staffPosition);
	        }
	
	        for (j = 0; j < neume.notes.length; j++) {
	          var k,
	              note = neume.notes[j];
	
	          // blend episemata as we're able
	          if (note.episemata.length === 0) episemata = [];
	          for (k = 0; k < note.episemata.length; k++) {
	            var episema = note.episemata[k];
	
	            var spaceBetweenEpisemata = 0;
	
	            // calculate the distance between the last episemata and this one...
	            // lots of code for a simple: currEpisemata.left - prevEpisemata.right
	            if (episemata.length > 0) spaceBetweenEpisemata = neume.bounds.x + episema.bounds.x - (episemata[episemata.length - 1].note.neume.bounds.x + episemata[episemata.length - 1].bounds.right());
	
	            // we try to blend the episema if we're able.
	            if (episemata.length === 0 || episemata[episemata.length - 1].positionHint !== episema.positionHint || episemata[episemata.length - 1].terminating === true || episemata[episemata.length - 1].alignment === _ExsurgeChantMarkings.HorizontalEpisemaAlignment.Left || episemata[episemata.length - 1].alignment === _ExsurgeChantMarkings.HorizontalEpisemaAlignment.Center || episema.alignment === _ExsurgeChantMarkings.HorizontalEpisemaAlignment.Right || episema.alignment === _ExsurgeChantMarkings.HorizontalEpisemaAlignment.Center || spaceBetweenEpisemata > ctxt.intraNeumeSpacing * 2 && note.glyphVisualizer.glyphCode !== _ExsurgeDrawing.GlyphCode.None) {
	              // start a new set of episemata to potentially blend
	              episemata = [episema];
	            } else {
	              // blend all previous with this one
	              var newY;
	
	              if (episema.positionHint === _ExsurgeDrawing.MarkingPositionHint.Below) newY = Math.max(episema.bounds.y, episemata[episemata.length - 1].bounds.y);else newY = Math.min(episema.bounds.y, episemata[episemata.length - 1].bounds.y);
	
	              if (episema.bounds.y !== newY) episema.bounds.y = newY;else {
	                for (var l = 0; l < episemata.length; l++) {
	                  episemata[l].bounds.y = newY;
	                }
	              }
	
	              // extend the last episema to meet the new one
	              var newWidth = neume.bounds.x + episema.bounds.x - (episemata[episemata.length - 1].note.neume.bounds.x + episemata[episemata.length - 1].bounds.x);
	              if (newWidth < 0) {
	                newWidth *= -1;
	                episemata[episemata.length - 1].bounds.x -= newWidth;
	              }
	              episemata[episemata.length - 1].bounds.width = newWidth;
	
	              episemata.push(episema);
	            }
	          }
	
	          if (note.braceEnd) this.handleEndBrace(ctxt, note, i);
	
	          if (note.braceStart) {
	            ctxt.lastStartBrace = startBrace = note.braceStart;
	            startBrace.notationIndex = i;
	          }
	        }
	      }
	
	      // if we still have an active brace, that means it spands two chant lines!
	      if (startBrace !== null) {
	        if (this.custos) {
	          // if the next end brace is on the first note following the line break, simply use it with the custos
	          // Do the same if there is only an accidental between
	          // otherwise, make a new end brace to work for this one, and a new start brace for the next line.
	          var nextNotation = notations[lastIndex];
	          var nextNote = nextNotation.notes && nextNotation.notes[0];
	          var nextNotationButOne = notations[lastIndex + 1];
	          var nextNoteButOne = nextNotationButOne && nextNotationButOne.notes && nextNotationButOne.notes[0];
	          var braceEnd = nextNote && nextNote.braceEnd || nextNotation.isAccidental && nextNoteButOne && nextNoteButOne.braceEnd;
	          if (braceEnd) {
	            this.custos.braceEnd = braceEnd;
	            this.handleEndBrace(ctxt, this.custos, i);
	          } else {
	            this.braceStart = startBrace;
	            this.custos.braceEnd = new _ExsurgeChantMarkings.BracePoint(this.custos, startBrace.isAbove, startBrace.shape, _ExsurgeChantMarkings.BraceAttachment.Right);
	            this.handleEndBrace(ctxt, this.custos, i - 1);
	            ctxt.lastStartBrace = new _ExsurgeChantMarkings.BracePoint(null, startBrace.isAbove, startBrace.shape, _ExsurgeChantMarkings.BraceAttachment.Left);
	            ctxt.lastStartBrace.notationIndex = i;
	          }
	        }
	      }
	
	      // don't forget to also include the final custos, which may need a ledger line too
	      if (this.custos) processElementForLedgerLine(this.custos);
	    }
	
	    // this is where the real core of positioning neumes takes place
	    // returns true if positioning was able to fit the neume before rightNotationBoundary.
	    // returns false if cannot fit before given right margin.
	    // fixme: if this returns false, shouldn't we set the connectors on prev to be activated?!
	
	  }, {
	    key: \"positionNotationElement\",
	    value: function positionNotationElement(ctxt, prevLyrics, prev, curr, rightNotationBoundary) {
	      var condensableSpaces = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
	
	      if (!condensableSpaces.hasOwnProperty(\"sum\")) condensableSpaces.sum = 0;
	      var i,
	          space = { notation: curr },
	          fixedX = false;
	
	      // To begin we just place the current notation right after the previous,
	      // irrespective of lyrics.
	      // But if the previous neume was part of a polyphonic \"no width\" group and the current is not, or is of a separate group,
	      // we force it to have the same x as the previous group.
	      if ((!curr.hasNoWidth || curr.firstWithNoWidth === curr) && prev.firstWithNoWidth) {
	        curr.bounds.x = prev.firstWithNoWidth.bounds.x;
	        fixedX = true;
	      } else {
	        curr.bounds.x = prev.bounds.right();
	      }
	
	      if (curr.constructor === _ExsurgeChant.TextOnly && this.extraTextOnlyIndex === null || !curr.hasLyrics() && prev.calculatedTrailingSpace < 0) {
	        // We transfer over the trailing space from the previous neume if the current neume is text only,
	        // so that the text only neume has a better chance at not needing a connector.
	        curr.calculatedTrailingSpace = prev.calculatedTrailingSpace;
	        if (curr.hasLyrics()) curr.calculatedTrailingSpace -= curr.lyrics[0].bounds.width;
	        if (curr.constructor === _ExsurgeChant.TextOnly && curr.lyrics.length === 1) {
	          curr.lyrics[0].setMaxWidth(ctxt, this.staffRight, this.staffRight - _ExsurgeDrawing.LyricArray.getRight(prevLyrics) - ctxt.minLyricWordSpacing);
	        }
	      } else if (!fixedX) {
	        curr.bounds.x += prev.calculatedTrailingSpace;
	      }
	
	      if (curr.hasLyrics() && !prev.isDivider && !prev.isAccidental && this.numNotationsOnLine > 0 && (curr.lyrics[0].lyricType === _ExsurgeDrawing.LyricType.SingleSyllable || curr.lyrics[0].lyricType === _ExsurgeDrawing.LyricType.BeginningSyllable)) {
	        curr.bounds.x += ctxt.intraNeumeSpacing * ctxt.interVerbalMultiplier;
	      }
	      if (curr.hasNoWidth || fixedX) {
	        space.total = space.condensable = 0;
	      } else if (this.extraTextOnlyIndex !== null && curr.constructor === _ExsurgeChant.TextOnly) {
	        curr.bounds.x = 0;
	        space.total = space.condensable = 0;
	      } else {
	        space.total = curr.bounds.x - prev.bounds.right();
	        space.condensable = space.total * ctxt.condensingTolerance;
	      }
	
	      // if the previous notation has no lyrics, then we simply make sure the
	      // current notation with lyrics is in the bounds of the line
	      if (prevLyrics.length === 0) {
	        var maxRight = curr.bounds.right() + curr.calculatedTrailingSpace;
	
	        // if the lyric left is negative, then offset the neume appropriately
	        for (i = 0; i < curr.lyrics.length; i++) {
	          var currLyric = curr.lyrics[i];
	          // we hope for the best!
	          // but always use a connector if the lyric has original text that was all used up for the drop cap.
	          var needsConnector = currLyric.allowsConnector() && currLyric.dropCap && currLyric.originalText && !currLyric.text;
	          currLyric.setNeedsConnector(needsConnector);
	          var minLeft = this.staffLeft - this.paddingLeft;
	
	          if (currLyric.getLeft() < minLeft) curr.bounds.x -= currLyric.getLeft() - minLeft;
	
	          space.condensable = Math.min(space.condensable, currLyric.getLeft() - minLeft);
	          maxRight = Math.max(maxRight, currLyric.getRight());
	        }
	
	        if (maxRight > rightNotationBoundary + condensableSpaces.sum + space.condensable) return false;
	        condensableSpaces.push(space);
	        condensableSpaces.sum += space.condensable;
	        return true;
	      } else {
	        if (curr.firstOfSyllable && prevLyrics.length && !curr.hasLyrics()) {
	          curr.bounds.x = Math.max(curr.bounds.x, prevLyrics[0].getRight());
	          space.total = curr.bounds.x - prev.bounds.right();
	          space.condensable = space.total * ctxt.condensingTolerance;
	        }
	      }
	
	      // if the curr notation has no lyrics, then simply check whether there is enough room
	      if (curr.hasLyrics() === false) {
	        if (curr.bounds.right() + curr.calculatedTrailingSpace > rightNotationBoundary + condensableSpaces.sum + space.condensable) return false;
	        condensableSpaces.push(space);
	        condensableSpaces.sum += space.condensable;
	        return true;
	      }
	
	      // if we have multiple lyrics on the current or the previous notation,
	      // we will have to run several passes over each set of lyrics:
	
	      // on the first pass, we will check the absolute left-most placement of the new syllables
	      // we will make additional passes until everything is stable
	      do {
	        var hasShifted = false;
	        var atLeastOneWithoutConnector = false;
	        for (i = 0; i < curr.lyrics.length; i++) {
	          if (!curr.lyrics[i].originalText) continue;
	          var prevLyricRight = 0;
	          var condensableSpacesSincePrevLyric = [];
	          var condensableSpaceSincePrevLyric = null;
	          if (i < prevLyrics.length && prevLyrics[i]) {
	            prevLyricRight = prevLyrics[i].getRight();
	            var notationI = condensableSpaces.map(function (s) {
	              return s.notation;
	            }).lastIndexOf(prevLyrics[i].notation);
	            if (notationI >= 0) {
	              condensableSpacesSincePrevLyric = condensableSpaces.slice(notationI + 1);
	              condensableSpacesSincePrevLyric.sum = condensableSpacesSincePrevLyric.map(function (s) {
	                return s.condensable;
	              }).reduce(function (a, b) {
	                return a + b;
	              }, 0);
	            } else {
	              condensableSpacesSincePrevLyric.sum = 0;
	            }
	          }
	
	          curr.lyrics[i].setNeedsConnector(false); // we hope for the best!
	          var currLyricLeft = curr.lyrics[i].getLeft();
	          if (!prevLyrics[i] || prevLyrics[i].allowsConnector() === false) {
	            // No connector needed, but include space between words if necessary!
	            var extraSpace = currLyricLeft - prevLyricRight - ctxt.minLyricWordSpacing;
	            if (extraSpace < 0) {
	              // push the current element over a bit.
	              var shift = prevLyricRight + ctxt.minLyricWordSpacing - currLyricLeft;
	              curr.bounds.x += shift;
	              condensableSpaceSincePrevLyric = 0;
	              hasShifted = shift > 0.5;
	            } else {
	              condensableSpaceSincePrevLyric = extraSpace;
	            }
	          } else {
	            // we may need a connector yet...
	            if (prevLyricRight + 0.1 > currLyricLeft - condensableSpacesSincePrevLyric.sum - space.condensable) {
	              // in this case, the lyric elements actually overlap.
	              // so nope, no connector needed. instead, we just place the lyrics together
	              // fixme: for better text layout, we could actually use the kerning values
	              // between the prev and curr lyric elements!
	              var _shift = prevLyricRight - currLyricLeft;
	              if (_shift < -0.1) {
	                (function () {
	                  // in this case, the spacing needs to be condensed in the neumes since the last lyric...
	                  var multiplier = _shift / (condensableSpacesSincePrevLyric.sum + space.condensable);
	                  var offset = 0;
	                  condensableSpacesSincePrevLyric.forEach(function (s) {
	                    offset += multiplier * s.condensable;
	                    s.notation.bounds.x += offset;
	                  });
	                })();
	              }
	              curr.bounds.x += _shift;
	              condensableSpaceSincePrevLyric = 0;
	              atLeastOneWithoutConnector = true;
	              hasShifted = _shift > 0.5;
	            } else {
	              // bummer, looks like we couldn't merge the syllables together. Better add a connector...
	              if (ctxt.minLyricWordSpacing < ctxt.hyphenWidth) {
	                var spaceBetweenSyls = currLyricLeft - prevLyricRight;
	                if (spaceBetweenSyls < ctxt.hyphenWidth) {
	                  var minHyphenWidth = prevLyrics.length > 1 ? ctxt.intraNeumeSpacing : ctxt.minLyricWordSpacing;
	                  // we might not need to shift the syllable, but we do want to shrink the hyphen...
	                  prevLyrics[i].setConnectorWidth(Math.max(minHyphenWidth, spaceBetweenSyls));
	                }
	              }
	              prevLyrics[i].setNeedsConnector(true);
	              prevLyricRight = prevLyrics[i].getRight();
	
	              if (prevLyricRight + 0.1 > currLyricLeft) {
	                var _shift2 = prevLyricRight - currLyricLeft;
	                curr.bounds.x += _shift2;
	                condensableSpaceSincePrevLyric = 0;
	                hasShifted = _shift2 > 0.5;
	              } else {
	                condensableSpaceSincePrevLyric = currLyricLeft - prevLyricRight;
	              }
	            }
	          }
	
	          if (condensableSpaceSincePrevLyric !== null) {
	            if (condensableSpaceSincePrevLyric < condensableSpacesSincePrevLyric.sum + space.condensable) {
	              (function () {
	                // reduce condensable space so that lyrics retain at least the width of a space character between words:
	                var multiplier = condensableSpaceSincePrevLyric / (condensableSpacesSincePrevLyric.sum + space.condensable);
	                space.condensable *= multiplier;
	                if (condensableSpacesSincePrevLyric.sum) {
	                  condensableSpacesSincePrevLyric.forEach(function (space) {
	                    space.condensable *= multiplier;
	                  });
	                  condensableSpaces.sum = condensableSpaces.map(function (s) {
	                    return s.condensable;
	                  }).reduce(function (a, b) {
	                    return a + b;
	                  }, 0);
	                }
	              })();
	            }
	          }
	        }
	      } while (curr.lyrics.length > 1 && hasShifted && atLeastOneWithoutConnector);
	
	      for (i = Math.min(curr.lyrics.length, prevLyrics.length) - 1; i >= 0; i--) {
	        var pLyrics = prevLyrics[i];
	        if (pLyrics.needsConnector && pLyrics.connectorWidth) {
	          currLyricLeft = curr.lyrics[i].getLeft();
	          prevLyricRight = pLyrics.getRight() - pLyrics.connectorWidth;
	          spaceBetweenSyls = currLyricLeft - prevLyricRight;
	          if (spaceBetweenSyls >= ctxt.hyphenWidth) spaceBetweenSyls = 0;
	          pLyrics.setConnectorWidth(spaceBetweenSyls);
	        }
	      }
	
	      if (curr.bounds.right() + curr.calculatedTrailingSpace < rightNotationBoundary + condensableSpaces.sum + space.condensable && _ExsurgeDrawing.LyricArray.getRight(curr.lyrics, true) <= this.staffRight + condensableSpaces.sum + space.condensable) {
	        if (prev.isAccidental) {
	          // move the previous accidental up next to the current note:
	          var _shift3 = curr.bounds.x - prev.bounds.width - prev.calculatedTrailingSpace - prev.bounds.x;
	          prev.bounds.x += _shift3;
	          if (Math.abs(_shift3) > 0.1) {
	            var lastCondensable = condensableSpaces[condensableSpaces.length - 1];
	            condensableSpaces.sum -= lastCondensable.condensable;
	            lastCondensable.condensable = 0;
	          }
	        }
	        condensableSpaces.push(space);
	        condensableSpaces.sum += space.condensable;
	        return true;
	      }
	
	      // if we made it this far, then the element won't fit on this line.
	      return false;
	    }
	
	    /**
	     * Find the notation closest to x without going past it
	     * @param {number} x
	     */
	
	  }, {
	    key: \"bisectNotationAtX\",
	    value: function bisectNotationAtX(x) {
	      var useMidpoint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	      var minIndex = -1,
	          maxIndex = Math.min(this.numNotationsOnLine, Infinity),
	          curIndex = minIndex + (maxIndex - minIndex >> 1),
	          notations = this.score.notations.slice(this.notationsStartIndex, this.notationsStartIndex + this.numNotationsOnLine);
	
	      while (minIndex < curIndex) {
	        var _notation = notations[curIndex];
	        var notationX = _notation.bounds.x;
	        if (notationX > x) {
	          maxIndex = curIndex;
	        } else {
	          minIndex = curIndex;
	        }
	        curIndex = minIndex + (maxIndex - minIndex >> 1);
	      }
	      var notation = notations[curIndex];
	      if (useMidpoint && notation && notation.bounds.width === 0 && curIndex + 1 < notations.length) {
	        var nextNotation = notations[curIndex + 1],
	            closenessToLeft = x - notation.bounds.x,
	            closenessToRight = nextNotation.bounds.x - x;
	        if (nextNotation.bounds.width === 0 && closenessToRight < closenessToLeft) ++curIndex;
	      }
	      return notations[curIndex];
	    }
	  }]);
	
	  return ChantLine;
	}(_ExsurgeDrawing.ChantLayoutElement);

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	exports.BracePoint = exports.BraceAttachment = exports.BraceShape = exports.Mora = exports.Ictus = exports.HorizontalEpisema = exports.HorizontalEpisemaAlignment = exports.Accent = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ExsurgeChant = __webpack_require__(8);
	
	var _ExsurgeDrawing = __webpack_require__(4);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //
	// Author(s):
	// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
	//
	// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the \"Software\"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	//
	
	var Accent = exports.Accent = function (_GlyphVisualizer) {
	  _inherits(Accent, _GlyphVisualizer);
	
	  function Accent(ctxt, note) {
	    var glyphCode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _ExsurgeDrawing.GlyphCode.AcuteAccent;
	
	    _classCallCheck(this, Accent);
	
	    var _this = _possibleConstructorReturn(this, (Accent.__proto__ || Object.getPrototypeOf(Accent)).call(this, ctxt, glyphCode));
	
	    _this.note = note;
	    _this.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;
	    return _this;
	  }
	
	  _createClass(Accent, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      this.bounds.x = this.note.bounds.x + this.bounds.width / 2; // center on the note itself
	
	      // this puts the acute accent either over the staff lines, or over the note if the
	      // note is above the staff lines
	      this.setStaffPosition(ctxt, Math.max(this.note.staffPosition + 1, 4));
	    }
	  }]);
	
	  return Accent;
	}(_ExsurgeDrawing.GlyphVisualizer);
	
	// for positioning markings on notes
	
	
	var HorizontalEpisemaAlignment = exports.HorizontalEpisemaAlignment = {
	  Default: 0,
	  Left: 1,
	  Center: 2,
	  Right: 3
	};
	
	/*
	 * HorizontalEpisema
	 *
	 * A horizontal episema marking is it's own visualizer (that is, it implements createSvgFragment)
	 */
	
	var HorizontalEpisema = exports.HorizontalEpisema = function (_ChantLayoutElement) {
	  _inherits(HorizontalEpisema, _ChantLayoutElement);
	
	  function HorizontalEpisema(note) {
	    _classCallCheck(this, HorizontalEpisema);
	
	    var _this2 = _possibleConstructorReturn(this, (HorizontalEpisema.__proto__ || Object.getPrototypeOf(HorizontalEpisema)).call(this));
	
	    _this2.note = note;
	
	    _this2.positionHint = _ExsurgeDrawing.MarkingPositionHint.Default;
	    _this2.terminating = false; // indicates if this episema should terminate itself or not
	    _this2.alignment = HorizontalEpisemaAlignment.Default;
	    return _this2;
	  }
	
	  _createClass(HorizontalEpisema, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      // following logic helps to keep the episemata away from staff lines if they get too close
	
	      var y = 0,
	          step;
	      var minDistanceAway = ctxt.staffInterval * 0.25; // min distance from neume
	      var glyphCode = this.note.glyphVisualizer.glyphCode;
	      var ledgerLine = this.note.neume.ledgerLines[0] || {};
	      var punctumInclinatumShorten = false;
	
	      if (glyphCode === _ExsurgeDrawing.GlyphCode.PunctumInclinatum) {
	        var notes = this.note.neume.notes,
	            index = notes.indexOf(this.note),
	            prevNote = notes[index - 1];
	        if (prevNote && prevNote.glyphVisualizer.glyphCode === _ExsurgeDrawing.GlyphCode.PunctumInclinatum && prevNote.staffPosition - this.note.staffPosition === 1) {
	          punctumInclinatumShorten = true;
	        }
	      }
	
	      if (this.positionHint === _ExsurgeDrawing.MarkingPositionHint.Below) {
	        y = this.note.bounds.bottom() + minDistanceAway; // the highest the line could be at
	        if (glyphCode === _ExsurgeDrawing.GlyphCode.None)
	          // correction for episema under the second note of a porrectus
	          y += ctxt.staffInterval / 2;
	        step = Math.ceil(y / ctxt.staffInterval);
	        // if there's enough space, center the episema between the punctum and the next staff line
	        if (step % 2 === 0) {
	          step = (step + 3 / 4 + (y - minDistanceAway) / ctxt.staffInterval) / 2;
	        } else {
	          // otherwise, find nearest acceptable third between staff lines (or staff line)
	          step = (Math.ceil(1.5 * y / ctxt.staffInterval - 0.5) * 2 + 1) / 3;
	
	          // if it's an odd step, that means we're on a staff line,
	          // so we shift to between the staff line
	          if (Math.abs(step) % 2 === 1) {
	            if (Math.abs(step) < 4 || ledgerLine.staffPosition === -step) {
	              step += 2 / 3;
	            } else {
	              // no ledger line, but we don't want the episema to be at exactly the same height the ledger line would occupy:
	              step += 1 / 3;
	            }
	          }
	        }
	      } else {
	        y = this.note.bounds.y - minDistanceAway; // the lowest the line could be at
	        step = Math.floor(y / ctxt.staffInterval);
	        // if there's enough space, center the episema between the punctum and the next staff line
	        if (step % 2 === 0) {
	          step = (step - 3 / 4 + (y + minDistanceAway) / ctxt.staffInterval) / 2;
	        } else {
	          // otherwise, find nearest acceptable third between staff lines (or staff line)
	          step = (Math.floor(1.5 * y / ctxt.staffInterval - 0.5) * 2 + 1) / 3;
	
	          // find nearest acceptable third between staff lines (or staff line)
	          if (Math.abs(step) % 2 === 1) {
	            // if it was a staff line, we need to adjust
	            if (Math.abs(step) < 4 || ledgerLine.staffPosition === -step) {
	              step -= 2 / 3;
	            } else {
	              // no ledger line, but we don't want the episema to be at exactly the same height the ledger line would occupy:
	              step -= 1 / 3;
	            }
	          }
	        }
	      }
	
	      y = step * ctxt.staffInterval;
	
	      var width = this.note.bounds.width;
	      var x = this.note.bounds.x;
	
	      // The porrectus requires special handling of the note width,
	      // otherwise the width is just that of the note itself
	      if (glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus1 || glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus2 || glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus3 || glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus4) width = ctxt.staffInterval;else if (glyphCode === _ExsurgeDrawing.GlyphCode.None) {
	        width = ctxt.staffInterval;
	        x -= width;
	      } else if (punctumInclinatumShorten) {
	        width *= 2 / 3;
	        x += 0.5 * width;
	      } else if (glyphCode === _ExsurgeDrawing.GlyphCode.PunctumInclinatumLiquescent) {
	        width *= 2 / 3;
	        x += 0.25 * width;
	      }
	
	      // also, the position hint can affect the x/width of the episema
	      if (this.alignment === HorizontalEpisemaAlignment.Left) {
	        width *= 0.8;
	      } else if (this.alignment === HorizontalEpisemaAlignment.Center) {
	        x += width * 0.1;
	        width *= 0.8;
	      } else if (this.alignment === HorizontalEpisemaAlignment.Right) {
	        x += width * 0.2;
	        width *= 0.8;
	      }
	
	      this.bounds.x = x;
	      this.bounds.y = y - ctxt.episemaLineWeight / 2;
	      this.bounds.width = width;
	      this.bounds.height = ctxt.episemaLineWeight;
	
	      this.origin.x = 0;
	      this.origin.y = 0;
	    }
	  }, {
	    key: \"draw\",
	    value: function draw(ctxt) {
	      var canvasCtxt = ctxt.canvasCtxt;
	
	      canvasCtxt.fillStyle = ctxt.neumeLineColor;
	
	      canvasCtxt.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
	    }
	  }, {
	    key: \"getSvgProps\",
	    value: function getSvgProps(ctxt) {
	      return {
	        x: this.bounds.x,
	        y: this.bounds.y,
	        width: this.bounds.width,
	        height: this.bounds.height,
	        fill: ctxt.neumeLineColor,
	        class: \"horizontalEpisema\"
	      };
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      return _ExsurgeDrawing.QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt) {
	      return _ExsurgeDrawing.QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      return _ExsurgeDrawing.QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));
	    }
	  }]);
	
	  return HorizontalEpisema;
	}(_ExsurgeDrawing.ChantLayoutElement);
	
	/*
	 * Ictus
	 */
	
	
	var Ictus = exports.Ictus = function (_GlyphVisualizer2) {
	  _inherits(Ictus, _GlyphVisualizer2);
	
	  function Ictus(ctxt, note) {
	    _classCallCheck(this, Ictus);
	
	    var _this3 = _possibleConstructorReturn(this, (Ictus.__proto__ || Object.getPrototypeOf(Ictus)).call(this, ctxt, _ExsurgeDrawing.GlyphCode.VerticalEpisemaAbove));
	
	    _this3.note = note;
	    _this3.positionHint = _ExsurgeDrawing.MarkingPositionHint.Default;
	    return _this3;
	  }
	
	  _createClass(Ictus, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      var glyphCode = this.note.glyphVisualizer.glyphCode;
	      // we have to place the ictus further from the note in some cases to avoid a collision with an episema on the same note:
	      var positionHint = this.positionHint || _ExsurgeDrawing.MarkingPositionHint.Below;
	      var staffPosition = this.note.staffPosition + (positionHint === _ExsurgeDrawing.MarkingPositionHint.Above ? 1 : -1);
	      var collisionWithEpisema = this.note.episemata.length > 0 && (this.note.episemata[0].positionHint || _ExsurgeDrawing.MarkingPositionHint.Above) === positionHint;
	      var horizontalOffset;
	      var verticalOffset = 1;
	      var shortOffset = -0.2;
	      var extraOffset = 0;
	      var collisionWithStaffLine = staffPosition % 2 && (Math.abs(staffPosition) < 4 || (this.note.neume.ledgerLines[0] || {}).staffPosition === staffPosition);
	
	      // The porrectus requires special handling of the note width,
	      // otherwise the width is just that of the note itself
	      if (glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus1 || glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus2 || glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus3 || glyphCode === _ExsurgeDrawing.GlyphCode.Porrectus4) horizontalOffset = ctxt.staffInterval / 2;else if (glyphCode === _ExsurgeDrawing.GlyphCode.None) {
	        horizontalOffset = -ctxt.staffInterval / 2;
	      } else {
	        horizontalOffset = this.note.bounds.width / 2;
	        if (glyphCode === _ExsurgeDrawing.GlyphCode.PunctumInclinatum && !collisionWithStaffLine && !collisionWithEpisema) {
	          extraOffset = 0.3;
	        }
	      }
	
	      if (this.positionHint === _ExsurgeDrawing.MarkingPositionHint.Above) {
	        glyphCode = _ExsurgeDrawing.GlyphCode.VerticalEpisemaAbove;
	        verticalOffset *= -1;
	      } else {
	        glyphCode = _ExsurgeDrawing.GlyphCode.VerticalEpisemaBelow;
	      }
	      if (collisionWithEpisema) {
	        extraOffset = 0.4;
	      }
	      verticalOffset *= ctxt.staffInterval * (extraOffset + (collisionWithStaffLine ? 0.3 : shortOffset));
	
	      this.setGlyph(ctxt, glyphCode);
	      this.setStaffPosition(ctxt, staffPosition);
	
	      this.bounds.x = this.note.bounds.x + horizontalOffset - this.origin.x;
	      this.bounds.y += verticalOffset;
	    }
	  }]);
	
	  return Ictus;
	}(_ExsurgeDrawing.GlyphVisualizer);
	
	/*
	 * Mora
	 */
	
	
	var Mora = exports.Mora = function (_GlyphVisualizer3) {
	  _inherits(Mora, _GlyphVisualizer3);
	
	  function Mora(ctxt, note) {
	    _classCallCheck(this, Mora);
	
	    var _this4 = _possibleConstructorReturn(this, (Mora.__proto__ || Object.getPrototypeOf(Mora)).call(this, ctxt, _ExsurgeDrawing.GlyphCode.Mora));
	
	    _this4.note = note;
	    _this4.positionHint = _ExsurgeDrawing.MarkingPositionHint.Default;
	    _this4.horizontalOffset = ctxt.staffInterval / 2 + _this4.origin.x;
	    return _this4;
	  }
	
	  _createClass(Mora, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      this.setGlyph(ctxt, this.glyphCode);
	      this.horizontalOffset = ctxt.staffInterval / 2 + this.origin.x;
	      var staffPosition = this.note.staffPosition;
	
	      this.setStaffPosition(ctxt, staffPosition);
	
	      var verticalOffset = 0;
	      // First, we need to find the next note in the neume.
	      var noteIndex = this.note.neume.notes.indexOf(this.note);
	      var nextNote;
	      if (noteIndex >= 0) {
	        ++noteIndex;
	        if (this.note.neume.notes.length > noteIndex) {
	          nextNote = this.note.neume.notes[noteIndex];
	          if (nextNote.morae && nextNote.morae.length && this.note.neume.notes.length === noteIndex + 1) {
	            // this note is the second to last in its neume, and the last note also has a mora
	            this.horizontalOffset += nextNote.bounds.right() - this.note.bounds.right();
	          } else if (nextNote.bounds.right() > this.note.bounds.right()) {
	            // center the dot over the following note.
	            this.horizontalOffset = (nextNote.bounds.right() - this.note.bounds.right() - this.bounds.right()) / 2;
	          } else {
	            nextNote = null;
	          }
	        } else if (this.note.neume.notes.length === noteIndex) {
	          // this note is the last in its neume:
	          if (this.note.neume.trailingSpace === 0) {
	            // if this was the last note in its neume, we only care about the next note if there is no trailing space at the end of this neume.
	            var notationIndex = this.note.neume.score.notations.indexOf(this.note.neume);
	            if (notationIndex >= 0) {
	              var nextNotation = this.note.neume.score.notations[notationIndex + 1];
	              if (nextNotation && nextNotation.notes) {
	                nextNote = nextNotation.notes[0];
	              }
	            }
	          } else if (this.note.shape !== _ExsurgeChant.NoteShape.Inclinatum) {
	            this.note.neume.calculatedTrailingSpace += this.origin.x;
	          }
	        }
	      }
	
	      if (this.positionHint === _ExsurgeDrawing.MarkingPositionHint.Above) {
	        if (staffPosition % 2 === 0) verticalOffset -= ctxt.staffInterval * 1.75;else verticalOffset -= ctxt.staffInterval * 0.75;
	      } else if (this.positionHint === _ExsurgeDrawing.MarkingPositionHint.Below) {
	        if (staffPosition % 2 === 0) verticalOffset += ctxt.staffInterval * 1.75;else verticalOffset += ctxt.staffInterval * 0.75;
	      } else {
	        if (staffPosition % 2 === 0) {
	          // if the note is in a space and followed by a note on the line below, we often want to move the mora dot up slightly so that it is centered
	          // between the top of the note's space and the top of the following note.
	          if (nextNote && nextNote.staffPosition === staffPosition - 1) {
	            verticalOffset -= ctxt.staffInterval * 0.25;
	          }
	        } else {
	          verticalOffset -= ctxt.staffInterval * 0.75;
	        }
	      }
	      this.bounds.x = this.horizontalOffset + this.note.bounds.right();
	      this.bounds.y += verticalOffset;
	    }
	  }]);
	
	  return Mora;
	}(_ExsurgeDrawing.GlyphVisualizer);
	
	// indicates the shape of the brace
	
	
	var BraceShape = exports.BraceShape = {
	  RoundBrace: 0,
	  CurlyBrace: 1,
	  AccentedCurlyBrace: 2
	};
	
	// indicates how the brace is alignerd to the note to which it's connected
	var BraceAttachment = exports.BraceAttachment = {
	  Left: 0,
	  Right: 1
	};
	
	var BracePoint = exports.BracePoint = function (_ChantLayoutElement2) {
	  _inherits(BracePoint, _ChantLayoutElement2);
	
	  function BracePoint(note, isAbove, shape, attachment) {
	    _classCallCheck(this, BracePoint);
	
	    var _this5 = _possibleConstructorReturn(this, (BracePoint.__proto__ || Object.getPrototypeOf(BracePoint)).call(this));
	
	    _this5.note = note;
	    _this5.isAbove = isAbove;
	    _this5.shape = shape;
	    _this5.attachment = attachment;
	    return _this5;
	  }
	
	  _createClass(BracePoint, [{
	    key: \"getAttachmentX\",
	    value: function getAttachmentX(note) {
	      if (!note) note = this.note;
	      if (this.attachment === BraceAttachment.Left) return (note.neume ? note.neume.bounds.x : 0) + note.bounds.x;else return (note.neume ? note.neume.bounds.x : 0) + note.bounds.right();
	    }
	  }]);
	
	  return BracePoint;
	}(_ExsurgeDrawing.ChantLayoutElement);

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	exports.Virgula = exports.Accidental = exports.AccidentalType = exports.DoubleBar = exports.DominicanBar = exports.InsertionCursor = exports.FullBar = exports.HalfBar = exports.QuarterBar = exports.Divider = exports.Custos = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _ExsurgeCore = __webpack_require__(1);
	
	var _ExsurgeDrawing = __webpack_require__(4);
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //
	// Author(s):
	// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
	//
	// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the \"Software\"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	//
	
	/*
	 *
	 */
	var Custos = exports.Custos = function (_ChantNotationElement) {
	  _inherits(Custos, _ChantNotationElement);
	
	  // if auto is true, then the custos will automatically try to determine it's height based on
	  // subsequent notations
	  function Custos() {
	    var auto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	
	    _classCallCheck(this, Custos);
	
	    var _this = _possibleConstructorReturn(this, (Custos.__proto__ || Object.getPrototypeOf(Custos)).call(this));
	
	    _this.auto = auto;
	    _this.staffPosition = 0; // default sane value
	    return _this;
	  }
	
	  _createClass(Custos, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Custos.prototype.__proto__ || Object.getPrototypeOf(Custos.prototype), \"performLayout\", this).call(this, ctxt);
	
	      if (this.auto) {
	        var neume = ctxt.findNextNeume();
	
	        if (neume) this.staffPosition = ctxt.activeClef.pitchToStaffPosition(neume.notes[0].pitch);
	
	        // in case there was a weird fa/do clef change, let's sanitize the staffPosition by making sure it is
	        // within reasonable bounds
	        while (this.staffPosition < -6) {
	          this.staffPosition += 7;
	        }while (this.staffPosition > 6) {
	          this.staffPosition -= 7;
	        }
	      }
	
	      var glyph = new _ExsurgeDrawing.GlyphVisualizer(ctxt, Custos.getGlyphCode(this.staffPosition));
	      glyph.setStaffPosition(ctxt, this.staffPosition);
	      this.addVisualizer(glyph);
	
	      this.finishLayout(ctxt);
	    }
	
	    // called when layout has changed and our dependencies are no longer good
	
	  }, {
	    key: \"resetDependencies\",
	    value: function resetDependencies() {
	      // we only need to resolve new dependencies if we're an automatic custos
	      if (this.auto) this.needsLayout = true;
	    }
	  }], [{
	    key: \"getGlyphCode\",
	    value: function getGlyphCode(staffPosition) {
	      if (staffPosition <= 2) {
	        // ascending custodes
	        if (Math.abs(staffPosition) % 2 === 1) return _ExsurgeDrawing.GlyphCode.CustosLong;else return _ExsurgeDrawing.GlyphCode.CustosShort;
	      } else {
	        // descending custodes
	        if (Math.abs(staffPosition) % 2 === 1) return _ExsurgeDrawing.GlyphCode.CustosDescLong;else return _ExsurgeDrawing.GlyphCode.CustosDescShort;
	      }
	    }
	  }]);
	
	  return Custos;
	}(_ExsurgeDrawing.ChantNotationElement);
	
	/*
	 * Divider
	 */
	
	
	var Divider = exports.Divider = function (_ChantNotationElement2) {
	  _inherits(Divider, _ChantNotationElement2);
	
	  function Divider() {
	    _classCallCheck(this, Divider);
	
	    var _this2 = _possibleConstructorReturn(this, (Divider.__proto__ || Object.getPrototypeOf(Divider)).call(this));
	
	    _this2.isDivider = true;
	    _this2.resetsAccidentals = true;
	    return _this2;
	  }
	
	  return Divider;
	}(_ExsurgeDrawing.ChantNotationElement);
	
	/*
	 * QuarterBar
	 */
	
	
	var QuarterBar = exports.QuarterBar = function (_Divider) {
	  _inherits(QuarterBar, _Divider);
	
	  function QuarterBar() {
	    _classCallCheck(this, QuarterBar);
	
	    return _possibleConstructorReturn(this, (QuarterBar.__proto__ || Object.getPrototypeOf(QuarterBar)).apply(this, arguments));
	  }
	
	  _createClass(QuarterBar, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(QuarterBar.prototype.__proto__ || Object.getPrototypeOf(QuarterBar.prototype), \"performLayout\", this).call(this, ctxt);
	      this.addVisualizer(new _ExsurgeDrawing.DividerLineVisualizer(ctxt, 2, 4, this));
	
	      this.origin.x = this.bounds.width / 2;
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return QuarterBar;
	}(Divider);
	
	/*
	 * HalfBar
	 */
	
	
	var HalfBar = exports.HalfBar = function (_Divider2) {
	  _inherits(HalfBar, _Divider2);
	
	  function HalfBar() {
	    _classCallCheck(this, HalfBar);
	
	    return _possibleConstructorReturn(this, (HalfBar.__proto__ || Object.getPrototypeOf(HalfBar)).apply(this, arguments));
	  }
	
	  _createClass(HalfBar, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(HalfBar.prototype.__proto__ || Object.getPrototypeOf(HalfBar.prototype), \"performLayout\", this).call(this, ctxt);
	
	      this.addVisualizer(new _ExsurgeDrawing.DividerLineVisualizer(ctxt, -2, 2, this));
	
	      this.origin.x = this.bounds.width / 2;
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return HalfBar;
	}(Divider);
	
	/*
	 * FullBar
	 */
	
	
	var FullBar = exports.FullBar = function (_Divider3) {
	  _inherits(FullBar, _Divider3);
	
	  function FullBar() {
	    _classCallCheck(this, FullBar);
	
	    return _possibleConstructorReturn(this, (FullBar.__proto__ || Object.getPrototypeOf(FullBar)).apply(this, arguments));
	  }
	
	  _createClass(FullBar, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(FullBar.prototype.__proto__ || Object.getPrototypeOf(FullBar.prototype), \"performLayout\", this).call(this, ctxt);
	
	      this.addVisualizer(new _ExsurgeDrawing.DividerLineVisualizer(ctxt, -3, 3, this));
	
	      this.origin.x = this.bounds.width / 2;
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return FullBar;
	}(Divider);
	
	/*
	 * Insertion Cursor
	 */
	
	
	var InsertionCursor = exports.InsertionCursor = function (_Divider4) {
	  _inherits(InsertionCursor, _Divider4);
	
	  function InsertionCursor() {
	    _classCallCheck(this, InsertionCursor);
	
	    return _possibleConstructorReturn(this, (InsertionCursor.__proto__ || Object.getPrototypeOf(InsertionCursor)).apply(this, arguments));
	  }
	
	  _createClass(InsertionCursor, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(InsertionCursor.prototype.__proto__ || Object.getPrototypeOf(InsertionCursor.prototype), \"performLayout\", this).call(this, ctxt);
	
	      this.addVisualizer(new _ExsurgeDrawing.DividerLineVisualizer(ctxt, -4, 4));
	
	      this.origin.x = this.bounds.width / 2;
	      this.bounds.width = 0;
	      this.bounds.height = 0;
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return InsertionCursor;
	}(Divider);
	
	/*
	 * DominicanBar
	 */
	
	
	var DominicanBar = exports.DominicanBar = function (_Divider5) {
	  _inherits(DominicanBar, _Divider5);
	
	  function DominicanBar(staffPosition) {
	    _classCallCheck(this, DominicanBar);
	
	    var _this7 = _possibleConstructorReturn(this, (DominicanBar.__proto__ || Object.getPrototypeOf(DominicanBar)).call(this));
	
	    staffPosition--;
	    var parity = staffPosition % 2;
	
	    _this7.staffPosition = staffPosition - 2 * parity;
	    return _this7;
	  }
	
	  _createClass(DominicanBar, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(DominicanBar.prototype.__proto__ || Object.getPrototypeOf(DominicanBar.prototype), \"performLayout\", this).call(this, ctxt);
	      this.addVisualizer(new _ExsurgeDrawing.DividerLineVisualizer(ctxt, this.staffPosition - 3, this.staffPosition, this));
	
	      this.origin.x = this.bounds.width / 2;
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return DominicanBar;
	}(Divider);
	
	/*
	 * DoubleBar
	 */
	
	
	var DoubleBar = exports.DoubleBar = function (_Divider6) {
	  _inherits(DoubleBar, _Divider6);
	
	  function DoubleBar() {
	    _classCallCheck(this, DoubleBar);
	
	    return _possibleConstructorReturn(this, (DoubleBar.__proto__ || Object.getPrototypeOf(DoubleBar)).apply(this, arguments));
	  }
	
	  _createClass(DoubleBar, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(DoubleBar.prototype.__proto__ || Object.getPrototypeOf(DoubleBar.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var line0 = new _ExsurgeDrawing.DividerLineVisualizer(ctxt, -3, 3, this);
	      line0.bounds.x = 0;
	      this.addVisualizer(line0);
	
	      var line1 = new _ExsurgeDrawing.DividerLineVisualizer(ctxt, -3, 3, this);
	      line1.bounds.x = ctxt.intraNeumeSpacing * 2 - line1.bounds.width;
	      this.addVisualizer(line1);
	
	      this.origin.x = this.bounds.width / 2;
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return DoubleBar;
	}(Divider);
	
	var AccidentalType = exports.AccidentalType = {
	  Flat: -1,
	  Natural: 0,
	  Sharp: 1
	};
	
	/*
	 * Accidental
	 */
	
	var Accidental = exports.Accidental = function (_ChantNotationElement3) {
	  _inherits(Accidental, _ChantNotationElement3);
	
	  function Accidental(staffPosition, accidentalType) {
	    _classCallCheck(this, Accidental);
	
	    var _this9 = _possibleConstructorReturn(this, (Accidental.__proto__ || Object.getPrototypeOf(Accidental)).call(this));
	
	    _this9.isAccidental = true;
	    _this9.keepWithNext = true; // accidentals should always stay connected...
	
	    _this9.staffPosition = staffPosition;
	    _this9.accidentalType = accidentalType;
	    return _this9;
	  }
	
	  _createClass(Accidental, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Accidental.prototype.__proto__ || Object.getPrototypeOf(Accidental.prototype), \"performLayout\", this).call(this, ctxt);
	
	      this.addVisualizer(this.createGlyphVisualizer(ctxt));
	
	      this.finishLayout(ctxt);
	    }
	
	    // creation of the glyph visualizer is refactored out or performLayout
	    // so that clefs can use the same logic for their accidental glyph
	
	  }, {
	    key: \"createGlyphVisualizer\",
	    value: function createGlyphVisualizer(ctxt) {
	      var glyphCode = _ExsurgeDrawing.GlyphCode.Flat;
	
	      switch (this.accidentalType) {
	        case AccidentalType.Natural:
	          glyphCode = _ExsurgeDrawing.GlyphCode.Natural;
	          break;
	        case AccidentalType.Sharp:
	          glyphCode = _ExsurgeDrawing.GlyphCode.Sharp;
	          break;
	        default:
	          glyphCode = _ExsurgeDrawing.GlyphCode.Flat;
	          break;
	      }
	
	      var glyph = new _ExsurgeDrawing.GlyphVisualizer(ctxt, glyphCode);
	      glyph.setStaffPosition(ctxt, this.staffPosition);
	
	      return glyph;
	    }
	  }, {
	    key: \"adjustStep\",
	    value: function adjustStep(step) {
	      switch (this.accidentalType) {
	        case AccidentalType.Flat:
	          if (step === _ExsurgeCore.Step.Ti) return _ExsurgeCore.Step.Te;
	          if (step === _ExsurgeCore.Step.Mi) return _ExsurgeCore.Step.Me;
	          break;
	        case AccidentalType.Sharp:
	          if (step === _ExsurgeCore.Step.Do) return _ExsurgeCore.Step.Du;
	          if (step === _ExsurgeCore.Step.Fa) return _ExsurgeCore.Step.Fu;
	          break;
	        case AccidentalType.Natural:
	          if (step === _ExsurgeCore.Step.Te) return _ExsurgeCore.Step.Ti;
	          if (step === _ExsurgeCore.Step.Me) return _ExsurgeCore.Step.Mi;
	          if (step === _ExsurgeCore.Step.Du) return _ExsurgeCore.Step.Do;
	          if (step === _ExsurgeCore.Step.Fu) return _ExsurgeCore.Step.Fa;
	          break;
	      }
	
	      // no adjustment needed
	      return step;
	    }
	  }, {
	    key: \"applyToPitch\",
	    value: function applyToPitch(pitch) {
	      // no adjusment needed
	      if (this.pitch.octave !== pitch.octave) return;
	
	      pitch.step = this.adjustStep(pitch.step);
	    }
	  }]);
	
	  return Accidental;
	}(_ExsurgeDrawing.ChantNotationElement);
	
	/*
	 * Virgula
	 */
	
	
	var Virgula = exports.Virgula = function (_Divider7) {
	  _inherits(Virgula, _Divider7);
	
	  function Virgula() {
	    _classCallCheck(this, Virgula);
	
	    // unlike other dividers a virgula does not reset accidentals
	    var _this10 = _possibleConstructorReturn(this, (Virgula.__proto__ || Object.getPrototypeOf(Virgula)).call(this));
	
	    _this10.resetsAccidentals = false;
	
	    // the staff position of the virgula is customizable, so that it
	    // can be placed on different lines (top or bottom) depending on the
	    // notation tradition of what is being notated (e.g., Benedictine has it
	    //  on top line, Norbertine at the bottom)
	    _this10.staffPosition = 3;
	    return _this10;
	  }
	
	  _createClass(Virgula, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Virgula.prototype.__proto__ || Object.getPrototypeOf(Virgula.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var glyph = new _ExsurgeDrawing.GlyphVisualizer(ctxt, _ExsurgeDrawing.GlyphCode.Virgula);
	      glyph.setStaffPosition(ctxt, this.staffPosition);
	
	      this.addVisualizer(glyph);
	
	      this.origin.x = this.bounds.width / 2;
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Virgula;
	}(Divider);

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	exports.Gabc = exports.GabcHeader = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //
	// Author(s):
	// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
	//
	// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the \"Software\"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	//
	
	var _ExsurgeCore = __webpack_require__(1);
	
	var _ExsurgeDrawing = __webpack_require__(4);
	
	var _ExsurgeChant = __webpack_require__(8);
	
	var _ExsurgeChantMarkings = __webpack_require__(10);
	
	var Markings = _interopRequireWildcard(_ExsurgeChantMarkings);
	
	var _ExsurgeChantSigns = __webpack_require__(11);
	
	var Signs = _interopRequireWildcard(_ExsurgeChantSigns);
	
	var _ExsurgeChantNeumes = __webpack_require__(13);
	
	var Neumes = _interopRequireWildcard(_ExsurgeChantNeumes);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }
	
	// reusable reg exps
	var __syllablesRegex = /(?=\\S)((?:<v>[\\s\\S]*<\\/v>|[^(])*)(?:\\(?([^)]*)\\)?)?/g;
	var __altTranslationRegex = /<alt>(.*?)<\\/alt>|\\[(alt:)?(.*?)\\]/g;
	
	var __notationsRegex = /z0|z|Z|::|:|[,;][1-6]?|`|[cf][1-4]|cb[1-4]|\\/+| |\\!|-?[a-mA-M][oOwWvVrRsxy#~\\+><_\\.'012345]*(?:\\[[^\\]]*\\]?)*|\\{([^}]+)\\}?/g;
	var __notationsRegex_group_insideBraces = 1;
	
	var __bracketedCommandRegex = /^([a-z]+):(.*)/;
	
	// for the brace string inside of [ and ] in notation data
	// the capturing groups are:
	//  1. o or u, to indicate over or under
	//  2. b, cb, or cba, to indicate the brace type
	//  3. 0 or 1 to indicate the attachment point
	//  4. { or } to indicate opening/closing (this group will be null if the metric version is used)
	//  5. a float indicating the millimeter length of the brace (not supported yet)
	var __braceSpecRegex = /([ou])(b|cb|cba):([01])(?:([{}])|;(\\d*(?:\\.\\d+)?)mm)/;
	
	var TrailingSpaceForAccidental = function TrailingSpaceForAccidental(ctxt) {
	  return ctxt.intraNeumeSpacing * ctxt.accidentalSpaceMultiplier;
	};
	var TrailingSpaceMultiple = function TrailingSpaceMultiple(multiplier) {
	  return function (ctxt) {
	    return ctxt.intraNeumeSpacing * multiplier;
	  };
	};
	
	var regexHeaderEnd = /(?:^|\
)%%\\s?\
/;
	var regexHeaderLine = /^([\\w-_.]+):\\s*((?:[^;\\r\
]|;[ \	])*)(?:;|$)/i;
	var regexHeaderComment = /^%.*/;
	
	var GabcHeader = exports.GabcHeader = function () {
	  _createClass(GabcHeader, null, [{
	    key: \"getLength\",
	    value: function getLength(gabc) {
	      var match = gabc.match(regexHeaderEnd);
	      return match ? match.index + match[0].length : 0;
	    }
	  }]);
	
	  function GabcHeader(text) {
	    _classCallCheck(this, GabcHeader);
	
	    if (typeof text !== \"string\") text = \"\";
	    this.comments = [];
	    this.cValues = {};
	    this.original = \"\";
	    var match = text.match(regexHeaderEnd);
	    if (match) {
	      var txtHeader = this.original = text.slice(0, match.index + match[0].length);
	      var lines = txtHeader.split(/\\r?\
/g);
	      for (var i = 0; i < lines.length; ++i) {
	        var line = lines[i],
	            _match = regexHeaderLine.exec(line);
	        if (_match) {
	          var key = _match[1].replace(/-([a-z])/g, function (a, letter) {
	            return letter.toUpperCase();
	          });
	          if (this[_match[1]]) {
	            var arrayName = _match[1] + \"Array\";
	            if (!this[arrayName]) {
	              this[arrayName] = [this[_match[1]]];
	            }
	            this[arrayName].push(_match[2]);
	          } else {
	            this[_match[1]] = _match[2];
	          }
	          if (key !== _match[1]) this[key] = this[_match[1]];
	        } else if (_match = regexHeaderComment.exec(line)) {
	          if (line !== \"%%\") {
	            _match = regexHeaderLine.exec(line.slice(1));
	            if (_match) {
	              var _key = _match[1].replace(/-([a-z])/g, function (a, letter) {
	                return letter.toUpperCase();
	              });
	              this.cValues[_match[1]] = _match[2];
	              if (_key !== _match[1]) this.cValues[_key] = _match[2];
	            } else {
	              this.comments[i] = line;
	            }
	          }
	        }
	      }
	    }
	  }
	
	  _createClass(GabcHeader, [{
	    key: \"toString\",
	    value: function toString() {
	      var result = [];
	      for (var key in this) {
	        if (typeof this[key] !== \"string\" || /^(length|original|comments|cValues)$/.test(key)) {
	          continue;
	        }
	        var alternateKey = key.replace(/[A-Z]/g, function (letter) {
	          return \"-\" + letter.toLowerCase();
	        });
	        if (alternateKey !== key && alternateKey in this) continue;
	        var array = this[key + \"Array\"];
	        if (array) {
	          for (var i = 0; i < array.length; ++i) {
	            result.push(key + \": \" + array[i] + \";\");
	          }
	        } else {
	          result.push(key + \": \" + this[key] + \";\");
	        }
	      }
	      for (var _key2 in this.cValues) {
	        if (_key2.length === 0 || !this.cValues.hasOwnProperty(_key2)) continue;
	        result.push(\"%\" + _key2 + \": \" + this.cValues[_key2] + \";\");
	      }
	      for (var _i in this.comments) {
	        if (!this.comments.hasOwnProperty(_i)) continue;
	        try {
	          result.splice(_i, 0, this.comments[_i]);
	        } catch (e) {
	          console.warn(e);
	        }
	      }
	      return result.join(\"\
\") + \"\
%%\
\";
	    }
	  }]);
	
	  return GabcHeader;
	}();
	
	var elementCountForNotations = function elementCountForNotations(items) {
	  return items.reduce(function (sum, item) {
	    return sum + (item.notes ? item.notes.length : 1);
	  }, 0);
	};
	
	var Gabc = exports.Gabc = function () {
	  function Gabc() {
	    _classCallCheck(this, Gabc);
	  }
	
	  _createClass(Gabc, null, [{
	    key: \"createMappingsFromSource\",
	
	    // takes gabc source code (without the header info) and returns an array
	    // of ChantMappings describing the chant. A chant score can then be created
	    // fron the chant mappings and later updated via updateMappings() if need
	    // be...
	    value: function createMappingsFromSource(ctxt, gabcSource) {
	      var headerLength = GabcHeader.getLength(gabcSource);
	      gabcSource = gabcSource.slice(headerLength);
	      var words = this.splitWords(gabcSource);
	
	      // set the default clef
	      ctxt.activeClef = _ExsurgeChant.Clef.default();
	
	      var mappings = this.createMappingsFromWords(ctxt, words, function (clef) {
	        return ctxt.activeClef = clef;
	      });
	
	      // always set the last notation to have a trailingSpace of 0. This makes layout for the last chant line simpler
	      if (mappings.length > 0 && mappings[mappings.length - 1].notations.length > 0) mappings[mappings.length - 1].notations[mappings[mappings.length - 1].notations.length - 1].trailingSpace = 0;
	
	      return mappings;
	    }
	
	    // A simple general purpose diff algorithm adapted here for comparing
	    // an array of existing mappings with an updated list of gabc words.
	    // note before is an array of mappings, and after is an array of strings
	    // (gabc words).
	    //
	    // This is definitely not the most effecient diff algorithm, but for our
	    // limited needs and source size it seems to work just fine...
	    //
	    // code is adapted from: https://github.com/paulgb/simplediff
	    //
	    // Returns:
	    //   A list of pairs, with the first part of the pair being one of three
	    //   strings ('-', '+', '=') and the second part being a list of values from
	    //   the original before and/or after lists. The first part of the pair
	    //   corresponds to whether the list of values is a deletion, insertion, or
	    //   unchanged, respectively.
	
	  }, {
	    key: \"diffDescriptorsAndNewWords\",
	    value: function diffDescriptorsAndNewWords(before, after) {
	      // Create a map from before values to their indices
	      var oldIndexMap = {},
	          i;
	      for (i = 0; i < before.length; i++) {
	        oldIndexMap[before[i].source] = oldIndexMap[before[i].source] || [];
	        oldIndexMap[before[i].source].push(i);
	      }
	
	      var overlap = [],
	          startOld,
	          startNew,
	          subLength,
	          inew;
	
	      startOld = startNew = subLength = 0;
	
	      for (inew = 0; inew < after.length; inew++) {
	        var _overlap = [];
	        oldIndexMap[after[inew]] = oldIndexMap[after[inew]] || [];
	        for (i = 0; i < oldIndexMap[after[inew]].length; i++) {
	          var iold = oldIndexMap[after[inew]][i];
	          // now we are considering all values of val such that
	          // `before[iold] == after[inew]`
	          _overlap[iold] = (iold && overlap[iold - 1] || 0) + 1;
	          if (_overlap[iold] > subLength) {
	            // this is the largest substring seen so far, so store its indices
	            subLength = _overlap[iold];
	            startOld = iold - subLength + 1;
	            startNew = inew - subLength + 1;
	          }
	        }
	        overlap = _overlap;
	      }
	
	      if (subLength === 0) {
	        // If no common substring is found, we return an insert and delete...
	        var result = [];
	
	        if (before.length) result.push([\"-\", before]);
	
	        if (after.length) result.push([\"+\", after]);
	
	        return result;
	      }
	
	      // ...otherwise, the common substring is unchanged and we recursively
	      // diff the text before and after that substring
	      return [].concat(this.diffDescriptorsAndNewWords(before.slice(0, startOld), after.slice(0, startNew)), [[\"=\", after.slice(startNew, startNew + subLength)]], this.diffDescriptorsAndNewWords(before.slice(startOld + subLength), after.slice(startNew + subLength)));
	    }
	
	    // this function essentially performs and applies a rudimentary diff between a
	    // previously parsed set of mappings and between a new gabc source text.
	    // the mappings array passed in is changed in place to be updated from the
	    // new source
	
	  }, {
	    key: \"updateMappingsFromSource\",
	    value: function updateMappingsFromSource(ctxt, mappings, newGabcSource) {
	      var insertionIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	      var oldInsertionIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
	
	      var headerLength = GabcHeader.getLength(newGabcSource);
	      newGabcSource = newGabcSource.slice(headerLength);
	      // always remove the last old mapping since it's spacing/trailingSpace is handled specially
	      mappings.pop();
	
	      if (insertionIndex === null) {
	        insertionIndex = NaN;
	      }
	      if (oldInsertionIndex === null) {
	        oldInsertionIndex = NaN;
	      }
	
	      var newWords = this.splitWords(newGabcSource);
	
	      var results = this.diffDescriptorsAndNewWords(mappings, newWords);
	
	      var index = 0,
	          j,
	          k,
	          l,
	          sourceIndex = 0,
	          wordLength = 0,
	          mapping,
	          elementIndex = 0;
	
	      ctxt.activeClef = _ExsurgeChant.Clef.default();
	
	      // apply the results to the mappings, marking notations that need to be processed
	      var lastTranslationNeumes = [];
	      for (var i = 0; i < results.length; i++) {
	        var resultCode = results[i][0];
	        var resultValues = results[i][1];
	
	        if (index > 0) sourceIndex = mappings[index - 1].sourceIndex + mappings[index - 1].source.length + 1;
	        if (resultCode === \"=\") {
	          var sourceIndexDiff = sourceIndex - mappings[index].sourceIndex;
	          // skip over ones that haven't changed, but updating the clef and source
	          // index (and pitch in case clef or accidentals have changed) as we go
	          for (j = 0; j < resultValues.length; j++, index++) {
	            mapping = mappings[index];
	            if (elementIndex === 0 && mapping.notations.length && mapping.notations[0].isClef) {
	              // the first clef doesn't get kept as a notation:
	              elementIndex = -1;
	            }
	            if (insertionIndex >= elementIndex || oldInsertionIndex >= elementIndex) {
	              // check if the insertion index is within this mapping:
	              var elementCount = elementCountForNotations(mapping.notations);
	              if (insertionIndex >= elementIndex && insertionIndex < elementIndex + elementCount || oldInsertionIndex >= elementIndex && oldInsertionIndex < elementIndex + elementCount) {
	                // re-do this mapping:
	                // TODO: check sourceIndex
	                var _sourceIndex = mapping.sourceIndex + sourceIndexDiff;
	                mapping = this.createMappingFromWord(ctxt, resultValues[j], _sourceIndex, lastTranslationNeumes, insertionIndex - elementIndex);
	                mappings.splice(index, 1, mapping);
	
	                elementIndex += elementCount;
	                continue;
	              }
	              elementIndex += elementCount;
	            }
	            mapping.sourceIndex += sourceIndexDiff;
	            for (k = 0; k < mapping.notations.length; k++) {
	              var curNotation = mapping.notations[k];
	              var prevIsAccidental = mapping.notations[k - 1] && mapping.notations[k - 1].isAccidental;
	              // notify the notation that its dependencies are no longer valid
	              curNotation.resetDependencies();
	
	              if (curNotation.isClef) {
	                ctxt.activeClef = mappings[index].notations[k];
	              }
	
	              if (curNotation.isAccidental) {
	                ctxt.activeClef.activeAccidental = curNotation;
	              } else if (curNotation.resetsAccidentals || !prevIsAccidental && curNotation.hasLyrics() && curNotation.lyrics[0].lyricType <= _ExsurgeDrawing.LyricType.BeginningSyllable) {
	                ctxt.activeClef.resetAccidentals();
	              }
	
	              // update source index, pitch, and automatic braces
	              if (curNotation.notes) {
	                for (l = 0; l < curNotation.notes.length; ++l) {
	                  var note = curNotation.notes[l];
	                  note.sourceIndex += sourceIndexDiff;
	                  note.pitch = ctxt.activeClef.staffPositionToPitch(note.staffPosition);
	                  if (note.braceEnd && note.braceEnd.automatic) delete note.braceEnd;
	                  if (this.needToEndBrace && !note.braceStart && !note.braceEnd) {
	                    note.braceEnd = new Markings.BracePoint(note, this.needToEndBrace.isAbove, this.needToEndBrace.shape, this.needToEndBrace.attachment === Markings.BraceAttachment.Left ? Markings.BraceAttachment.Right : Markings.BraceAttachment.Left);
	                    note.braceEnd.automatic = true;
	                    delete this.needToEndBrace;
	                  } else if (note.braceStart && note.braceStart.automatic) {
	                    this.needToEndBrace = note.braceStart;
	                  }
	                }
	              }
	              if (curNotation.translationText) {
	                for (l = 0; l < curNotation.translationText.length; ++l) {
	                  var transText = curNotation.translationText[l];
	                  delete transText.endNeume;
	                  curNotation.translationText[l].sourceIndex += sourceIndexDiff;
	                  if (transText.textAnchor === \"end\" && lastTranslationNeumes[0]) {
	                    var lastTranslationText = lastTranslationNeumes[0].translationText[l];
	                    if (lastTranslationText) lastTranslationText.endNeume = curNotation;
	                  }
	                }
	                lastTranslationNeumes[0] = curNotation;
	              }
	              if (sourceIndexDiff) {
	                if (typeof curNotation.sourceIndex === \"number\") {
	                  curNotation.sourceIndex += sourceIndexDiff;
	                }
	                for (l = 0; l < curNotation.lyrics.length; ++l) {
	                  curNotation.lyrics[l].sourceIndex += sourceIndexDiff;
	                }
	                if (curNotation.alText) {
	                  for (l = 0; l < curNotation.alText.length; ++l) {
	                    curNotation.alText[l].sourceIndex += sourceIndexDiff;
	                  }
	                }
	              }
	            }
	          }
	        } else if (resultCode === \"-\") {
	          // delete elements that no longer exist, but first notify all
	          // elements of the change
	          mappings.splice(index, resultValues.length);
	        } else if (resultCode === \"+\") {
	          // insert new ones
	          for (j = 0; j < resultValues.length; j++) {
	            wordLength = resultValues[j].length + 1;
	            mapping = this.createMappingFromWord(ctxt, resultValues[j], sourceIndex, lastTranslationNeumes, insertionIndex - elementIndex);
	
	            if (elementIndex === 0 && mapping.notations.length && mapping.notations[0].isClef) {
	              // the first clef doesn't get kept as a notation:
	              elementIndex = -1;
	              var _elementCount = elementCountForNotations(mapping.notations);
	              if (insertionIndex < _elementCount) {
	                // re-do the first mapping, because it was broken up incorrectly, due to the presence of the initial clef
	                mapping = this.createMappingFromWord(ctxt, resultValues[j], sourceIndex, lastTranslationNeumes, insertionIndex - elementIndex);
	              }
	            }
	
	            for (k = 0; k < mapping.notations.length; k++) {
	              var _curNotation = mapping.notations[k];
	              elementIndex += _curNotation.notes ? _curNotation.notes.length : 1;
	              if (_curNotation.isClef) {
	                ctxt.activeClef = mapping.notations[k];
	              }
	            }
	
	            mappings.splice(index++, 0, mapping);
	            sourceIndex += wordLength;
	          }
	        }
	      }
	
	      // always set the last notation to have a trailingSpace of 0. This makes layout for the last chant line simpler
	      if (mappings.length > 0 && mappings[mappings.length - 1].notations.length > 0) mappings[mappings.length - 1].notations[mappings[mappings.length - 1].notations.length - 1].trailingSpace = 0;
	
	      return headerLength;
	    }
	
	    // takes an array of gabc words (like that returned by splitWords below)
	    // and returns an array of ChantMapping objects, one for each word.
	
	  }, {
	    key: \"createMappingsFromWords\",
	    value: function createMappingsFromWords(ctxt, words) {
	      var mappings = [];
	      var sourceIndex = 0,
	          wordLength = 0,
	          lastTranslationNeumes = [];
	
	      for (var i = 0; i < words.length; i++) {
	        sourceIndex += wordLength;
	        wordLength = words[i].length + 1;
	        var word = words[i].trim();
	
	        if (word === \"\") continue;
	
	        var mapping = this.createMappingFromWord(ctxt, word, sourceIndex, lastTranslationNeumes);
	
	        if (mapping) mappings.push(mapping);
	      }
	
	      return mappings;
	    }
	
	    // takes a gabc word (like those returned by splitWords below) and returns
	    // a ChantMapping object that contains the gabc word source text as well
	    // as the generated notations.
	
	  }, {
	    key: \"createMappingFromWord\",
	    value: function createMappingFromWord(ctxt, word, sourceIndex, lastTranslationNeumes, insertionIndex) {
	      var matches = [];
	      var notations = [];
	      var currSyllable = 0;
	
	      while (match = __syllablesRegex.exec(word)) {
	        matches.push(match);
	      }for (var j = 0; j < matches.length; j++) {
	        var match = matches[j];
	
	        var lyricText = match[1].replace(/(^|<\\/sp>)([\\s\\S]*?)($|<sp>)/g, function (_, pre, main, post) {
	          return \"\" + pre + main.replace(/~/g, \" \") + post;
	        });
	        var alText = [];
	        var translationText = [];
	        var notationData = match[2];
	
	        // new words reset the accidentals, per the Solesmes style (see LU xviij)
	        // but we need to also make sure that there _is_ a word and that it has notes associated with it.
	        if (currSyllable === 0 && /[a-z]/i.test(lyricText) && /[a-m]/i.test(notationData)) ctxt.activeClef.resetAccidentals();
	
	        var items = this.parseNotations(ctxt, notationData, sourceIndex + match.index + match[1].length + 1, insertionIndex);
	
	        if (items.length === 0) continue;
	
	        if (insertionIndex >= 0) insertionIndex -= elementCountForNotations(items);
	
	        items[0].firstOfSyllable = !!lyricText;
	        items[0].firstOfParentheses = true;
	        notations.push.apply(notations, _toConsumableArray(items));
	
	        // add the lyrics and/or alText to the first notation that makes sense...
	        var notationWithLyrics = null;
	        for (var i = 0; i < items.length; i++) {
	          var cne = items[i];
	
	          if (cne.isAccidental && i + 1 < items.length) continue;
	
	          notationWithLyrics = cne;
	          break;
	        }
	
	        var m = __altTranslationRegex.exec();
	        var indexOffset = 0;
	        while (m = __altTranslationRegex.exec(lyricText)) {
	          var index = m.index;
	          lyricText = lyricText.slice(0, index) + lyricText.slice(index + m[0].length);
	          index += sourceIndex + indexOffset + 1;
	          if (typeof m[1] === \"string\") {
	            var elem = new _ExsurgeDrawing.AboveLinesText(ctxt, m[1], notationWithLyrics, index + 4);
	            elem.alIndex = alText.push(elem) - 1;
	          } else if (typeof m[2] === \"string\") {
	            var _elem = new _ExsurgeDrawing.AboveLinesText(ctxt, m[3], notationWithLyrics, index + m[2].length);
	            _elem.alIndex = alText.push(_elem) - 1;
	          } else {
	            var _elem2 = new _ExsurgeDrawing.TranslationText(ctxt, m[3], notationWithLyrics, index);
	            _elem2.translationIndex = translationText.push(_elem2) - 1;
	          }
	          indexOffset += m[0].length;
	          __altTranslationRegex.exec();
	        }
	        if (lyricText === \"\" && alText.length === 0) continue;
	
	        if (notationWithLyrics === null) return new _ExsurgeChant.ChantMapping(word, notations, sourceIndex);
	
	        if (alText.length) notationWithLyrics.alText = alText;
	
	        if (translationText.length) {
	          notationWithLyrics.translationText = translationText;
	          for (i = 0; i < translationText.length; ++i) {
	            var transText = translationText[i];
	            if (transText.textAnchor === \"end\" && lastTranslationNeumes[0]) {
	              var lastTranslationText = lastTranslationNeumes[0].translationText[i];
	              if (lastTranslationText) lastTranslationText.endNeume = notationWithLyrics;
	            }
	          }
	          lastTranslationNeumes[0] = notationWithLyrics;
	        }
	
	        if (lyricText === \"\") continue;
	
	        var proposedLyricType;
	
	        // if it's not a neume or a TextOnly notation, then make the lyrics a directive
	        if (!cne.isNeume && cne.constructor !== _ExsurgeChant.TextOnly) proposedLyricType = _ExsurgeDrawing.LyricType.Directive;
	        // otherwise trye to guess the lyricType for the first lyric anyway
	        else if (currSyllable === 0 && j === matches.length - 1) proposedLyricType = _ExsurgeDrawing.LyricType.SingleSyllable;else if (currSyllable === 0 && j < matches.length - 1) proposedLyricType = _ExsurgeDrawing.LyricType.BeginningSyllable;else if (j === matches.length - 1) proposedLyricType = _ExsurgeDrawing.LyricType.EndingSyllable;else proposedLyricType = _ExsurgeDrawing.LyricType.MiddleSyllable;
	
	        currSyllable++;
	
	        var lyrics = this.createSyllableLyrics(ctxt, lyricText, proposedLyricType, notationWithLyrics, items, sourceIndex + match.index);
	
	        if (lyrics === null || lyrics.length === 0) continue;
	
	        notationWithLyrics.lyrics = lyrics;
	      }
	
	      return new _ExsurgeChant.ChantMapping(word, notations, sourceIndex);
	    }
	
	    // returns an array of lyrics (an array because each syllable can have multiple lyrics)
	
	  }, {
	    key: \"createSyllableLyrics\",
	    value: function createSyllableLyrics(ctxt, text, proposedLyricType, notation, notations, sourceIndex) {
	      var _this = this;
	
	      var lyrics = [];
	
	      // an extension to gabc: multiple lyrics per syllable can be separated by a |
	      var lyricTexts = text.split(\"|\");
	
	      var _loop = function _loop() {
	        lyricText = lyricTexts[i];
	
	
	        if (i > 0) {
	          if (lyricText.match(/\\s$/)) {
	            lyricText = lyricText.replace(/s+$/, \"\");
	            proposedLyricType = _ExsurgeDrawing.LyricType.EndingSyllable;
	          } else {
	            proposedLyricType = _ExsurgeDrawing.LyricType.MiddleSyllable;
	          }
	        }
	
	        // gabc allows lyrics to indicate the centering part of the text by
	        // using braces to indicate how to center the lyric. So a lyric can
	        // look like \"f{i}re\" or \"{fenced}\" to center on the i or on the entire
	        // word, respectively. Here we determine if the lyric should be spaced
	        // manually with this method of using braces.
	        // however, we don't want to consider any braces inside of v tags, so we
	        // do a bit of text processing here:
	        lyricTextWithoutVTags = lyricText;
	
	        var vtagRegex = /<v>[\\s\\S]*?<\\/v>/;
	        var match = void 0;
	        var vtags = [];
	        while (match = vtagRegex.exec(lyricTextWithoutVTags)) {
	          var index = match.index;
	          var length = match[0].length;
	          vtags[index] = length;
	          lyricTextWithoutVTags = lyricTextWithoutVTags.slice(0, index) + lyricTextWithoutVTags.slice(index + length);
	        }
	        centerStartIndex = lyricTextWithoutVTags.indexOf(\"{\");
	        centerLength = 0;
	
	
	        if (centerStartIndex >= 0) {
	          var indexClosingBracket = lyricTextWithoutVTags.indexOf(\"}\");
	
	          if (indexClosingBracket >= 0 && indexClosingBracket > centerStartIndex) {
	            var getTrueIndex = function getTrueIndex(indexWithoutVTags) {
	              // map indices back to the lyricText with the V tags:
	              var accum = 0;
	              for (var _index in vtags) {
	                if (vtags.hasOwnProperty(_index) && indexWithoutVTags >= _index) {
	                  accum += vtags[_index];
	                } else {
	                  break;
	                }
	              }
	              return indexWithoutVTags + accum;
	            };
	            centerStartIndex = getTrueIndex(centerStartIndex);
	            indexClosingBracket = getTrueIndex(indexClosingBracket);
	            centerLength = indexClosingBracket - centerStartIndex - 1;
	
	            // strip out the brackets:
	            lyricText = lyricText.substring(0, centerStartIndex) + lyricText.substring(centerStartIndex + 1, indexClosingBracket) + lyricText.substring(indexClosingBracket + 1, lyricText.length);
	          } else centerStartIndex = -1; // if there's no closing bracket, don't enable centering
	        }
	
	        lyric = _this.makeLyric(ctxt, lyricText, proposedLyricType, notation, notations, sourceIndex);
	
	
	        if (centerStartIndex >= 0) {
	          // update indices in case there had been any tags, etc.
	          var textIndex = 0,
	              centerEndIndex = -1;
	          var _iteratorNormalCompletion = true;
	          var _didIteratorError = false;
	          var _iteratorError = undefined;
	
	          try {
	            for (var _iterator = lyric.spans[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              var span = _step.value;
	
	              if (centerStartIndex >= span.index && centerStartIndex <= span.index + span.text.length) {
	                centerEndIndex = centerStartIndex + centerLength;
	                centerStartIndex += textIndex - span.index;
	              }
	              if (centerEndIndex >= 0 && centerEndIndex >= span.index && centerEndIndex <= span.index + span.text.length) {
	                centerEndIndex += textIndex - span.index;
	                centerLength = centerEndIndex - centerStartIndex;
	                centerEndIndex = -1;
	                break;
	              }
	              textIndex += span.text.length;
	            }
	          } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	              }
	            } finally {
	              if (_didIteratorError) {
	                throw _iteratorError;
	              }
	            }
	          }
	
	          if (centerEndIndex >= 0) {
	            centerEndIndex = textIndex;
	            centerLength = centerEndIndex - centerStartIndex;
	          }
	        }
	
	        // if we have manual lyric centering, then set it now
	        if (centerStartIndex >= 0) {
	          lyric.centerStartIndex = centerStartIndex;
	          lyric.centerLength = centerLength;
	        }
	
	        lyric.lyricIndex = lyrics.push(lyric) - 1;
	        sourceIndex += lyricText.length + 1;
	      };
	
	      for (var i = 0; i < lyricTexts.length; i++) {
	        var lyricText;
	        var lyricTextWithoutVTags;
	        var centerStartIndex;
	        var centerLength;
	        var lyric;
	
	        _loop();
	      }
	      notation.lyrics = lyrics;
	      return lyrics;
	    }
	  }, {
	    key: \"makeLyric\",
	    value: function makeLyric(ctxt, text, lyricType, notation, notations, sourceIndex) {
	      var elides = false;
	      var forceConnector = false;
	      if (text.length > 1) {
	        if (text[text.length - 1] === \"-\") {
	          forceConnector = true;
	          if (lyricType === _ExsurgeDrawing.LyricType.EndingSyllable) lyricType = _ExsurgeDrawing.LyricType.MiddleSyllable;else if (lyricType === _ExsurgeDrawing.LyricType.SingleSyllable) lyricType = _ExsurgeDrawing.LyricType.BeginningSyllable;
	
	          text = text.slice(0, -1);
	        } else if (text[text.length - 1] === \" \") {
	          if (lyricType === _ExsurgeDrawing.LyricType.MiddleSyllable) lyricType = _ExsurgeDrawing.LyricType.EndingSyllable;else if (lyricType === _ExsurgeDrawing.LyricType.BeginningSyllable) lyricType = _ExsurgeDrawing.LyricType.SingleSyllable;
	
	          text = text.slice(0, -1);
	        } else if (/<\\/i>$/.test(text)) {
	          // must be an elision
	          elides = true;
	        }
	      }
	
	      if (text.match(/^(?:[*†]+|i+j|\\d+)\\.?$/)) lyricType = _ExsurgeDrawing.LyricType.Directive;
	
	      var lyric = new _ExsurgeDrawing.Lyric(ctxt, text, lyricType, notation, notations, sourceIndex);
	      lyric.elidesToNext = elides;
	      if (forceConnector) lyric.setForceConnector(true);
	
	      return lyric;
	    }
	
	    // takes a string of gabc notations and creates exsurge objects out of them.
	    // returns an array of notations.
	
	  }, {
	    key: \"parseNotations\",
	    value: function parseNotations(ctxt, data, sourceIndex, insertionIndex) {
	      var _this2 = this;
	
	      // if there is no data, then this must be a text only object
	      if (!data) return [new _ExsurgeChant.TextOnly(sourceIndex, 0)];
	
	      var baseSourceIndex = sourceIndex;
	      var sourceLength = 0;
	      var notations = [];
	      var notes = [];
	      var trailingSpace = _ExsurgeDrawing.DefaultTrailingSpace;
	
	      var addToLastSourceGabc = function addToLastSourceGabc(gabc) {
	        if (notes.length > 0) {
	          notes[notes.length - 1].sourceGabc += gabc;
	        }
	      };
	      var addNotation = function addNotation(notation) {
	        // first, if we have any notes left over, we create a neume out of them
	        if (notes.length > 0) {
	          // create neume(s)
	          var neumes = _this2.createNeumesFromNotes(ctxt, notes, trailingSpace);
	          for (var i = 0; i < neumes.length; i++) {
	            notations.push(neumes[i]);
	          }notes = [];
	        }
	
	        // reset the trailing space
	        trailingSpace = _ExsurgeDrawing.DefaultTrailingSpace;
	
	        // then, if we're passed a notation, let's add it
	        // also, perform chant logic here
	        if (notation !== null) {
	          var prevNotation = notations[notations.length - 1];
	          notation.sourceIndex = sourceIndex;
	          notation.sourceGabc = match[0];
	          if (notation.isClef) {
	            ctxt.activeClef = notation;
	            if (prevNotation && prevNotation.trailingSpace.isDefault && prevNotation.isDivider) {
	              prevNotation.trailingSpace = TrailingSpaceForAccidental;
	            }
	          } else if (notation.isAccidental) {
	            ctxt.activeClef.activeAccidental = notation;
	          } else if (notation.trailingSpace.isDefault && notation instanceof Signs.Custos) {
	            notation.trailingSpace = TrailingSpaceForAccidental;
	          } else if (notation.resetsAccidentals) ctxt.activeClef.resetAccidentals();
	
	          notations.push(notation);
	        }
	      };
	
	      var regex = new RegExp(__notationsRegex.source, \"g\");
	      var match;
	
	      while (match = regex.exec(data)) {
	        sourceIndex = baseSourceIndex + match.index;
	        sourceLength = match[0].length;
	        var atom = match[0];
	
	        // handle the clefs and dividers here
	        switch (atom) {
	          case \",\":
	            addNotation(new Signs.QuarterBar());
	            break;
	          case \"`\":
	            addNotation(new Signs.Virgula());
	            break;
	          case \";\":
	            addNotation(new Signs.HalfBar());
	            break;
	          case \";1\":
	          case \";2\":
	          case \";3\":
	          case \";4\":
	          case \";5\":
	          case \";6\":
	          case \",1\":
	          case \",2\":
	          case \",3\":
	          case \",4\":
	          case \",5\":
	          case \",6\":
	            addNotation(new Signs.DominicanBar(parseInt(atom[1], 10)));
	            break;
	          case \":\":
	            addNotation(new Signs.FullBar());
	            break;
	          case \"::\":
	            addNotation(new Signs.DoubleBar());
	            break;
	          // other gregorio dividers are not supported yet
	
	          case \"c1\":
	            addNotation(ctxt.activeClef = new _ExsurgeChant.DoClef(-3, 2));
	            break;
	
	          case \"c2\":
	            addNotation(ctxt.activeClef = new _ExsurgeChant.DoClef(-1, 2));
	            break;
	
	          case \"c3\":
	            addNotation(ctxt.activeClef = new _ExsurgeChant.DoClef(1, 2));
	            break;
	
	          case \"c4\":
	            addNotation(ctxt.activeClef = new _ExsurgeChant.DoClef(3, 2));
	            break;
	
	          case \"f1\":
	            addNotation(ctxt.activeClef = new _ExsurgeChant.FaClef(-3, 2));
	            break;
	
	          case \"f2\":
	            addNotation(ctxt.activeClef = new _ExsurgeChant.FaClef(-1, 2));
	            break;
	
	          case \"f3\":
	            addNotation(ctxt.activeClef = new _ExsurgeChant.FaClef(1, 2));
	            break;
	
	          case \"f4\":
	            addNotation(ctxt.activeClef = new _ExsurgeChant.FaClef(3, 2));
	            break;
	
	          case \"cb1\":
	            addNotation(ctxt.activeClef = new _ExsurgeChant.DoClef(-3, 2, new Signs.Accidental(-4, Signs.AccidentalType.Flat)));
	            break;
	
	          case \"cb2\":
	            addNotation(ctxt.activeClef = new _ExsurgeChant.DoClef(-1, 2, new Signs.Accidental(-2, Signs.AccidentalType.Flat)));
	            break;
	
	          case \"cb3\":
	            addNotation(ctxt.activeClef = new _ExsurgeChant.DoClef(1, 2, new Signs.Accidental(0, Signs.AccidentalType.Flat)));
	            break;
	
	          case \"cb4\":
	            addNotation(ctxt.activeClef = new _ExsurgeChant.DoClef(3, 2, new Signs.Accidental(2, Signs.AccidentalType.Flat)));
	            break;
	
	          case \"z\":
	            addNotation(new _ExsurgeChant.ChantLineBreak(true));
	            break;
	          case \"Z\":
	            addNotation(new _ExsurgeChant.ChantLineBreak(false));
	            break;
	          case \"z0\":
	            addNotation(new Signs.Custos(true));
	            break;
	
	          // spacing indicators
	          case \"!\":
	            trailingSpace = 0;
	            addToLastSourceGabc(atom);
	            addNotation(null);
	            break;
	          case \" \":
	            // fixme: is this correct? logically what is the difference in gabc
	            // between putting a space between notes vs putting '//' between notes?
	            trailingSpace = TrailingSpaceMultiple(2);
	            addToLastSourceGabc(atom);
	            addNotation(null);
	            break;
	
	          default:
	            // might be a number of slashes, a custos, might be an accidental, or might be a note
	            if (atom[0] === \"/\") {
	              trailingSpace = TrailingSpaceMultiple(atom.length);
	              addToLastSourceGabc(atom);
	              addNotation(null);
	            } else if (atom.length > 1 && atom[1] === \"+\") {
	              // custos
	              var custos = new Signs.Custos();
	
	              custos.staffPosition = this.gabcHeightToExsurgeHeight(atom[0]);
	
	              addNotation(custos);
	            } else if (atom.length > 1 && /[xy#]/.test(atom[1])) {
	              var accidentalType;
	
	              switch (atom[1]) {
	                case \"y\":
	                  accidentalType = Signs.AccidentalType.Natural;
	                  break;
	                case \"#\":
	                  accidentalType = Signs.AccidentalType.Sharp;
	                  break;
	                default:
	                  accidentalType = Signs.AccidentalType.Flat;
	                  break;
	              }
	
	              var noteArray = [];
	              this.createNoteFromData(ctxt, ctxt.activeClef, atom, noteArray, sourceIndex);
	              var accidental = new Signs.Accidental(noteArray[0].staffPosition, accidentalType);
	              accidental.pitch = this.gabcHeightToExsurgePitch(ctxt.activeClef, atom[0]);
	              accidental.sourceIndex = sourceIndex;
	              accidental.sourceLength = sourceLength;
	              accidental.trailingSpace = TrailingSpaceForAccidental;
	
	              ctxt.activeClef.activeAccidental = accidental;
	
	              addNotation(accidental);
	            } else if (atom.length > 1 && atom[0] === \"{\") {
	              (function () {
	                trailingSpace = 0;
	                addNotation(null);
	                var bracketedNotations = _this2.parseNotations(ctxt, match[__notationsRegex_group_insideBraces], sourceIndex + 1);
	                // Set the width of these notations to 0
	                bracketedNotations.forEach(function (neume) {
	                  neume.hasNoWidth = true;
	                  neume.firstWithNoWidth = bracketedNotations[0];
	                });
	                notations.push.apply(notations, _toConsumableArray(bracketedNotations));
	              })();
	            } else {
	              // looks like it's a note
	              if (insertionIndex === -1) {
	                trailingSpace = TrailingSpaceMultiple(1);
	                addNotation(null);
	              }
	              this.createNoteFromData(ctxt, ctxt.activeClef, atom, notes, sourceIndex);
	              --insertionIndex;
	            }
	            break;
	        }
	      }
	
	      // finish up any remaining notes we have left
	      addNotation(null);
	
	      return notations;
	    }
	  }, {
	    key: \"createNeumesFromNotes\",
	    value: function createNeumesFromNotes(ctxt, notes, finalTrailingSpace) {
	      var neumes = [];
	      var firstNoteIndex = 0;
	      var currNoteIndex = 0;
	
	      // here we use a simple finite state machine to create the neumes from the notes
	      // createNeume is helper function which returns the next state after a neume is created
	      // (unknownState). Each state object has a neume() function and a handle() function.
	      // neume() allows us to create the neume of the state in the event that we run out
	      // of notes. handle() gives the state an opportunity to examine the currNote and
	      // determine what to do...either transition to a different neume/state, or
	      // continue building the neume of that state. handle() returns the next state
	
	      var createNeume = function createNeume(neume, includeCurrNote) {
	        var includePrevNote = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	
	        // add the notes to the neume
	        var lastNoteIndex;
	        if (includeCurrNote) lastNoteIndex = currNoteIndex;else if (includePrevNote) lastNoteIndex = currNoteIndex - 1;else lastNoteIndex = currNoteIndex - 2;
	
	        if (lastNoteIndex < 0) return;
	
	        while (firstNoteIndex <= lastNoteIndex) {
	          var note = notes[firstNoteIndex++];
	          neume.addNote(note);
	          if (note.alText) {
	            if (!neume.alText) neume.alText = [];
	            neume.alText.push(note.alText);
	            note.alText.noteIndex = firstNoteIndex - 1;
	          }
	        }
	
	        neumes.push(neume);
	
	        if (includeCurrNote === false) {
	          currNoteIndex--;
	
	          if (includePrevNote === false) currNoteIndex--;
	
	          neume.keepWithNext = true;
	          if (notes[currNoteIndex + 1].shape === _ExsurgeChant.NoteShape.Quilisma) neume.trailingSpace = 0;else {
	            neume.trailingSpace = TrailingSpaceMultiple(1);
	            neume.allowLineBreakBeforeNext = true;
	          }
	        }
	
	        return unknownState;
	      };
	
	      var unknownState = {
	        neume: function neume() {
	          return new Neumes.Punctum();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.shape === _ExsurgeChant.NoteShape.Virga) return virgaState;else if (currNote.shape === _ExsurgeChant.NoteShape.Stropha) return apostrophaState;else if (currNote.shape === _ExsurgeChant.NoteShape.Oriscus) return oriscusState;else if (currNote.shape === _ExsurgeChant.NoteShape.Inclinatum) return punctaInclinataState;else if (currNote.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Cavum) return createNeume(new Neumes.Punctum(), true);else return punctumState;
	        }
	      };
	
	      var punctumState = {
	        neume: function neume() {
	          return new Neumes.Punctum();
	        },
	        handle: function handle(currNote, prevNote, notesRemaining) {
	          if (currNote.shape || prevNote.liquescent === _ExsurgeChant.LiquescentType.Small) {
	            var neume = new Neumes.Punctum();
	            var state = createNeume(neume, false);
	            // if the current note is on a space within the staff AND the previous note is on the line below AND the previous note has a mora,
	            // then we went the trailing space at its default of intraNeumeSpacing to prevent the dot from running up into the current note.
	            // Otherwise, we want no trailing space.
	            if (currNote.staffPosition > prevNote.staffPosition && (currNote.staffPosition % 2 === 1 || prevNote.staffPosition !== currNote.staffPosition - 1 || !prevNote.morae || prevNote.morae.length === 0)) neume.trailingSpace = 0;
	            return state;
	          }
	
	          if (currNote.staffPosition > prevNote.staffPosition) {
	            if (currNote.ictus) currNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;
	            return podatusState;
	          } else if (currNote.staffPosition < prevNote.staffPosition) {
	            if (prevNote.ictus) prevNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;
	            if (currNote.shape === _ExsurgeChant.NoteShape.Inclinatum) return climacusState;else if (prevNote.staffPosition - currNote.staffPosition <= 4) {
	              return clivisState;
	            }
	          } else if (!prevNote.morae || !prevNote.morae.length) {
	            return distrophaState;
	          }
	          return createNeume(new Neumes.Punctum(), false);
	        }
	      };
	
	      var punctaInclinataState = {
	        neume: function neume() {
	          return new Neumes.PunctaInclinata();
	        },
	        handle: function handle() {
	          if (currNote.shape !== _ExsurgeChant.NoteShape.Inclinatum) return createNeume(new Neumes.PunctaInclinata(), false);else return punctaInclinataState;
	        }
	      };
	
	      var oriscusState = {
	        neume: function neume() {
	          return new Neumes.Oriscus();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.shape === _ExsurgeChant.NoteShape.Default) {
	            if (currNote.staffPosition > prevNote.staffPosition) {
	              prevNote.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Ascending;
	              return createNeume(new Neumes.PesQuassus(), true);
	            } else if (currNote.staffPosition < prevNote.staffPosition) {
	              prevNote.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Descending;
	              return createNeume(new Neumes.Clivis(), true);
	            }
	          }
	          // stand alone oriscus
	          var neume = new Neumes.Oriscus(),
	              state = createNeume(neume, false);
	          // if the current note is on a space within the staff AND the previous note is on the line below AND the previous note has a mora,
	          // then we went the trailing space at its default of intraNeumeSpacing to prevent the dot from running up into the current note.
	          // Otherwise, we want no trailing space.
	          if (currNote.staffPosition > prevNote.staffPosition && (currNote.staffPosition % 2 === 1 || prevNote.staffPosition !== currNote.staffPosition - 1 || !prevNote.morae || prevNote.morae.length === 0)) neume.trailingSpace = 0;
	          return state;
	        }
	      };
	
	      var podatusState = {
	        neume: function neume() {
	          return new Neumes.Podatus();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.staffPosition > prevNote.staffPosition) {
	            if (currNote.ictus) currNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;
	            if (prevNote.ictus) prevNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;
	
	            if (prevNote.shape === _ExsurgeChant.NoteShape.Oriscus) return salicusState;else return scandicusState;
	          } else if (currNote.staffPosition < prevNote.staffPosition) {
	            if (currNote.shape === _ExsurgeChant.NoteShape.Inclinatum) return pesSubpunctisState;else return torculusState;
	          } else return createNeume(new Neumes.Podatus(), false);
	        }
	      };
	
	      var clivisState = {
	        neume: function neume() {
	          return new Neumes.Clivis();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.shape === _ExsurgeChant.NoteShape.Default && currNote.staffPosition > prevNote.staffPosition) {
	            if (currNote.ictus) currNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;
	            return porrectusState;
	          } else return createNeume(new Neumes.Clivis(), false);
	        }
	      };
	
	      var climacusState = {
	        neume: function neume() {
	          return new Neumes.Climacus();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.shape !== _ExsurgeChant.NoteShape.Inclinatum) return createNeume(new Neumes.Climacus(), false);else return state;
	        }
	      };
	
	      var porrectusState = {
	        neume: function neume() {
	          return new Neumes.Porrectus();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.shape === _ExsurgeChant.NoteShape.Default && currNote.staffPosition < prevNote.staffPosition) return createNeume(new Neumes.PorrectusFlexus(), true);else return createNeume(new Neumes.Porrectus(), false);
	        }
	      };
	
	      var pesSubpunctisState = {
	        neume: function neume() {
	          return new Neumes.PesSubpunctis();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.shape !== _ExsurgeChant.NoteShape.Inclinatum) return createNeume(new Neumes.PesSubpunctis(), false);else return state;
	        }
	      };
	
	      var salicusState = {
	        neume: function neume() {
	          return new Neumes.Salicus();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.staffPosition < prevNote.staffPosition) return salicusFlexusState;else return createNeume(new Neumes.Salicus(), false);
	        }
	      };
	
	      var salicusFlexusState = {
	        neume: function neume() {
	          return new Neumes.SalicusFlexus();
	        },
	        handle: function handle(currNote, prevNote) {
	          return createNeume(new Neumes.SalicusFlexus(), false);
	        }
	      };
	
	      var scandicusState = {
	        neume: function neume() {
	          return new Neumes.Scandicus();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (prevNote.shape === _ExsurgeChant.NoteShape.Virga && currNote.shape === _ExsurgeChant.NoteShape.Inclinatum && currNote.staffPosition < prevNote.staffPosition) {
	            // if we get here, then it seems we have a podatus, now being followed by a climacus
	            // rather than a scandicus. react accordingly
	            return createNeume(new Neumes.Podatus(), false, false);
	          } else if (currNote.shape === _ExsurgeChant.NoteShape.Default && currNote.staffPosition < prevNote.staffPosition) return scandicusFlexusState;else return createNeume(new Neumes.Scandicus(), false);
	        }
	      };
	
	      var scandicusFlexusState = {
	        neume: function neume() {
	          return new Neumes.ScandicusFlexus();
	        },
	        handle: function handle(currNote, prevNote) {
	          return createNeume(new Neumes.ScandicusFlexus(), false);
	        }
	      };
	
	      var virgaState = {
	        neume: function neume() {
	          return new Neumes.Virga();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.shape === _ExsurgeChant.NoteShape.Inclinatum && currNote.staffPosition < prevNote.staffPosition) return climacusState;else if (currNote.shape === _ExsurgeChant.NoteShape.Virga && currNote.staffPosition === prevNote.staffPosition) return bivirgaState;else return createNeume(new Neumes.Virga(), false);
	        }
	      };
	
	      var bivirgaState = {
	        neume: function neume() {
	          return new Neumes.Bivirga();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.shape === _ExsurgeChant.NoteShape.Virga && currNote.staffPosition === prevNote.staffPosition) return createNeume(new Neumes.Trivirga(), true);else return createNeume(new Neumes.Bivirga(), false);
	        }
	      };
	
	      var apostrophaState = {
	        neume: function neume() {
	          return new Neumes.Apostropha();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.staffPosition === prevNote.staffPosition) return distrophaState;else return createNeume(new Neumes.Apostropha(), false);
	        }
	      };
	
	      var distrophaState = {
	        neume: function neume() {
	          return new Neumes.Distropha();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.staffPosition === prevNote.staffPosition) {
	            if (prevNote.morae && prevNote.morae.length) {
	              return createNeume(new Neumes.Distropha(), false);
	            } else {
	              return tristrophaState;
	            }
	          } else return createNeume(new Neumes.Apostropha(), false, false);
	        }
	      };
	
	      var tristrophaState = {
	        neume: function neume() {
	          return new Neumes.Tristropha();
	        },
	        handle: function handle(currNote, prevNote) {
	          // we only create a tristropha when the note run ends after three
	          // and the neume() function of this state is called. Otherwise
	          // we always interpret the third note to belong to the next sequence
	          // of notes.
	          //
	          // fixme: gabc allows any number of punctum/stropha in succession...
	          // is this a valid neume type? Or is it just multiple *stropha neumes
	          // in succession? Should we simplify the apostropha/distropha/
	          // tristropha classes to a generic stropha neume that can have 1 or
	          // more successive notes?
	          return createNeume(new Neumes.Distropha(), false, false);
	        }
	      };
	
	      var torculusState = {
	        neume: function neume() {
	          return new Neumes.Torculus();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.shape === _ExsurgeChant.NoteShape.Default && currNote.staffPosition > prevNote.staffPosition) {
	            var prevNoteButOne = notes[currNoteIndex - 2];
	            if (prevNoteButOne && prevNoteButOne.staffPosition - prevNote.staffPosition <= 4) {
	              if (currNote.ictus) currNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;
	              return torculusResupinusState;
	            }
	          }
	          return createNeume(new Neumes.Torculus(), false);
	        }
	      };
	
	      var torculusResupinusState = {
	        neume: function neume() {
	          return new Neumes.TorculusResupinus();
	        },
	        handle: function handle(currNote, prevNote) {
	          if (currNote.shape === _ExsurgeChant.NoteShape.Default && currNote.staffPosition < prevNote.staffPosition) return createNeume(new Neumes.TorculusResupinusFlexus(), true);else return createNeume(new Neumes.TorculusResupinus(), false);
	        }
	      };
	
	      var state = unknownState;
	
	      while (currNoteIndex < notes.length) {
	        var prevNote = currNoteIndex > 0 ? notes[currNoteIndex - 1] : null;
	        var currNote = notes[currNoteIndex];
	
	        state = state.handle(currNote, prevNote, notes.length - 1 - currNoteIndex);
	
	        // if we are on the last note, then try to create a neume if we need to.
	        if (currNoteIndex === notes.length - 1 && state !== unknownState) createNeume(state.neume(), true);
	
	        currNoteIndex++;
	      }
	
	      if (neumes.length > 0) {
	        if (!finalTrailingSpace.isDefault) {
	          neumes[neumes.length - 1].trailingSpace = finalTrailingSpace;
	          neumes[neumes.length - 1].keepWithNext = true;
	
	          if (finalTrailingSpace > 0) neumes[neumes.length - 1].allowLineBreakBeforeNext = neumes[neumes.length - 1].keepWithNext = true;
	        }
	      }
	
	      return neumes;
	    }
	
	    // appends any notes created to the notes array argument
	
	  }, {
	    key: \"createNoteFromData\",
	    value: function createNoteFromData(ctxt, clef, data, notes, sourceIndex) {
	      var note = new _ExsurgeChant.Note();
	      note.sourceIndex = sourceIndex;
	      note.sourceGabc = data;
	
	      if (data.length < 1) throw \"Invalid note data: \" + data;
	
	      if (data[0] === \"-\") {
	        // liquescent initio debilis
	        note.liquescent = _ExsurgeChant.LiquescentType.InitioDebilis;
	        data = data.substring(1);
	      }
	
	      if (data.length < 1) throw \"Invalid note data: \" + data;
	
	      // the next char is always the pitch
	      var pitch = this.gabcHeightToExsurgePitch(clef, data[0]);
	
	      if (data[0] === data[0].toUpperCase()) note.shape = _ExsurgeChant.NoteShape.Inclinatum;
	
	      note.staffPosition = this.gabcHeightToExsurgeHeight(data[0]);
	      note.pitch = pitch;
	
	      var mark;
	
	      var episemaNoteIndex = notes.length;
	      var episemaNote = note;
	
	      // process the modifiers
	      for (var i = 1; i < data.length; i++) {
	        var c = data[i];
	        var lookahead = \"\\0\";
	
	        var haveLookahead = i + 1 < data.length;
	        if (haveLookahead) lookahead = data[i + 1];
	
	        switch (c) {
	          // rhythmic markings
	          case \".\":
	            mark = null;
	
	            // gabc supports putting up to two morae on each note, by repeating the
	            // period. here, we check to see if we've already created a mora for the
	            // note, and if so, we simply force the second one to have an Above
	            // position hint. if a user decides to try to put position indicators
	            // on the double morae (such as 1 or 2), then really the behavior is
	            // not defined by gabc, so it's on the user to figure it out.
	            if (note.morae.length > 0 && notes.length) {
	              var previousNote = notes.slice(-1)[0];
	              var previousMora = note.morae.slice(-1)[0];
	              previousMora.note = previousNote;
	            }
	
	            mark = new Markings.Mora(ctxt, note);
	            if (haveLookahead && lookahead === \"1\") mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;else if (haveLookahead && lookahead === \"0\") mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;
	
	            note.morae.push(mark);
	            break;
	
	          case \"_\":
	            var episemaHadModifier = false;
	
	            mark = new Markings.HorizontalEpisema(episemaNote);
	            while (haveLookahead) {
	              if (lookahead === \"0\") mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;else if (lookahead === \"1\") mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;else if (lookahead === \"2\") mark.terminating = true;
	              // episema terminates
	              else if (lookahead === \"3\") mark.alignment = Markings.HorizontalEpisemaAlignment.Left;else if (lookahead === \"4\") mark.alignment = Markings.HorizontalEpisemaAlignment.Center;else if (lookahead === \"5\") mark.alignment = Markings.HorizontalEpisemaAlignment.Right;else break;
	
	              // the gabc definition for episemata is so convoluted...
	              // - double underscores create episemata over multiple notes.
	              // - unless the _ has a 0, 1, 3, 4, or 5 modifier, which means
	              //   another underscore puts a second episema on the same note
	              // - (when there's a 2 lookahead, then this is treated as an
	              //   unmodified underscore, so another underscore would be
	              //   added to previous notes
	              if (mark.alignment !== Markings.HorizontalEpisemaAlignment.Default && mark.positionHint !== _ExsurgeDrawing.MarkingPositionHint.Below) episemaHadModifier = true;
	
	              i++;
	              haveLookahead = i + 1 < data.length;
	
	              if (haveLookahead) lookahead = data[i + 1];
	            }
	
	            // since gabc allows consecutive underscores which is a shortcut to
	            // apply the episemata to previous notes, we keep track of that here
	            // in order to add the new episema to the correct note.
	
	            if (episemaNote) episemaNote.episemata.push(mark);
	
	            if (episemaNote === note && episemaHadModifier) episemaNote = note;else if (episemaNoteIndex >= 0 && notes.length > 0) episemaNote = notes[--episemaNoteIndex];
	
	            break;
	
	          case \"'\":
	            mark = new Markings.Ictus(ctxt, note);
	            if (haveLookahead && lookahead === \"1\") mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;else if (haveLookahead && lookahead === \"0\") mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;else if (note.shape === _ExsurgeChant.NoteShape.Virga)
	              // ictus on a virga goes above by default:
	              mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;
	
	            note.ictus = mark;
	            break;
	
	          //note shapes
	          case \"r\":
	            if (haveLookahead && /^[0-5]$/.test(lookahead)) {
	              switch (lookahead) {
	                case \"0\":
	                  note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Cavum;
	                  note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Linea;
	                  break;
	                case \"1\":
	                  note.accent = new Markings.Accent(ctxt, note, _ExsurgeDrawing.GlyphCode.AcuteAccent);
	                  break;
	                case \"2\":
	                  note.accent = new Markings.Accent(ctxt, note, _ExsurgeDrawing.GlyphCode.GraveAccent);
	                  break;
	                case \"3\":
	                  note.accent = new Markings.Accent(ctxt, note, _ExsurgeDrawing.GlyphCode.Circle);
	                  break;
	                case \"4\":
	                  note.accent = new Markings.Accent(ctxt, note, _ExsurgeDrawing.GlyphCode.Semicircle);
	                  break;
	                case \"5\":
	                  note.accent = new Markings.Accent(ctxt, note, _ExsurgeDrawing.GlyphCode.ReversedSemicircle);
	                  break;
	                default:
	              }
	              i++;
	            } else note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Cavum;
	            break;
	
	          case \"R\":
	            note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Linea;
	            break;
	
	          case \"s\":
	            if (note.shape === _ExsurgeChant.NoteShape.Stropha) {
	              // if we're already a stropha, that means this is gabc's
	              // quick stropha feature (e.g., gsss). create a new note
	              var newNote = new _ExsurgeChant.Note();
	              newNote.sourceIndex = sourceIndex + i;
	              newNote.sourceGabc = \"s\";
	              newNote.staffPosition = note.staffPosition;
	              newNote.pitch = note.pitch;
	              notes.push(note);
	              note = newNote;
	              episemaNoteIndex++; // since a new note was added, increase the index here
	            }
	
	            note.shape = _ExsurgeChant.NoteShape.Stropha;
	            break;
	
	          case \"v\":
	            if (note.shape === _ExsurgeChant.NoteShape.Virga) {
	              // if we're already a stropha, that means this is gabc's
	              // quick virga feature (e.g., gvvv). create a new note
	              var _newNote = new _ExsurgeChant.Note();
	              _newNote.sourceIndex = sourceIndex + i;
	              _newNote.sourceGabc = \"v\";
	              _newNote.staffPosition = note.staffPosition;
	              _newNote.pitch = note.pitch;
	              notes.push(note);
	              note = _newNote;
	              episemaNoteIndex++; // since a new note was added, increase the index here
	            }
	
	            note.shape = _ExsurgeChant.NoteShape.Virga;
	            break;
	
	          case \"V\":
	            note.shape = _ExsurgeChant.NoteShape.Virga;
	            note.shapeModifers |= _ExsurgeChant.NoteShapeModifiers.Reverse;
	            break;
	
	          case \"w\":
	            note.shape = _ExsurgeChant.NoteShape.Quilisma;
	            break;
	
	          case \"o\":
	            note.shape = _ExsurgeChant.NoteShape.Oriscus;
	            if (haveLookahead && lookahead === \"<\") {
	              note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Ascending;
	              i++;
	            } else if (haveLookahead && lookahead === \">\") {
	              note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Descending;
	              i++;
	            }
	            break;
	
	          case \"O\":
	            note.shape = _ExsurgeChant.NoteShape.Oriscus;
	            if (haveLookahead && lookahead === \"<\") {
	              note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Ascending | _ExsurgeChant.NoteShapeModifiers.Stemmed;
	              i++;
	            } else if (haveLookahead && lookahead === \">\") {
	              note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Descending | _ExsurgeChant.NoteShapeModifiers.Stemmed;
	              i++;
	            } else note.shapeModifiers |= _ExsurgeChant.NoteShapeModifiers.Stemmed;
	            break;
	
	          // liquescents
	          case \"~\":
	            if (note.shape === _ExsurgeChant.NoteShape.Inclinatum) note.liquescent |= _ExsurgeChant.LiquescentType.Small;else if (note.shape === _ExsurgeChant.NoteShape.Oriscus) note.liquescent |= _ExsurgeChant.LiquescentType.Large;else note.liquescent |= _ExsurgeChant.LiquescentType.Small;
	            break;
	          case \"<\":
	            note.liquescent |= _ExsurgeChant.LiquescentType.Ascending;
	            break;
	          case \">\":
	            note.liquescent |= _ExsurgeChant.LiquescentType.Descending;
	            break;
	
	          // accidentals
	          case \"x\":
	            if (note.pitch.step === _ExsurgeCore.Step.Mi) note.pitch.step = _ExsurgeCore.Step.Me;else if (note.pitch.step === _ExsurgeCore.Step.Ti) note.pitch.step = _ExsurgeCore.Step.Te;
	            break;
	          case \"y\":
	            if (note.pitch.step === _ExsurgeCore.Step.Te) note.pitch.step = _ExsurgeCore.Step.Ti;else if (note.pitch.step === _ExsurgeCore.Step.Me) note.pitch.step = _ExsurgeCore.Step.Mi;else if (note.pitch.step === _ExsurgeCore.Step.Du) note.pitch.step = _ExsurgeCore.Step.Do;else if (note.pitch.step === _ExsurgeCore.Step.Fu) note.pitch.step = _ExsurgeCore.Step.Fa;
	            break;
	          case \"#\":
	            if (note.pitch.step === _ExsurgeCore.Step.Do) note.pitch.step = _ExsurgeCore.Step.Du;else if (note.pitch.step === _ExsurgeCore.Step.Fa) note.pitch.step = _ExsurgeCore.Step.Fu;
	            break;
	
	          // gabc special item groups
	          case \"[\":
	            // read in the whole group and parse it
	            var startIndex = ++i;
	            while (i < data.length && data[i] !== \"]\") {
	              i++;
	            }this.processInstructionForNote(ctxt, note, data.substring(startIndex, i), startIndex);
	            break;
	        }
	      }
	
	      if (this.needToEndBrace && !note.braceStart && !note.braceEnd && !/[xy#]/.test(c)) {
	        note.braceEnd = new Markings.BracePoint(note, this.needToEndBrace.isAbove, this.needToEndBrace.shape, this.needToEndBrace.attachment === Markings.BraceAttachment.Left ? Markings.BraceAttachment.Right : Markings.BraceAttachment.Left);
	        note.braceEnd.automatic = true;
	        delete this.needToEndBrace;
	      }
	
	      notes.push(note);
	    }
	
	    // an instruction in this context is referring to a special gabc coding found after
	    // notes between ['s and ]'s. choral signs and braces fall into this
	    // category.
	    //
	    // currently only brace instructions are supported here!
	
	  }, {
	    key: \"processInstructionForNote\",
	    value: function processInstructionForNote(ctxt, note, instruction, sourceIndexOffset) {
	      var results = instruction.match(__bracketedCommandRegex);
	      if (results === null) return;
	      var cmd = results[1];
	      var data = results[2];
	      switch (cmd) {
	        case \"cs\":
	          note.choralSign = new _ExsurgeDrawing.ChoralSign(ctxt, data, note, note.sourceIndex + sourceIndexOffset, instruction.length);
	          return;
	        case \"alt\":
	          note.alText = new _ExsurgeDrawing.AboveLinesText(ctxt, data, note, note.sourceIndex + sourceIndexOffset, instruction.length);
	          return;
	      }
	
	      results = instruction.match(__braceSpecRegex);
	
	      if (results === null) return;
	
	      // see the comments at the definition of __braceSpecRegex for the
	      // capturing groups
	      var above = results[1] === \"o\";
	      var shape = Markings.BraceShape.CurlyBrace; // default
	
	      switch (results[2]) {
	        case \"b\":
	          shape = Markings.BraceShape.RoundBrace;
	          break;
	        case \"cb\":
	          shape = Markings.BraceShape.CurlyBrace;
	          break;
	        case \"cba\":
	          shape = Markings.BraceShape.AccentedCurlyBrace;
	          break;
	      }
	
	      var attachmentPoint = results[3] === \"1\" ? Markings.BraceAttachment.Left : Markings.BraceAttachment.Right;
	
	      if (results[4] === \"{\" || results[5]) note.braceStart = new Markings.BracePoint(note, above, shape, attachmentPoint);else note.braceEnd = new Markings.BracePoint(note, above, shape, attachmentPoint);
	
	      // just have the next note end a brace that uses length;
	      if (results[5]) {
	        note.braceStart.automatic = true;
	        this.needToEndBrace = note.braceStart;
	      }
	    }
	
	    // takes raw gabc text source and parses it into words. For example, passing
	    // in a string of \"me(f.) (,) ma(fff)num(d!ewf) tu(fgF'E)am,(f.)\" would return
	    // an array of four strings: [\"me(f.)\", \"(,)\", \"ma(fff)num(d!ewf)\", \"tu(fgF'E)am,(f.)\"]
	
	  }, {
	    key: \"splitWords\",
	    value: function splitWords(gabcNotations) {
	      // split the notations on whitespace boundaries, as long as the space
	      // immediately follows a set of parentheses. Prior to doing that, we replace
	      // all whitespace with spaces, which prevents tabs and newlines from ending
	      // up in the notation data.
	      gabcNotations = gabcNotations
	      // .trim()
	      // .replace(/\\s/g, \" \")
	      .replace(/\\)\\s(?=[^\\)]*(?:\\(|$))/g, \")\
\");
	      return gabcNotations.split(/\
/g);
	    }
	  }, {
	    key: \"parseSource\",
	    value: function parseSource(gabcSource) {
	      return this.parseWords(this.splitWords(gabcSource));
	    }
	
	    // gabcWords is an array of strings, e.g., the result of splitWords above
	
	  }, {
	    key: \"parseWords\",
	    value: function parseWords(gabcWords) {
	      var words = [];
	
	      for (var i = 0; i < gabcWords.length; i++) {
	        words.push(this.parseWord(gabcWords[i]));
	      }return words;
	    }
	
	    // returns an array of objects, each of which has the following properties
	    //  - notations (string)
	    //  - lyrics (array of strings)
	
	  }, {
	    key: \"parseWord\",
	    value: function parseWord(gabcWord) {
	      var syllables = [];
	      var matches = [];
	
	      syllables.wordLength = gabcWord.length;
	
	      while (match = __syllablesRegex.exec(gabcWord)) {
	        matches.push(match);
	      }for (var j = 0; j < matches.length; j++) {
	        var match = matches[j];
	
	        var lyrics = match[1].trim().split(\"|\");
	        var notations = match[2];
	
	        syllables.push({
	          notations: notations,
	          lyrics: lyrics
	        });
	      }
	
	      return syllables;
	    }
	
	    // returns pitch
	
	  }, {
	    key: \"gabcHeightToExsurgeHeight\",
	    value: function gabcHeightToExsurgeHeight(gabcHeight) {
	      return gabcHeight.toLowerCase().charCodeAt(0) - \"a\".charCodeAt(0) - 6;
	    }
	
	    // returns pitch
	
	  }, {
	    key: \"gabcHeightToExsurgePitch\",
	    value: function gabcHeightToExsurgePitch(clef, gabcHeight) {
	      var exsurgeHeight = this.gabcHeightToExsurgeHeight(gabcHeight);
	
	      var pitch = clef.staffPositionToPitch(exsurgeHeight);
	
	      return pitch;
	    }
	  }]);

	  return Gabc;
	}();

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	exports.Virga = exports.Tristropha = exports.TorculusResupinusFlexus = exports.TorculusResupinus = exports.Torculus = exports.ScandicusFlexus = exports.Scandicus = exports.SalicusFlexus = exports.Salicus = exports.Punctum = exports.PunctaInclinata = exports.PorrectusFlexus = exports.Porrectus = exports.Podatus = exports.PesSubpunctis = exports.PesQuassus = exports.Oriscus = exports.Distropha = exports.Clivis = exports.Climacus = exports.Trivirga = exports.Bivirga = exports.Apostropha = exports.Neume = undefined;
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //
	// Author(s):
	// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
	//
	// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the \"Software\"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	//
	
	var _ExsurgeChant = __webpack_require__(8);
	
	var _ExsurgeDrawing = __webpack_require__(4);
	
	var _ExsurgeGlyphs = __webpack_require__(3);
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }
	
	var NeumeBuilder = function () {
	  function NeumeBuilder(ctxt, neume) {
	    var startingX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	
	    _classCallCheck(this, NeumeBuilder);
	
	    this.ctxt = ctxt;
	    this.neume = neume;
	    this.x = startingX;
	    this.lastNote = null;
	    this.lineIsHanging = false;
	    this.minX = 0;
	  }
	
	  // used to start a hanging line on the left of the next note
	
	
	  _createClass(NeumeBuilder, [{
	    key: \"lineFrom\",
	    value: function lineFrom(note) {
	      var previousNotation = this.ctxt.notations[this.ctxt.currNotationIndex - 1];
	      if (this.x === 0 && previousNotation && previousNotation.notes && previousNotation.trailingSpace === 0) {
	        this.lastNote = previousNotation.notes.slice(-1)[0];
	        this.minX = -this.ctxt.neumeLineWeight;
	      } else {
	        this.lastNote = note;
	        this.lineIsHanging = true;
	      }
	      return this;
	    }
	
	    // add a note, with a connecting line on the left if we have one
	
	  }, {
	    key: \"noteAt\",
	    value: function noteAt(note, glyph) {
	      var withLineTo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
	
	      if (!note) throw \"NeumeBuilder.noteAt: note must be a valid note\";
	
	      if (!glyph) throw \"NeumeBuilder.noteAt: glyph must be a valid glyph code\";
	
	      note.setGlyph(this.ctxt, glyph);
	      var noteAlignsRight = note.glyphVisualizer.align === \"right\";
	
	      var needsLine = withLineTo && this.lastNote !== null && (this.lineIsHanging || this.lastNote.glyphVisualizer && this.lastNote.glyphVisualizer.align === \"right\" || Math.abs(this.lastNote.staffPosition - note.staffPosition) > 1);
	
	      if (needsLine) {
	        var line = new _ExsurgeDrawing.NeumeLineVisualizer(this.ctxt, this.lastNote, note, this.lineIsHanging);
	        this.neume.addVisualizer(line);
	        line.bounds.x = Math.max(this.minX, this.x - line.bounds.width);
	
	        if (!noteAlignsRight) this.x = line.bounds.x;
	      }
	
	      var xOffset = 0;
	      if (note.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Linea) {
	        var linea = new _ExsurgeDrawing.LineaVisualizer(this.ctxt, note);
	        this.neume.addVisualizer(linea);
	        note.origin.x += linea.origin.x;
	        xOffset = linea.origin.x;
	      }
	
	      // if this is the first note of a right aligned glyph (probably an initio debilis),
	      // then there's nothing to worry about. but if it's not then first, then this
	      // subtraction will right align it visually
	      if (noteAlignsRight && this.lastNote) note.bounds.x = this.x - note.bounds.width;else {
	        note.bounds.x = this.x + xOffset;
	        this.x += note.bounds.width + xOffset;
	      }
	
	      this.neume.addVisualizer(note);
	
	      this.lastNote = note;
	      this.lineIsHanging = false;
	
	      return this;
	    }
	
	    // a special form of noteAdd that creates a virga
	    // uses a punctum cuadratum and a line rather than the virga glyphs
	
	  }, {
	    key: \"virgaAt\",
	    value: function virgaAt(note) {
	      var withLineTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	      // add the punctum for the virga
	      this.noteAt(note, _ExsurgeDrawing.GlyphCode.PunctumQuadratum);
	
	      // add a line for the virga
	      var line = new _ExsurgeDrawing.VirgaLineVisualizer(this.ctxt, note);
	      this.x -= line.bounds.width;
	      if (note.shapeModifers & _ExsurgeChant.NoteShapeModifiers.Reverse) {
	        line.bounds.x = 0;
	      } else {
	        line.bounds.x = this.x;
	      }
	      this.neume.addVisualizer(line);
	
	      this.lastNote = note;
	      this.lineIsHanging = false;
	
	      return this;
	    }
	  }, {
	    key: \"advanceBy\",
	    value: function advanceBy(x) {
	      this.lastNote = null;
	      this.lineIsHanging = false;
	
	      this.x += x;
	
	      return this;
	    }
	
	    // for terminating hanging lines with no lower notes
	
	  }, {
	    key: \"withLineEndingAt\",
	    value: function withLineEndingAt(note) {
	      if (this.lastNote === null) return;
	
	      var line = new _ExsurgeDrawing.NeumeLineVisualizer(this.ctxt, this.lastNote, note, true);
	      this.neume.addVisualizer(line);
	      this.x -= line.bounds.width;
	      line.bounds.x = this.x;
	
	      this.neume.addVisualizer(line);
	
	      this.lastNote = note;
	
	      return this;
	    }
	  }, {
	    key: \"withPodatus\",
	    value: function withPodatus(lowerNote, upperNote) {
	      var upperGlyph;
	      var lowerGlyph;
	
	      if (lowerNote.liquescent === _ExsurgeChant.LiquescentType.InitioDebilis) {
	        // liquescent upper note or not?
	        if (upperNote.liquescent === _ExsurgeChant.LiquescentType.None) upperGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;else upperGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;
	
	        lowerGlyph = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;
	      } else if (upperNote.liquescent & _ExsurgeChant.LiquescentType.Small) {
	        lowerGlyph = _ExsurgeDrawing.GlyphCode.BeginningAscLiquescent;
	        upperGlyph = _ExsurgeDrawing.GlyphCode.TerminatingAscLiquescent;
	      } else if (upperNote.liquescent & _ExsurgeChant.LiquescentType.Ascending) {
	        lowerGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	        upperGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;
	      } else if (upperNote.liquescent & _ExsurgeChant.LiquescentType.Descending) {
	        lowerGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	        upperGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;
	      } else {
	        // standard shape
	        lowerGlyph = _ExsurgeDrawing.GlyphCode.PodatusLower;
	        upperGlyph = _ExsurgeDrawing.GlyphCode.PodatusUpper;
	      }
	
	      // allow a quilisma pes
	      if (lowerNote.shape === _ExsurgeChant.NoteShape.Quilisma) lowerGlyph = _ExsurgeDrawing.GlyphCode.Quilisma;
	
	      this.noteAt(lowerNote, lowerGlyph).noteAt(upperNote, upperGlyph);
	
	      // make sure we don't have lines connected to the podatus
	      this.lastNote = null;
	
	      return this;
	    }
	  }, {
	    key: \"withClivis\",
	    value: function withClivis(upper, lower) {
	      var lowerGlyph;
	
	      if (upper.shape === _ExsurgeChant.NoteShape.Oriscus) this.noteAt(upper, _ExsurgeDrawing.GlyphCode.OriscusDes, false);else this.lineFrom(lower).noteAt(upper, _ExsurgeDrawing.GlyphCode.PunctumQuadratum);
	
	      if (lower.liquescent & _ExsurgeChant.LiquescentType.Small) {
	        lowerGlyph = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;
	      } else if (lower.liquescent === _ExsurgeChant.LiquescentType.Ascending) lowerGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (lower.liquescent === _ExsurgeChant.LiquescentType.Descending) lowerGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else lowerGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	
	      this.noteAt(lower, lowerGlyph);
	
	      // make sure we don't have lines connected to the clivis
	      this.lastNote = null;
	
	      return this;
	    }
	
	    // lays out a sequence of notes that are inclinata (e.g., climacus, pes subpunctis)
	
	  }, {
	    key: \"withInclinata\",
	    value: function withInclinata(notes) {
	      var staffPosition = notes[0].staffPosition,
	          prevStaffPosition = notes[0].staffPosition;
	
	      // it is important to advance by the width of the inclinatum glyph itself
	      // rather than by individual note widths, so that any liquescents are spaced
	      // the same as non-liquscents
	      var advanceWidth = _ExsurgeGlyphs.Glyphs.PunctumInclinatum.bounds.width * this.ctxt.glyphScaling;
	
	      // now add all the punctum inclinatum
	      for (var i = 0; i < notes.length; i++, prevStaffPosition = staffPosition) {
	        var note = notes[i];
	
	        if (note.liquescent & _ExsurgeChant.LiquescentType.Small) note.setGlyph(this.ctxt, _ExsurgeDrawing.GlyphCode.PunctumInclinatumLiquescent);else if (note.liquescent & _ExsurgeChant.LiquescentType.Large)
	          // fixme: is the large inclinatum liquescent the same as the apostropha?
	          note.setGlyph(this.ctxt, _ExsurgeDrawing.GlyphCode.Stropha);
	          // fixme: some climaci in the new chant books end with a punctum quadratum
	          // (see, for example, the antiphon \"Sancta Maria\" for October 7).
	        else note.setGlyph(this.ctxt, _ExsurgeDrawing.GlyphCode.PunctumInclinatum);
	
	        staffPosition = note.staffPosition;
	
	        var multiple = Math.abs(prevStaffPosition - staffPosition);
	        switch (multiple) {
	          case 0:
	            multiple = 1.1;
	            break;
	          default:
	            multiple *= 2 / 3;
	            break;
	        }
	
	        if (i > 0) this.x += advanceWidth * multiple;
	
	        note.bounds.x = this.x;
	
	        this.neume.addVisualizer(note);
	      }
	
	      return this;
	    }
	  }, {
	    key: \"withPorrectusSwash\",
	    value: function withPorrectusSwash(start, end) {
	      var needsLine = this.lastNote !== null && (this.lineIsHanging || this.lastNote.glyphVisualizer && this.lastNote.glyphVisualizer.align === \"right\" || Math.abs(this.lastNote.staffPosition - start.staffPosition) > 1);
	
	      if (needsLine) {
	        var line = new _ExsurgeDrawing.NeumeLineVisualizer(this.ctxt, this.lastNote, start, this.lineIsHanging);
	        this.x = Math.max(this.minX, this.x - line.bounds.width);
	        line.bounds.x = this.x;
	        this.neume.addVisualizer(line);
	      }
	
	      var glyph;
	
	      switch (start.staffPosition - end.staffPosition) {
	        case 1:
	          glyph = _ExsurgeDrawing.GlyphCode.Porrectus1;
	          break;
	        case 2:
	          glyph = _ExsurgeDrawing.GlyphCode.Porrectus2;
	          break;
	        case 3:
	          glyph = _ExsurgeDrawing.GlyphCode.Porrectus3;
	          break;
	        case 4:
	          glyph = _ExsurgeDrawing.GlyphCode.Porrectus4;
	          break;
	        default:
	          // fixme: should we generate an error here?
	          glyph = _ExsurgeDrawing.GlyphCode.None;
	          break;
	      }
	
	      start.setGlyph(this.ctxt, glyph);
	      start.bounds.x = this.x;
	
	      // the second glyph does not draw anything, but it still has logical importance for the editing
	      // environment...it can respond to changes which will then change the swash glyph of the first.
	      end.setGlyph(this.ctxt, _ExsurgeDrawing.GlyphCode.None);
	
	      this.x = start.bounds.right();
	      end.bounds.x = this.x - end.bounds.width;
	
	      this.neume.addVisualizer(start);
	      this.neume.addVisualizer(end);
	
	      this.lastNote = end;
	      this.lineIsHanging = false;
	
	      return this;
	    }
	  }]);
	
	  return NeumeBuilder;
	}();
	
	/*
	 * Neumes base class
	 */
	
	
	var Neume = exports.Neume = function (_ChantNotationElement) {
	  _inherits(Neume, _ChantNotationElement);
	
	  function Neume() {
	    var notes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	
	    _classCallCheck(this, Neume);
	
	    var _this = _possibleConstructorReturn(this, (Neume.__proto__ || Object.getPrototypeOf(Neume)).call(this));
	
	    _this.isNeume = true; // poor man's reflection
	    _this.notes = notes;
	
	    for (var i = 0; i < notes.length; i++) {
	      notes[i].neume = _this;
	    }return _this;
	  }
	
	  _createClass(Neume, [{
	    key: \"addNote\",
	    value: function addNote(note) {
	      note.neume = this;
	      this.notes.push(note);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Neume.prototype.__proto__ || Object.getPrototypeOf(Neume.prototype), \"performLayout\", this).call(this, ctxt);
	    }
	  }, {
	    key: \"finishLayout\",
	    value: function finishLayout(ctxt) {
	      this.ledgerLines = this.requiresLedgerLine();
	
	      // allow subclasses an opportunity to position their own markings...
	      this.positionMarkings();
	
	      // layout the markings of the notes
	      for (var i = 0; i < this.notes.length; i++) {
	        var note = this.notes[i];
	        var j;
	
	        for (j = 0; j < note.episemata.length; j++) {
	          note.episemata[j].performLayout(ctxt);
	          this.addVisualizer(note.episemata[j]);
	        }
	
	        for (j = 0; j < note.morae.length; j++) {
	          note.morae[j].performLayout(ctxt);
	          this.addVisualizer(note.morae[j]);
	        }
	
	        // if the note has an ictus, then add it here
	        if (note.ictus) {
	          note.ictus.performLayout(ctxt);
	          this.addVisualizer(note.ictus);
	        }
	
	        if (note.accent) {
	          note.accent.performLayout(ctxt);
	          this.addVisualizer(note.accent);
	        }
	
	        if (note.choralSign) {
	          note.choralSign.performLayout(ctxt);
	          this.addVisualizer(note.choralSign);
	        }
	
	        // braces are handled by the chant line, so we don't mess with them here
	        // this is because brace size depends on chant line logic (neume spacing,
	        // justification, etc.) so they are considered chant line level
	        // markings rather than note level markings
	      }
	
	      this.origin.x = this.notes[0].origin.x;
	      this.origin.y = this.notes[0].origin.y;
	
	      _get(Neume.prototype.__proto__ || Object.getPrototypeOf(Neume.prototype), \"finishLayout\", this).call(this, ctxt);
	    }
	  }, {
	    key: \"requiresLedgerLine\",
	    value: function requiresLedgerLine() {
	      var firstAbove = false,
	          needsAbove = false,
	          firstBelow = false,
	          needsBelow = false,
	
	      // isPorrectus = false,
	      result = [];
	
	      if (!this.notes) return result;
	
	      for (var i = 0; i < this.notes.length; ++i) {
	        var note = this.notes[i];
	        var staffPosition = note.staffPosition;
	        if (staffPosition >= 4) {
	          needsAbove = needsAbove || staffPosition >= 5;
	          if (firstAbove === false) firstAbove = Math.max(0, i - 1);
	          if (staffPosition >= 5) continue;
	        } else if (staffPosition <= -4) {
	          needsBelow = needsBelow || staffPosition <= -5;
	          if (firstBelow === false) firstBelow = Math.max(0, i - 1);
	          if (staffPosition <= -5) continue;
	        }
	        if (needsAbove || needsBelow) {
	          var endI = i; // Math.abs(staffPosition) >= 4? i : i - 1;
	          result.push({
	            element: this.notes[firstAbove || firstBelow || 0],
	            endElem: this.notes[endI],
	            staffPosition: needsAbove ? 5 : -5
	          });
	          firstAbove = firstBelow = needsAbove = needsBelow = false;
	        }
	        // isPorrectus = /^Porrectus\\d$/.test(note.glyphVisualizer.glyphCode);
	      }
	      if (needsAbove || needsBelow) {
	        result.push({
	          element: this.notes[firstAbove || firstBelow || 0],
	          endElem: this.notes[this.notes.length - 1],
	          staffPosition: needsAbove ? 5 : -5
	        });
	      }
	      return result;
	    }
	  }, {
	    key: \"resetDependencies\",
	    value: function resetDependencies() {}
	  }, {
	    key: \"build\",
	    value: function build(ctxt) {
	      return new NeumeBuilder(ctxt, this);
	    }
	  }, {
	    key: \"positionEpisemata\",
	    value: function positionEpisemata(note, position) {
	      var i;
	      for (i = 0; i < note.episemata.length; i++) {
	        if (note.episemata[i].positionHint === _ExsurgeDrawing.MarkingPositionHint.Default) note.episemata[i].positionHint = position;
	      }if (note.choralSign) note.choralSign.positionHint = position;
	      return note.episemata.length;
	    }
	  }, {
	    key: \"positionEpisemataAbove\",
	    value: function positionEpisemataAbove(note) {
	      return this.positionEpisemata(note, _ExsurgeDrawing.MarkingPositionHint.Above);
	    }
	  }, {
	    key: \"positionEpisemataBelow\",
	    value: function positionEpisemataBelow(note) {
	      return this.positionEpisemata(note, _ExsurgeDrawing.MarkingPositionHint.Below);
	    }
	  }, {
	    key: \"positionPodatusEpisemata\",
	    value: function positionPodatusEpisemata(bottomNote, topNote) {
	      // 1. episema on lower note by default be below, upper note above
	      this.positionEpisemataBelow(bottomNote);
	      this.positionEpisemataAbove(topNote);
	      if (topNote.ictus) {
	        topNote.ictus.positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;
	      }
	    }
	  }, {
	    key: \"positionInclinataMorae\",
	    value: function positionInclinataMorae(notes) {
	      notes = notes.slice(-2);
	      if (notes.length < 2 || notes[1].staffPosition > notes[0].staffPosition) return;
	      var bottomNote = notes[1],
	          topNote = notes[0],
	          mark;
	
	      // The mora on the second (lower) note should be below the punctum,
	      // if the punctum is on a line and the previous punctum is in the space above.
	      if (Math.abs(bottomNote.staffPosition % 2) === 1 && topNote.staffPosition - bottomNote.staffPosition === 1 && bottomNote.morae.length > 0) {
	        mark = bottomNote.morae.slice(-1)[0];
	        if (mark.positionHint === _ExsurgeDrawing.MarkingPositionHint.Default) mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;
	      }
	    }
	  }, {
	    key: \"positionPodatusMorae\",
	    value: function positionPodatusMorae(bottomNote, topNote) {
	      var mark;
	
	      // The mora on the first (lower) note should be below it,
	      // if it is on a line.
	      if (Math.abs(bottomNote.staffPosition % 2) === 1) {
	        if (bottomNote.morae.length === 1) {
	          mark = bottomNote.morae[0];
	        } else if (topNote.morae.length > 1) {
	          mark = topNote.morae[0];
	        }
	        if (mark && mark.positionHint === _ExsurgeDrawing.MarkingPositionHint.Default) mark.positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;
	      }
	
	      // if there is a mora on the first note but not on the second, and the neume
	      // continues with a punctum higher than the second note, we need to adjust
	      // the space after the neume so that it follows immediately with no gap
	      if (bottomNote.morae.length > 0 && topNote.morae.length === 0) {
	        bottomNote.morae[0].ignoreBounds = true;
	      }
	    }
	    // for any subclasses that begin with a podatus, they can call this from their own positionMarkings()
	
	  }, {
	    key: \"positionPodatusMarkings\",
	    value: function positionPodatusMarkings(bottomNote, topNote) {
	      this.positionPodatusEpisemata(bottomNote, topNote);
	      this.positionPodatusMorae(bottomNote, topNote);
	    }
	
	    // just like a clivis, but the first note of the three also works like the second note of the clivis:
	    // episema below, unless the middle note also has an episema
	
	  }, {
	    key: \"positionTorculusMarkings\",
	    value: function positionTorculusMarkings(firstNote, secondNote, thirdNote) {
	      var hasTopEpisema = this.positionClivisMarkings(secondNote, thirdNote);
	      hasTopEpisema = this.positionEpisemata(firstNote, hasTopEpisema ? _ExsurgeDrawing.MarkingPositionHint.Above : _ExsurgeDrawing.MarkingPositionHint.Below) && hasTopEpisema;
	      return hasTopEpisema;
	    }
	  }, {
	    key: \"positionClivisMorae\",
	    value: function positionClivisMorae(firstNote, secondNote) {
	      // 1. second note of a clivis that ends on a line and goes down one step has its mora below:
	      var morae = firstNote.morae.concat(secondNote.morae);
	      if (secondNote.morae.length && firstNote.staffPosition - secondNote.staffPosition === 1 && Math.abs(secondNote.staffPosition % 2) === 1) {
	        morae.slice(-1)[0].positionHint = _ExsurgeDrawing.MarkingPositionHint.Below;
	      }
	    }
	  }, {
	    key: \"positionClivisEpisemata\",
	    value: function positionClivisEpisemata(firstNote, secondNote) {
	      var hasTopEpisema = this.positionEpisemataAbove(firstNote);
	      this.positionEpisemata(secondNote, hasTopEpisema ? _ExsurgeDrawing.MarkingPositionHint.Above : _ExsurgeDrawing.MarkingPositionHint.Below);
	      return hasTopEpisema;
	    }
	  }, {
	    key: \"positionClivisMarkings\",
	    value: function positionClivisMarkings(firstNote, secondNote) {
	      this.positionClivisMorae(firstNote, secondNote);
	      return this.positionClivisEpisemata(firstNote, secondNote);
	    }
	  }, {
	    key: \"positionPorrectusMarkings\",
	    value: function positionPorrectusMarkings(firstNote, secondNote, thirdNote) {
	      // episemata on first and second note work like a clivis,
	      // the second note should have its episema below, unless the first note also has an episema.
	      this.positionClivisEpisemata(firstNote, secondNote);
	      this.positionPodatusMarkings(secondNote, thirdNote);
	    }
	  }, {
	    key: \"positionPorrectusFlexusMarkings\",
	    value: function positionPorrectusFlexusMarkings(first, second, third, fourth) {
	      var hasTopEpisema = this.positionEpisemataAbove(first);
	      hasTopEpisema = this.positionClivisMarkings(third, fourth) || hasTopEpisema;
	      this.positionEpisemata(second, hasTopEpisema ? _ExsurgeDrawing.MarkingPositionHint.Above : _ExsurgeDrawing.MarkingPositionHint.Below);
	    }
	
	    // subclasses can override this in order to correctly place markings in a neume specific way
	
	  }, {
	    key: \"positionMarkings\",
	    value: function positionMarkings() {}
	  }]);
	
	  return Neume;
	}(_ExsurgeDrawing.ChantNotationElement);
	
	/*
	 * Apostropha
	 */
	
	
	var Apostropha = exports.Apostropha = function (_Neume) {
	  _inherits(Apostropha, _Neume);
	
	  function Apostropha() {
	    _classCallCheck(this, Apostropha);
	
	    return _possibleConstructorReturn(this, (Apostropha.__proto__ || Object.getPrototypeOf(Apostropha)).apply(this, arguments));
	  }
	
	  _createClass(Apostropha, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      var positionHint = _ExsurgeDrawing.MarkingPositionHint.Above;
	
	      // logic here is this: if first episema is default position, place it above.
	      // then place the second one (if there is one) opposite of the first.
	      for (var i = 0; i < this.notes[0].episemata.length; i++) {
	        if (this.notes[0].episemata[i].positionHint === _ExsurgeDrawing.MarkingPositionHint.Default) this.notes[0].episemata[i].positionHint = positionHint;else positionHint = this.notes[0].episemata[i].positionHint;
	
	        // now place the next one in the opposite position
	        positionHint = positionHint === _ExsurgeDrawing.MarkingPositionHint.Above ? _ExsurgeDrawing.MarkingPositionHint.Below : _ExsurgeDrawing.MarkingPositionHint.Above;
	      }
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Apostropha.prototype.__proto__ || Object.getPrototypeOf(Apostropha.prototype), \"performLayout\", this).call(this, ctxt);
	
	      this.build(ctxt).noteAt(this.notes[0], Apostropha.getNoteGlyphCode(this.notes[0]));
	
	      this.finishLayout(ctxt);
	    }
	  }], [{
	    key: \"getNoteGlyphCode\",
	    value: function getNoteGlyphCode(note) {
	      if (note.shape === _ExsurgeChant.NoteShape.Stropha) return _ExsurgeDrawing.GlyphCode.Stropha;
	
	      if (note.liquescent & _ExsurgeChant.LiquescentType.Ascending) return _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (note.liquescent & _ExsurgeChant.LiquescentType.Descending) return _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;
	
	      if (note.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Cavum) return _ExsurgeDrawing.GlyphCode.PunctumCavum;
	
	      return _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	    }
	  }]);
	
	  return Apostropha;
	}(Neume);
	
	/*
	 * Bivirga
	 *
	 * For simplicity in implementation, Bivirga's have two notes in the object
	 * structure. These technically must be the same pitch though.
	 */
	
	
	var Bivirga = exports.Bivirga = function (_Neume2) {
	  _inherits(Bivirga, _Neume2);
	
	  function Bivirga() {
	    _classCallCheck(this, Bivirga);
	
	    return _possibleConstructorReturn(this, (Bivirga.__proto__ || Object.getPrototypeOf(Bivirga)).apply(this, arguments));
	  }
	
	  _createClass(Bivirga, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionEpisemataAbove(this.notes[0]);
	      this.positionEpisemataAbove(this.notes[1]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Bivirga.prototype.__proto__ || Object.getPrototypeOf(Bivirga.prototype), \"performLayout\", this).call(this, ctxt);
	
	      this.build(ctxt).virgaAt(this.notes[0]).advanceBy(ctxt.intraNeumeSpacing).virgaAt(this.notes[1]);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Bivirga;
	}(Neume);
	
	/*
	 * Trivirga
	 *
	 * For simplicity in implementation, Trivirga's have three notes in the object
	 * structure. These technically must be the same pitch though.
	 */
	
	
	var Trivirga = exports.Trivirga = function (_Neume3) {
	  _inherits(Trivirga, _Neume3);
	
	  function Trivirga() {
	    _classCallCheck(this, Trivirga);
	
	    return _possibleConstructorReturn(this, (Trivirga.__proto__ || Object.getPrototypeOf(Trivirga)).apply(this, arguments));
	  }
	
	  _createClass(Trivirga, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionEpisemataAbove(this.notes[0]);
	      this.positionEpisemataAbove(this.notes[1]);
	      this.positionEpisemataAbove(this.notes[2]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Trivirga.prototype.__proto__ || Object.getPrototypeOf(Trivirga.prototype), \"performLayout\", this).call(this, ctxt);
	
	      this.build(ctxt).virgaAt(this.notes[0]).advanceBy(ctxt.intraNeumeSpacing).virgaAt(this.notes[1]).advanceBy(ctxt.intraNeumeSpacing).virgaAt(this.notes[2]);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Trivirga;
	}(Neume);
	
	/*
	 * Climacus
	 */
	
	
	var Climacus = exports.Climacus = function (_Neume4) {
	  _inherits(Climacus, _Neume4);
	
	  function Climacus() {
	    _classCallCheck(this, Climacus);
	
	    return _possibleConstructorReturn(this, (Climacus.__proto__ || Object.getPrototypeOf(Climacus)).apply(this, arguments));
	  }
	
	  _createClass(Climacus, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      for (var i = 0; i < this.notes.length; i++) {
	        this.positionEpisemataAbove(this.notes[i]);
	      }
	      this.positionInclinataMorae(this.notes);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Climacus.prototype.__proto__ || Object.getPrototypeOf(Climacus.prototype), \"performLayout\", this).call(this, ctxt);
	
	      this.build(ctxt).virgaAt(this.notes[0]).advanceBy(ctxt.intraNeumeSpacing).withInclinata(this.notes.slice(1));
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Climacus;
	}(Neume);
	
	/*
	 * Clivis
	 */
	
	
	var Clivis = exports.Clivis = function (_Neume5) {
	  _inherits(Clivis, _Neume5);
	
	  function Clivis() {
	    _classCallCheck(this, Clivis);
	
	    return _possibleConstructorReturn(this, (Clivis.__proto__ || Object.getPrototypeOf(Clivis)).apply(this, arguments));
	  }
	
	  _createClass(Clivis, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionClivisMarkings(this.notes[0], this.notes[1]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Clivis.prototype.__proto__ || Object.getPrototypeOf(Clivis.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var upper = this.notes[0];
	      var lower = this.notes[1];
	
	      this.build(ctxt).withClivis(upper, lower);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Clivis;
	}(Neume);
	
	/*
	 * Distropha
	 *
	 * For simplicity in implementation, Distropha's have two notes in the object
	 * structure. These technically must be the same pitch though (like Bivirga).
	 */
	
	
	var Distropha = exports.Distropha = function (_Neume6) {
	  _inherits(Distropha, _Neume6);
	
	  function Distropha() {
	    _classCallCheck(this, Distropha);
	
	    return _possibleConstructorReturn(this, (Distropha.__proto__ || Object.getPrototypeOf(Distropha)).apply(this, arguments));
	  }
	
	  _createClass(Distropha, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionEpisemataAbove(this.notes[0]);
	      this.positionEpisemataAbove(this.notes[1]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Distropha.prototype.__proto__ || Object.getPrototypeOf(Distropha.prototype), \"performLayout\", this).call(this, ctxt);
	      var glyphCodes = this.notes.map(function (note) {
	        return Apostropha.getNoteGlyphCode(note);
	      });
	      var glyphAdvance = ctxt.intraNeumeSpacing;
	      glyphCodes.slice(0, 2).forEach(function (glyphCode) {
	        if (glyphCode === _ExsurgeDrawing.GlyphCode.Stropha) glyphAdvance -= ctxt.intraNeumeSpacing / 4;
	      });
	
	      this.build(ctxt).noteAt(this.notes[0], glyphCodes[0]).advanceBy(glyphAdvance).noteAt(this.notes[1], glyphCodes[1]);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Distropha;
	}(Neume);
	
	/*
	 * Oriscus
	 */
	
	
	var Oriscus = exports.Oriscus = function (_Neume7) {
	  _inherits(Oriscus, _Neume7);
	
	  function Oriscus() {
	    _classCallCheck(this, Oriscus);
	
	    return _possibleConstructorReturn(this, (Oriscus.__proto__ || Object.getPrototypeOf(Oriscus)).apply(this, arguments));
	  }
	
	  _createClass(Oriscus, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionEpisemataAbove(this.notes[0]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Oriscus.prototype.__proto__ || Object.getPrototypeOf(Oriscus.prototype), \"performLayout\", this).call(this, ctxt);
	
	      // determine the glyph to use
	      var note = this.notes[0];
	      var glyph;
	
	      if (note.liquescent !== _ExsurgeChant.LiquescentType.None) {
	        glyph = _ExsurgeDrawing.GlyphCode.OriscusLiquescent;
	      } else {
	        if (note.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Ascending) glyph = _ExsurgeDrawing.GlyphCode.OriscusAsc;else if (note.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Descending) glyph = _ExsurgeDrawing.GlyphCode.OriscusDes;else {
	          // by default we take the descending form, unless we can figure out by a lookahead here
	          glyph = _ExsurgeDrawing.GlyphCode.OriscusDes;
	
	          // try to find a neume following this one
	          var neume = ctxt.findNextNeume();
	
	          if (neume) {
	            var nextNoteStaffPosition = ctxt.activeClef.pitchToStaffPosition(neume.notes[0].pitch);
	
	            if (nextNoteStaffPosition > note.staffPosition) glyph = _ExsurgeDrawing.GlyphCode.OriscusAsc;
	          }
	        }
	      }
	
	      this.build(ctxt).noteAt(note, glyph);
	
	      this.finishLayout(ctxt);
	    }
	  }, {
	    key: \"resetDependencies\",
	    value: function resetDependencies() {
	      // a single oriscus tries to automatically use the right direction
	      // based on the following neumes. if we don't have a manually designated
	      // direction, then we reset our layout so that we can try to guess it
	      // at next layout phase.
	      if (this.notes[0].shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Ascending || this.notes[0].shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Descending) return;
	
	      this.needsLayout = true;
	    }
	  }]);
	
	  return Oriscus;
	}(Neume);
	
	/*
	 * PesQuassus
	 */
	
	
	var PesQuassus = exports.PesQuassus = function (_Neume8) {
	  _inherits(PesQuassus, _Neume8);
	
	  function PesQuassus() {
	    _classCallCheck(this, PesQuassus);
	
	    return _possibleConstructorReturn(this, (PesQuassus.__proto__ || Object.getPrototypeOf(PesQuassus)).apply(this, arguments));
	  }
	
	  _createClass(PesQuassus, [{
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(PesQuassus.prototype.__proto__ || Object.getPrototypeOf(PesQuassus.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var lower = this.notes[0];
	      var upper = this.notes[1];
	
	      var lowerGlyph;
	
	      var lowerStaffPos = lower.staffPosition;
	      var upperStaffPos = upper.staffPosition;
	
	      if (lower.shape === _ExsurgeChant.NoteShape.Oriscus) lowerGlyph = _ExsurgeDrawing.GlyphCode.OriscusAsc;else lowerGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	
	      var builder = this.build(ctxt).noteAt(lower, lowerGlyph);
	
	      if (upperStaffPos - lowerStaffPos === 1)
	        // use a virga glyph in this case
	        builder.virgaAt(upper);else if (upper.liquescent === _ExsurgeChant.LiquescentType.LargeDescending) builder.noteAt(upper, _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent).withLineEndingAt(lower);else builder.noteAt(upper, _ExsurgeDrawing.GlyphCode.PunctumQuadratum).withLineEndingAt(lower);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return PesQuassus;
	}(Neume);
	
	/*
	 * PesSubpunctis
	 */
	
	
	var PesSubpunctis = exports.PesSubpunctis = function (_Neume9) {
	  _inherits(PesSubpunctis, _Neume9);
	
	  function PesSubpunctis() {
	    _classCallCheck(this, PesSubpunctis);
	
	    return _possibleConstructorReturn(this, (PesSubpunctis.__proto__ || Object.getPrototypeOf(PesSubpunctis)).apply(this, arguments));
	  }
	
	  _createClass(PesSubpunctis, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionPodatusEpisemata(this.notes[0], this.notes[1]);
	      for (var i = 2; i < this.notes.length; ++i) {
	        this.positionEpisemataAbove(this.notes[i]);
	      }
	      this.positionInclinataMorae(this.notes.slice(1));
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(PesSubpunctis.prototype.__proto__ || Object.getPrototypeOf(PesSubpunctis.prototype), \"performLayout\", this).call(this, ctxt);
	
	      // podatus followed by inclinata
	      this.build(ctxt).withPodatus(this.notes[0], this.notes[1]).advanceBy(ctxt.intraNeumeSpacing * 0.68).withInclinata(this.notes.slice(2));
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return PesSubpunctis;
	}(Neume);
	
	/*
	 * Podatus
	 *
	 * This podatus class handles a few neume types actually, depending on the note
	 * data: Podatus (including various liquescent types on the upper note),
	 * Podatus initio debilis, and Quilisma-Pes
	 */
	
	
	var Podatus = exports.Podatus = function (_Neume10) {
	  _inherits(Podatus, _Neume10);
	
	  function Podatus() {
	    _classCallCheck(this, Podatus);
	
	    return _possibleConstructorReturn(this, (Podatus.__proto__ || Object.getPrototypeOf(Podatus)).apply(this, arguments));
	  }
	
	  _createClass(Podatus, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionPodatusMarkings(this.notes[0], this.notes[1]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Podatus.prototype.__proto__ || Object.getPrototypeOf(Podatus.prototype), \"performLayout\", this).call(this, ctxt);
	
	      this.build(ctxt).withPodatus(this.notes[0], this.notes[1]);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Podatus;
	}(Neume);
	
	/*
	 * Porrectus
	 */
	
	
	var Porrectus = exports.Porrectus = function (_Neume11) {
	  _inherits(Porrectus, _Neume11);
	
	  function Porrectus() {
	    _classCallCheck(this, Porrectus);
	
	    return _possibleConstructorReturn(this, (Porrectus.__proto__ || Object.getPrototypeOf(Porrectus)).apply(this, arguments));
	  }
	
	  _createClass(Porrectus, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionPorrectusMarkings(this.notes[0], this.notes[1], this.notes[2]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Porrectus.prototype.__proto__ || Object.getPrototypeOf(Porrectus.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var first = this.notes[0];
	      var second = this.notes[1];
	      var third = this.notes[2];
	
	      var thirdGlyph;
	
	      if (third.liquescent & _ExsurgeChant.LiquescentType.Small) thirdGlyph = _ExsurgeDrawing.GlyphCode.TerminatingAscLiquescent;else if (third.liquescent & _ExsurgeChant.LiquescentType.Descending) thirdGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else thirdGlyph = _ExsurgeDrawing.GlyphCode.PodatusUpper;
	
	      this.build(ctxt).lineFrom(second).withPorrectusSwash(first, second).noteAt(third, thirdGlyph);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Porrectus;
	}(Neume);
	
	/*
	 * PorrectusFlexus
	 */
	
	
	var PorrectusFlexus = exports.PorrectusFlexus = function (_Neume12) {
	  _inherits(PorrectusFlexus, _Neume12);
	
	  function PorrectusFlexus() {
	    _classCallCheck(this, PorrectusFlexus);
	
	    return _possibleConstructorReturn(this, (PorrectusFlexus.__proto__ || Object.getPrototypeOf(PorrectusFlexus)).apply(this, arguments));
	  }
	
	  _createClass(PorrectusFlexus, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionPorrectusFlexusMarkings(this.notes[0], this.notes[1], this.notes[2], this.notes[3]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(PorrectusFlexus.prototype.__proto__ || Object.getPrototypeOf(PorrectusFlexus.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var first = this.notes[0];
	      var second = this.notes[1];
	      var third = this.notes[2];
	      var fourth = this.notes[3];
	
	      var thirdGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum,
	          fourthGlyph;
	
	      if (fourth.liquescent & _ExsurgeChant.LiquescentType.Small) {
	        thirdGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;
	        fourthGlyph = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;
	      } else if (fourth.liquescent & _ExsurgeChant.LiquescentType.Ascending) fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (fourth.liquescent & _ExsurgeChant.LiquescentType.Descending) fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	
	      this.build(ctxt).lineFrom(second).withPorrectusSwash(first, second).noteAt(third, thirdGlyph).noteAt(fourth, fourthGlyph);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return PorrectusFlexus;
	}(Neume);
	
	// this is some type of pseudo nume right? there is no such thing as a neume
	// of puncta inclinata, but this will be part of other composite neumes.
	
	
	var PunctaInclinata = exports.PunctaInclinata = function (_Neume13) {
	  _inherits(PunctaInclinata, _Neume13);
	
	  function PunctaInclinata() {
	    _classCallCheck(this, PunctaInclinata);
	
	    return _possibleConstructorReturn(this, (PunctaInclinata.__proto__ || Object.getPrototypeOf(PunctaInclinata)).apply(this, arguments));
	  }
	
	  _createClass(PunctaInclinata, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionInclinataMorae(this.notes);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(PunctaInclinata.prototype.__proto__ || Object.getPrototypeOf(PunctaInclinata.prototype), \"performLayout\", this).call(this, ctxt);
	
	      this.build(ctxt).withInclinata(this.notes);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return PunctaInclinata;
	}(Neume);
	
	/*
	 * Punctum
	 */
	
	
	var Punctum = exports.Punctum = function (_Neume14) {
	  _inherits(Punctum, _Neume14);
	
	  function Punctum() {
	    _classCallCheck(this, Punctum);
	
	    return _possibleConstructorReturn(this, (Punctum.__proto__ || Object.getPrototypeOf(Punctum)).apply(this, arguments));
	  }
	
	  _createClass(Punctum, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionEpisemataAbove(this.notes[0]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Punctum.prototype.__proto__ || Object.getPrototypeOf(Punctum.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var note = this.notes[0];
	      var glyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	
	      // determine the glyph to use
	      if (note.liquescent !== _ExsurgeChant.LiquescentType.None) {
	        if (note.shape === _ExsurgeChant.NoteShape.Inclinatum) glyph = _ExsurgeDrawing.GlyphCode.PunctumInclinatumLiquescent;else if (note.shape === _ExsurgeChant.NoteShape.Oriscus) glyph = _ExsurgeDrawing.GlyphCode.OriscusLiquescent;else if (note.liquescent & _ExsurgeChant.LiquescentType.Ascending) glyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (note.liquescent & _ExsurgeChant.LiquescentType.Descending) glyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else glyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumLiquescent;
	      } else {
	        if (note.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Cavum) glyph = _ExsurgeDrawing.GlyphCode.PunctumCavum;else if (note.shape === _ExsurgeChant.NoteShape.Inclinatum) glyph = _ExsurgeDrawing.GlyphCode.PunctumInclinatum;else if (note.shape === _ExsurgeChant.NoteShape.Quilisma) glyph = _ExsurgeDrawing.GlyphCode.Quilisma;else glyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	      }
	
	      this.build(ctxt).noteAt(note, glyph);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Punctum;
	}(Neume);
	
	/*
	 * Salicus
	 */
	
	
	var Salicus = exports.Salicus = function (_Neume15) {
	  _inherits(Salicus, _Neume15);
	
	  function Salicus() {
	    _classCallCheck(this, Salicus);
	
	    return _possibleConstructorReturn(this, (Salicus.__proto__ || Object.getPrototypeOf(Salicus)).apply(this, arguments));
	  }
	
	  _createClass(Salicus, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      // by default place episema below
	      // fixme: is this correct?
	      for (var i = 0; i < this.notes.length; i++) {
	        this.positionEpisemataBelow(this.notes[i]);
	      }
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Salicus.prototype.__proto__ || Object.getPrototypeOf(Salicus.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var first = this.notes[0];
	      var second = this.notes[1];
	      var third = this.notes[2];
	
	      var builder = this.build(ctxt).noteAt(first, _ExsurgeDrawing.GlyphCode.PunctumQuadratum);
	
	      // if the next note doesn't require a stem connector, then add a tad bit
	      // of spacing here
	      if (!(second.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Stemmed)) builder.advanceBy(ctxt.intraNeumeSpacing);
	
	      // second note is always an oriscus, which may or may not be stemmed
	      // to the first
	      builder.noteAt(second, _ExsurgeDrawing.GlyphCode.OriscusAsc);
	
	      // third note can be a punctum quadratum or various liquescent forms
	      if (third.liquescent & _ExsurgeChant.LiquescentType.Small) builder.noteAt(third, _ExsurgeDrawing.GlyphCode.TerminatingAscLiquescent);else if (third.liquescent === _ExsurgeChant.LiquescentType.Ascending) builder.noteAt(third, _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent);else if (third.liquescent === _ExsurgeChant.LiquescentType.Descending) builder.noteAt(third, _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent);else builder.virgaAt(third);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Salicus;
	}(Neume);
	
	/*
	 * Salicus Flexus
	 */
	
	
	var SalicusFlexus = exports.SalicusFlexus = function (_Neume16) {
	  _inherits(SalicusFlexus, _Neume16);
	
	  function SalicusFlexus() {
	    _classCallCheck(this, SalicusFlexus);
	
	    return _possibleConstructorReturn(this, (SalicusFlexus.__proto__ || Object.getPrototypeOf(SalicusFlexus)).apply(this, arguments));
	  }
	
	  _createClass(SalicusFlexus, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      var hasTopEpisema = this.positionTorculusMarkings(this.notes[1], this.notes[2], this.notes[3]);
	      this.positionEpisemata(this.notes[0], hasTopEpisema ? _ExsurgeDrawing.MarkingPositionHint.Above : _ExsurgeDrawing.MarkingPositionHint.Below);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(SalicusFlexus.prototype.__proto__ || Object.getPrototypeOf(SalicusFlexus.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var first = this.notes[0];
	      var second = this.notes[1];
	      var third = this.notes[2];
	      var fourth = this.notes[3];
	
	      var builder = this.build(ctxt).noteAt(first, _ExsurgeDrawing.GlyphCode.PunctumQuadratum);
	
	      // if the next note doesn't require a stem connector, then add a tad bit
	      // of spacing here
	      if (!(second.shapeModifiers & _ExsurgeChant.NoteShapeModifiers.Stemmed)) builder.advanceBy(ctxt.intraNeumeSpacing);
	
	      // second note is always an oriscus, which may or may not be stemmed
	      // to the first
	      builder.noteAt(second, _ExsurgeDrawing.GlyphCode.OriscusAsc);
	
	      // third note can be a punctum quadratum or various liquescent forms,
	      // ...based on note four though!
	      if (fourth.liquescent & _ExsurgeChant.LiquescentType.Small) builder.noteAt(third, _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent);else builder.noteAt(third, _ExsurgeDrawing.GlyphCode.PunctumQuadratum);
	
	      // finally, do the fourth note
	      if (fourth.liquescent & _ExsurgeChant.LiquescentType.Small) builder.noteAt(fourth, _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent);else if (fourth.liquescent & _ExsurgeChant.LiquescentType.Ascending) builder.noteAt(fourth, _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent);else if (fourth.liquescent & _ExsurgeChant.LiquescentType.Descending) builder.noteAt(fourth, _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent);else builder.noteAt(fourth, _ExsurgeDrawing.GlyphCode.PunctumQuadratum);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return SalicusFlexus;
	}(Neume);
	
	/*
	 * Scandicus
	 */
	
	
	var Scandicus = exports.Scandicus = function (_Neume17) {
	  _inherits(Scandicus, _Neume17);
	
	  function Scandicus() {
	    _classCallCheck(this, Scandicus);
	
	    return _possibleConstructorReturn(this, (Scandicus.__proto__ || Object.getPrototypeOf(Scandicus)).apply(this, arguments));
	  }
	
	  _createClass(Scandicus, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      if (this.notes[2].shape === _ExsurgeChant.NoteShape.Virga) {
	        this.positionPodatusMarkings(this.notes[0], this.notes[1]);
	        this.positionEpisemataAbove(this.notes[2]);
	      } else {
	        this.positionEpisemataBelow(this.notes[0]);
	        this.positionPodatusMarkings(this.notes[1], this.notes[2]);
	      }
	    }
	
	    // if the third note shape is a virga, then the scadicus is rendered
	    // as a podatus followed by a virga. Otherwise, it's rendered as a
	    // punctum followed by a podatus...
	
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Scandicus.prototype.__proto__ || Object.getPrototypeOf(Scandicus.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var first = this.notes[0];
	      var second = this.notes[1];
	      var third = this.notes[2];
	
	      if (third.shape === _ExsurgeChant.NoteShape.Virga) {
	        this.build(ctxt).withPodatus(first, second).virgaAt(third);
	      } else {
	        this.build(ctxt).noteAt(first, first.shape === _ExsurgeChant.NoteShape.Quilisma ? _ExsurgeDrawing.GlyphCode.Quilisma : _ExsurgeDrawing.GlyphCode.PunctumQuadratum).withPodatus(second, third);
	      }
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Scandicus;
	}(Neume);
	
	/*
	 * Scandicus Flexus
	 */
	
	
	var ScandicusFlexus = exports.ScandicusFlexus = function (_Neume18) {
	  _inherits(ScandicusFlexus, _Neume18);
	
	  function ScandicusFlexus() {
	    _classCallCheck(this, ScandicusFlexus);
	
	    return _possibleConstructorReturn(this, (ScandicusFlexus.__proto__ || Object.getPrototypeOf(ScandicusFlexus)).apply(this, arguments));
	  }
	
	  _createClass(ScandicusFlexus, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      if (this.notes[2].shape === _ExsurgeChant.NoteShape.Virga) {
	        this.positionPodatusMarkings(this.notes[0], this.notes[1]);
	        this.positionClivisMarkings(this.notes[2], this.notes[3]);
	      } else {
	        this.positionEpisemataBelow(this.notes[0]);
	        this.positionPodatusMarkings(this.notes[1], this.notes[2]);
	        this.positionEpisemataAbove(this.notes[3]);
	      }
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(ScandicusFlexus.prototype.__proto__ || Object.getPrototypeOf(ScandicusFlexus.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var first = this.notes[0];
	      var second = this.notes[1];
	      var third = this.notes[2];
	      var fourth = this.notes[3];
	
	      if (third.shape === _ExsurgeChant.NoteShape.Virga) {
	        this.build(ctxt).withPodatus(first, second).advanceBy(ctxt.intraNeumeSpacing).withClivis(third, fourth);
	      } else {
	        var fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	
	        if (fourth.liquescent & _ExsurgeChant.LiquescentType.Ascending) fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (fourth.liquescent & _ExsurgeChant.LiquescentType.Descending) fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;
	
	        this.build(ctxt).noteAt(first, _ExsurgeDrawing.GlyphCode.PunctumQuadratum).withPodatus(second, third).advanceBy(ctxt.intraNeumeSpacing).noteAt(fourth, fourthGlyph);
	      }
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return ScandicusFlexus;
	}(Neume);
	
	/*
	 * Torculus
	 */
	
	
	var Torculus = exports.Torculus = function (_Neume19) {
	  _inherits(Torculus, _Neume19);
	
	  function Torculus() {
	    _classCallCheck(this, Torculus);
	
	    return _possibleConstructorReturn(this, (Torculus.__proto__ || Object.getPrototypeOf(Torculus)).apply(this, arguments));
	  }
	
	  _createClass(Torculus, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionTorculusMarkings(this.notes[0], this.notes[1], this.notes[2]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Torculus.prototype.__proto__ || Object.getPrototypeOf(Torculus.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var note1 = this.notes[0];
	      var note2 = this.notes[1];
	      var note3 = this.notes[2];
	
	      var glyph1, glyph3;
	
	      if (note1.liquescent === _ExsurgeChant.LiquescentType.InitioDebilis) glyph1 = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;else if (note1.shape === _ExsurgeChant.NoteShape.Quilisma) glyph1 = _ExsurgeDrawing.GlyphCode.Quilisma;else glyph1 = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	
	      if (note3.liquescent & _ExsurgeChant.LiquescentType.Small) glyph3 = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;else if (note3.liquescent & _ExsurgeChant.LiquescentType.Ascending) glyph3 = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (note3.liquescent & _ExsurgeChant.LiquescentType.Descending) glyph3 = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else glyph3 = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	
	      this.build(ctxt).noteAt(note1, glyph1).noteAt(note2, _ExsurgeDrawing.GlyphCode.PunctumQuadratum).noteAt(note3, glyph3);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Torculus;
	}(Neume);
	
	/*
	 * TorculusResupinus
	 */
	
	
	var TorculusResupinus = exports.TorculusResupinus = function (_Neume20) {
	  _inherits(TorculusResupinus, _Neume20);
	
	  function TorculusResupinus() {
	    _classCallCheck(this, TorculusResupinus);
	
	    return _possibleConstructorReturn(this, (TorculusResupinus.__proto__ || Object.getPrototypeOf(TorculusResupinus)).apply(this, arguments));
	  }
	
	  _createClass(TorculusResupinus, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionPorrectusMarkings(this.notes[1], this.notes[2], this.notes[3]);
	      this.positionClivisEpisemata(this.notes[1], this.notes[0]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(TorculusResupinus.prototype.__proto__ || Object.getPrototypeOf(TorculusResupinus.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var first = this.notes[0];
	      var second = this.notes[1];
	      var third = this.notes[2];
	      var fourth = this.notes[3];
	
	      var firstGlyph, fourthGlyph;
	
	      if (first.liquescent === _ExsurgeChant.LiquescentType.InitioDebilis) {
	        firstGlyph = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;
	      } else if (first.shape === _ExsurgeChant.NoteShape.Quilisma) firstGlyph = _ExsurgeDrawing.GlyphCode.Quilisma;else firstGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	
	      if (fourth.liquescent & _ExsurgeChant.LiquescentType.Small) fourthGlyph = _ExsurgeDrawing.GlyphCode.TerminatingAscLiquescent;else if (third.liquescent & _ExsurgeChant.LiquescentType.Descending) fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else fourthGlyph = _ExsurgeDrawing.GlyphCode.PodatusUpper;
	
	      this.build(ctxt).noteAt(first, firstGlyph).withPorrectusSwash(second, third).noteAt(fourth, fourthGlyph);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return TorculusResupinus;
	}(Neume);
	
	/*
	 * TorculusResupinusFlexus
	 */
	
	
	var TorculusResupinusFlexus = exports.TorculusResupinusFlexus = function (_Neume21) {
	  _inherits(TorculusResupinusFlexus, _Neume21);
	
	  function TorculusResupinusFlexus() {
	    _classCallCheck(this, TorculusResupinusFlexus);
	
	    return _possibleConstructorReturn(this, (TorculusResupinusFlexus.__proto__ || Object.getPrototypeOf(TorculusResupinusFlexus)).apply(this, arguments));
	  }
	
	  _createClass(TorculusResupinusFlexus, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionPorrectusFlexusMarkings(this.notes[1], this.notes[2], this.notes[3], this.notes[4]);
	      this.positionClivisEpisemata(this.notes[1], this.notes[0]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(TorculusResupinusFlexus.prototype.__proto__ || Object.getPrototypeOf(TorculusResupinusFlexus.prototype), \"performLayout\", this).call(this, ctxt);
	
	      var first = this.notes[0];
	      var second = this.notes[1];
	      var third = this.notes[2];
	      var fourth = this.notes[3];
	      var fifth = this.notes[4];
	
	      var firstGlyph,
	          fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum,
	          fifthGlyph;
	
	      if (first.liquescent === _ExsurgeChant.LiquescentType.InitioDebilis) {
	        firstGlyph = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;
	      } else if (first.shape === _ExsurgeChant.NoteShape.Quilisma) firstGlyph = _ExsurgeDrawing.GlyphCode.Quilisma;else firstGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	
	      if (fifth.liquescent & _ExsurgeChant.LiquescentType.Small) {
	        fourthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;
	        fifthGlyph = _ExsurgeDrawing.GlyphCode.TerminatingDesLiquescent;
	      } else if (fifth.liquescent & _ExsurgeChant.LiquescentType.Ascending) fifthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumAscLiquescent;else if (fifth.liquescent & _ExsurgeChant.LiquescentType.Descending) fifthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratumDesLiquescent;else fifthGlyph = _ExsurgeDrawing.GlyphCode.PunctumQuadratum;
	
	      this.build(ctxt).noteAt(first, firstGlyph).withPorrectusSwash(second, third).noteAt(fourth, fourthGlyph).noteAt(fifth, fifthGlyph);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return TorculusResupinusFlexus;
	}(Neume);
	
	/*
	 * Tristropha
	 *
	 * For simplicity in implementation, Tristropha's have three notes in the object
	 * structure. These technically must be the same pitch though (like the
	 * Distropha and Bivirga).
	 */
	
	
	var Tristropha = exports.Tristropha = function (_Neume22) {
	  _inherits(Tristropha, _Neume22);
	
	  function Tristropha() {
	    _classCallCheck(this, Tristropha);
	
	    return _possibleConstructorReturn(this, (Tristropha.__proto__ || Object.getPrototypeOf(Tristropha)).apply(this, arguments));
	  }
	
	  _createClass(Tristropha, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionEpisemataAbove(this.notes[0]);
	      this.positionEpisemataAbove(this.notes[1]);
	      this.positionEpisemataAbove(this.notes[2]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Tristropha.prototype.__proto__ || Object.getPrototypeOf(Tristropha.prototype), \"performLayout\", this).call(this, ctxt);
	      var glyphCodes = this.notes.map(function (note) {
	        return Apostropha.getNoteGlyphCode(note);
	      });
	      var glyphAdvance = glyphCodes[0] === _ExsurgeDrawing.GlyphCode.Stropha ? ctxt.intraNeumeSpacing / 2 : ctxt.intraNeumeSpacing;
	
	      this.build(ctxt).noteAt(this.notes[0], glyphCodes[0]).advanceBy(glyphAdvance).noteAt(this.notes[1], glyphCodes[1]).advanceBy(glyphAdvance).noteAt(this.notes[2], glyphCodes[2]);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Tristropha;
	}(Neume);
	
	/*
	 * Virga
	 */
	
	
	var Virga = exports.Virga = function (_Neume23) {
	  _inherits(Virga, _Neume23);
	
	  function Virga() {
	    _classCallCheck(this, Virga);
	
	    return _possibleConstructorReturn(this, (Virga.__proto__ || Object.getPrototypeOf(Virga)).apply(this, arguments));
	  }
	
	  _createClass(Virga, [{
	    key: \"positionMarkings\",
	    value: function positionMarkings() {
	      this.positionEpisemataAbove(this.notes[0]);
	    }
	  }, {
	    key: \"performLayout\",
	    value: function performLayout(ctxt) {
	      _get(Virga.prototype.__proto__ || Object.getPrototypeOf(Virga.prototype), \"performLayout\", this).call(this, ctxt);
	
	      this.build(ctxt).virgaAt(this.notes[0]);
	
	      this.finishLayout(ctxt);
	    }
	  }]);
	
	  return Virga;
	}(Neume);

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	\"use strict\";
	
	Object.defineProperty(exports, \"__esModule\", {
	  value: true
	});
	exports.Titles = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _ExsurgeCore = __webpack_require__(1);
	
	var _ExsurgeDrawing = __webpack_require__(4);
	
	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //
	// Author(s):
	// Benjamin Bloomfield <benjamin@sourceandsummit.com>
	//
	// Copyright (c) 2019
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the \"Software\"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	//
	
	var Titles = exports.Titles = function (_ChantLayoutElement) {
	  _inherits(Titles, _ChantLayoutElement);
	
	  function Titles(ctxt, score) {
	    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
	        supertitle = _ref.supertitle,
	        title = _ref.title,
	        subtitle = _ref.subtitle,
	        textLeft = _ref.textLeft,
	        textRight = _ref.textRight;
	
	    _classCallCheck(this, Titles);
	
	    var _this = _possibleConstructorReturn(this, (Titles.__proto__ || Object.getPrototypeOf(Titles)).call(this));
	
	    _this.score = score;
	    _this.setSupertitle(ctxt, supertitle);
	    _this.setTitle(ctxt, title);
	    _this.setSubtitle(ctxt, subtitle);
	    _this.setTextLeft(ctxt, textLeft);
	    _this.setTextRight(ctxt, textRight);
	    return _this;
	  }
	
	  _createClass(Titles, [{
	    key: \"setBoundsX\",
	    value: function setBoundsX(ctxt, elementName, width) {
	      var element = this[elementName];
	      switch (ctxt.textStyles[elementName].alignment) {
	        case \"left\":
	          element.textAnchor = \"start\";
	          element.bounds.x = 0;
	          break;
	        case \"right\":
	          element.textAnchor = \"end\";
	          element.bounds.x = width;
	          break;
	        case \"center\":
	        default:
	          element.textAnchor = \"middle\";
	          element.bounds.x = width / 2;
	      }
	    }
	
	    /**
	     * Lays out the titles, and returns their total height
	     * @param  {ChantContext} ctxt
	     * @return {number}      the tottal height of titles laid out
	     */
	
	  }, {
	    key: \"layoutTitles\",
	    value: function layoutTitles(ctxt, width) {
	      this.bounds = new _ExsurgeCore.Rect(0, 0, 0, 0);
	      var y = 0;
	      if (this.supertitle) {
	        this.supertitle.recalculateMetrics(ctxt);
	        this.supertitle.setMaxWidth(ctxt, width);
	
	        this.setBoundsX(ctxt, \"supertitle\", width);
	        this.supertitle.bounds.y = y;
	        this.bounds.union(this.supertitle.bounds);
	        this.supertitle.bounds.y += this.supertitle.origin.y;
	        y += this.supertitle.bounds.height + this.supertitle.padding(ctxt);
	      }
	      if (this.title) {
	        if (y) y += this.title.padding(ctxt);
	        this.title.recalculateMetrics(ctxt);
	        this.title.setMaxWidth(ctxt, width);
	        this.setBoundsX(ctxt, \"title\", width);
	        this.title.bounds.y = y;
	        this.bounds.union(this.title.bounds);
	        this.title.bounds.y += this.title.origin.y;
	        y += this.title.bounds.height + this.title.padding(ctxt);
	      }
	      if (this.subtitle) {
	        if (y) y += this.subtitle.padding(ctxt);
	        this.subtitle.recalculateMetrics(ctxt);
	        this.subtitle.setMaxWidth(ctxt, width);
	        this.setBoundsX(ctxt, \"subtitle\", width);
	        this.subtitle.bounds.y = y;
	        this.bounds.union(this.subtitle.bounds);
	        this.subtitle.bounds.y += this.subtitle.origin.y;
	        y += this.subtitle.bounds.height + this.subtitle.padding(ctxt);
	      }
	      var finalY = y,
	          textLeft = this.score.overrideTextLeft || this.textLeft;
	      if (textLeft) {
	        textLeft.recalculateMetrics(ctxt);
	        textLeft.bounds.y = y;
	        this.bounds.union(textLeft.bounds);
	        textLeft.bounds.y += textLeft.origin.y;
	        finalY = y + textLeft.bounds.height + textLeft.padding(ctxt);
	      }
	      if (this.textRight) {
	        this.textRight.recalculateMetrics(ctxt);
	        this.textRight.bounds.x = width;
	        this.textRight.bounds.y = y;
	        this.bounds.union(this.textRight.bounds);
	        this.textRight.bounds.y += this.textRight.origin.y;
	        finalY = Math.max(finalY, y + this.textRight.bounds.height + this.textRight.padding(ctxt));
	      }
	      return finalY;
	    }
	  }, {
	    key: \"setSupertitle\",
	    value: function setSupertitle(ctxt, supertitle) {
	      this.supertitle = supertitle ? new _ExsurgeDrawing.Supertitle(ctxt, supertitle) : null;
	    }
	  }, {
	    key: \"setTitle\",
	    value: function setTitle(ctxt, title) {
	      this.title = title ? new _ExsurgeDrawing.Title(ctxt, title) : null;
	    }
	  }, {
	    key: \"setSubtitle\",
	    value: function setSubtitle(ctxt, subtitle) {
	      this.subtitle = subtitle ? new _ExsurgeDrawing.Subtitle(ctxt, subtitle) : null;
	    }
	  }, {
	    key: \"setTextLeft\",
	    value: function setTextLeft(ctxt, textLeft) {
	      this.textLeft = textLeft ? new _ExsurgeDrawing.TextLeftRight(ctxt, textLeft, \"textLeft\") : null;
	    }
	  }, {
	    key: \"setTextRight\",
	    value: function setTextRight(ctxt, textRight) {
	      this.textRight = textRight ? new _ExsurgeDrawing.TextLeftRight(ctxt, textRight, \"textRight\") : null;
	    }
	  }, {
	    key: \"hasSupertitle\",
	    value: function hasSupertitle(ctxt, supertitle) {
	      return !!this.supertitle;
	    }
	  }, {
	    key: \"hasTitle\",
	    value: function hasTitle(ctxt, title) {
	      return !!this.title;
	    }
	  }, {
	    key: \"hasSubtitle\",
	    value: function hasSubtitle(ctxt, subtitle) {
	      return !!this.subtitle;
	    }
	  }, {
	    key: \"hasTextLeft\",
	    value: function hasTextLeft(ctxt, textLeft) {
	      return !!this.textLeft;
	    }
	  }, {
	    key: \"hasTextRight\",
	    value: function hasTextRight(ctxt, textRight) {
	      return !!this.textRight;
	    }
	  }, {
	    key: \"draw\",
	    value: function draw(ctxt) {
	      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	
	      var canvasCtxt = ctxt.canvasCtxt;
	      canvasCtxt.translate(this.bounds.x, this.bounds.y);
	
	      var _arr = [this.supertitle, this.title, this.subtitle, this.score.overrideTextLeft || this.textLeft, this.textRight];
	      for (var _i = 0; _i < _arr.length; _i++) {
	        var el = _arr[_i];
	        if (el) el.draw(ctxt, scale);
	      }
	
	      canvasCtxt.translate(-this.bounds.x, -this.bounds.y);
	    }
	  }, {
	    key: \"getInnerNodes\",
	    value: function getInnerNodes(ctxt) {
	      var functionName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"createSvgNode\";
	
	      var nodes = [];
	
	      var _arr2 = [this.supertitle, this.title, this.subtitle, this.score.overrideTextLeft || this.textLeft, this.textRight];
	      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
	        var el = _arr2[_i2];
	        if (el) nodes.push(el[functionName](ctxt));
	      }
	      return nodes;
	    }
	  }, {
	    key: \"createSvgNode\",
	    value: function createSvgNode(ctxt) {
	      var nodes = this.getInnerNodes(ctxt, \"createSvgNode\");
	
	      var node = _ExsurgeDrawing.QuickSvg.createNode(\"g\", { class: \"Titles\" }, nodes);
	
	      node.source = this;
	      this.svg = node;
	
	      return node;
	    }
	  }, {
	    key: \"createSvgTree\",
	    value: function createSvgTree(ctxt) {
	      var nodes = this.getInnerNodes(ctxt, \"createSvgTree\");
	
	      return _ExsurgeDrawing.QuickSvg.createSvgTree.apply(_ExsurgeDrawing.QuickSvg, [\"g\", { class: \"Titles\", source: this }].concat(_toConsumableArray(nodes)));
	    }
	  }, {
	    key: \"createSvgFragment\",
	    value: function createSvgFragment(ctxt) {
	      var fragment = \"\";
	
	      var _arr3 = [this.supertitle, this.title, this.subtitle, this.score.overrideTextLeft || this.textLeft, this.textRight];
	      for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
	        var el = _arr3[_i3];
	        if (el) fragment += el.createSvgFragment(ctxt);
	      }
	
	      fragment = _ExsurgeDrawing.QuickSvg.createFragment(\"g\", { class: \"Titles\" }, fragment);
	      return fragment;
	    }
	  }]);
	
	  return Titles;
	}(_ExsurgeDrawing.ChantLayoutElement);

/***/ })
/******/ ])
});
;


// WEBPACK FOOTER //
// exsurge.min.js"," 	// The module cache
 	var installedModules = {};

 	// The require function
 	function __webpack_require__(moduleId) {

 		// Check if module is in cache
 		if(installedModules[moduleId])
 			return installedModules[moduleId].exports;

 		// Create a new module (and put it into the cache)
 		var module = installedModules[moduleId] = {
 			exports: {},
 			id: moduleId,
 			loaded: false
 		};

 		// Execute the module function
 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

 		// Flag the module as loaded
 		module.loaded = true;

 		// Return the exports of the module
 		return module.exports;
 	}


 	// expose the modules object (__webpack_modules__)
 	__webpack_require__.m = modules;

 	// expose the module cache
 	__webpack_require__.c = installedModules;

 	// __webpack_public_path__
 	__webpack_require__.p = \"\";

 	// Load entry module and return exports
 	return __webpack_require__(0);



// WEBPACK FOOTER //
// webpack/bootstrap 6f17a1afaaa61ba84253","//
// Author(s):
// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
//
// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the \"Software\"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

'use strict';

// import { Annotation, ChantContext } from './Exsurge.Drawing.js'
// import { Gabc } from './Exsurge.Gabc.js'
//
// // client side support
//
// if (typeof document !== 'undefined' && document.registerElement) {
//   var ChantVisualElementPrototype = Object.create(HTMLElement.prototype);
//
//   ChantVisualElementPrototype.createdCallback = function() {
//     var ctxt = new ChantContext();
//
//     ctxt.setFont(\"'Crimson Text', serif\", 19.2);
//
//     var useDropCap = true;
//     var useDropCapAttr = this.getAttribute(\"use-drop-cap\");
//     if (useDropCapAttr === 'false')
//       useDropCap = false;
//
//     var score = Gabc.loadChantScore(ctxt, this.innerText, useDropCap);
//
//     var annotationAttr = this.getAttribute(\"annotation\");
//     if (annotationAttr) {
//       // add an annotation
//       score.annotation = new Annotation(ctxt, annotationAttr);
//     }
//
//     var _element = this;
//
//     var width = 0;
//     var doLayout = function() {
//       var newWidth = _element.parentElement.clientWidth;
//       if(width === newWidth) return;
//       width = newWidth;
//       // perform layout on the chant
//       score.performLayout(ctxt, function() {
//         score.layoutChantLines(ctxt, width, function() {
//           // render the score to svg code
//           _element.appendElement(score.createSvgNode(ctxt));
//         });
//       });
//     }
//     doLayout();
//     if (window.addEventListener)
//       window.addEventListener('resize',doLayout,false);
//     else if (window.attachEvent)
//       window.attachEvent('onresize',doLayout);
//   }
//
//   ChantVisualElementPrototype.attachedCallback = function() {
//
//   }
//
//   // register the custom element
//   // if(window.customElements && window.customElements.define) {
//   //   window.customElements.define('chant-visual', ChantVisualElementPrototype);
//   // } else {
//     document.registerElement('chant-visual', {
//       prototype: ChantVisualElementPrototype
//     });
//   // }
// }

export * from './Exsurge.Core.js'
export * from './Exsurge.Text.js'
export * from './Exsurge.Glyphs.js'
export * from './Exsurge.Drawing.js'
export * from './Exsurge.Chant.js'
export * from './Exsurge.Chant.ChantLine.js'
export * from './Exsurge.Chant.Markings.js'
export * from './Exsurge.Chant.Signs.js'
export * from './Exsurge.Chant.Neumes.js'
export * from './Exsurge.Gabc.js'
export * from './Exsurge.Titles.js'
export * from './greextraGlyphs.js'



// WEBPACK FOOTER //
// ./src/index.js","//
// Author(s):
// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
//
// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the \"Software\"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

export var Units = {
  // enums
  DeviceIndepenedent: 0, // device independent units: 96/inch
  Centimeters: 1,
  Millimeters: 2,
  Inches: 3,

  // constants for device independent units (diu)
  DIU_PER_INCH: 96,
  DIU_PER_CENTIMETER: 96 / 2.54,

  ToDeviceIndependent: function (n, inputUnits) {
    switch (inputUnits) {
      case Centimeters:
        return n * Units.DIU_PER_CENTIMETER;
      case Millimeters:
        return n * Units.DIU_PER_CENTIMETER / 10;
      case Inches:
        return n * Units.DIU_PER_INCH;
      default:
        return n;
    }
  },

  FromDeviceIndependent: function (n, outputUnits) {
    switch (outputUnits) {
      case Centimeters:
        return n / Units.DIU_PER_CENTIMETER;
      case Millimeters:
        return n / Units.DIU_PER_CENTIMETER * 10;
      case Inches:
        return n / Units.DIU_PER_INCH;
      default:
        return n;
    }
  },


  StringToUnitsType: function(s) {
    switch (s.ToLower()) {
      case \"in\":
      case \"inches\":
        return Units.Inches;

      case \"cm\":
      case \"centimeters\":
        return Units.Centimeters;

      case \"mm\":
      case \"millimeters\":
        return Units.Millimeters;

      case \"di\":
      case \"device-independent\":
        return Units.DeviceIndepenedent;

      default:
        return Units.DeviceIndepenedent;
    }
  },

  UnitsTypeToString: function(units) {
    switch (units) {
      case Units.Inches: return \"in\";
      case Units.Centimeters: return \"cm\";
      case Units.Millimeters: return \"mm\";
      case Units.DeviceIndepenedent: return \"device-independent\";
      default: return \"device-independent\";
    }
  }
}

export function DeviceIndependent(n) {
  return n;
}

export function Centimeters(n) {
  return Units.ToDeviceIndependent(n, Units.Centimeters);
}

export function Millimeters(n) {
  return Units.ToDeviceIndependent(n, Units.Millimeters);
}

export function Inches(n) {
  return Units.ToDeviceIndependent(n, Units.Inches);
}

export function ToCentimeters(n) {
  return Units.FromDeviceIndependent(n, Units.Centimeters);
}

export function ToMillimeters(n) {
  return Units.FromDeviceIndependent(n, Units.Millimeters);
}

export function ToInches(n) {
  return Units.FromDeviceIndependent(n, Units.Inches);
}


/*
 * Point
 */
export class Point {
  constructor(x, y) {
    this.x = (typeof x !== 'undefined') ? x : 0;
    this.y = (typeof y !== 'undefined') ? y : 0;
  }

  clone() {
    return new Point(this.x, this.y);
  }

  equals(point) {
    return this.x === point.x && this.y === point.y;
  }
}

/*
 * Rect
 */
export class Rect {
  constructor(x, y, width, height) {
    this.x = (typeof x !== 'undefined') ? x : Infinity;
    this.y = (typeof y !== 'undefined') ? y : Infinity;
    this.width = (typeof width !== 'undefined') ? width : -Infinity;
    this.height = (typeof height !== 'undefined') ? height : -Infinity;
  }

  clone() {
    return new Rect(this.x, this.y, this.width, this.height);
  }

  isEmpty() {
    return (this.x === Infinity &&
            this.y === Infinity &&
            this.width === -Infinity &&
            this.height === -Infinity);
  }

  // convenience method
  right() {
    return this.x + this.width;
  }

  bottom() {
    return this.y + this.height;
  }

  equals(rect) {
    return this.x === rect.x && this.y === rect.y &&
           this.width === rect.width && this.height === rect.height;
  }

  // other can be a Point or a Rect
  contains(other) {
    if (other instanceof Point) {
      return other.x >= this.x &&
              other.x <= this.x + this.width &&
              other.y >= this.y &&
              other.y <= this.y + this.height;
    } else { // better be instance of Rect
      return this.x <= other.x &&
              this.x + this.width >= other.x + other.width &&
              this.y <= other.y &&
              this.y + this.height >= other.y + other.height;
    }
  }

  union(rect) {

    var right = Math.max(this.x + this.width, rect.x + rect.width);
    var bottom = Math.max(this.y + this.height, rect.y + rect.height);

    this.x = Math.min(this.x, rect.x);
    this.y = Math.min(this.y, rect.y);

    this.width = right - this.x;
    this.height = bottom - this.y;
  }
}

/**
 * Margins
 *
 * @class
 */
export class Margins {
  constructor(left, top, right, bottom) {
    this.left = (typeof left !== 'undefined') ? left : 0;
    this.top = (typeof top !== 'undefined') ? top : 0;
    this.right = (typeof right !== 'undefined') ? right : 0;
    this.bottom = (typeof bottom !== 'undefined') ? bottom : 0;
  }

  clone() {
    return new Margins(this.left, this.top, this.right, this.bottom);
  }

  equals(margins) {
    return this.left === margins.left &&
        this.top === margins.top &&
        this.right === margins.right &&
        this.bottom === margins.bottom;
  }
}

/**
 * Size
 *
 * @class
 */
export class Size {
  constructor(width, height) {
    this.width = (typeof width !== 'undefined') ? width : 0;
    this.height = (typeof height !== 'undefined') ? height : 0;
  }

  clone() {
    return new Size(this.width, this.height);
  }

  equals(size) {
    return this.width === size.width && this.height === size.height;
  }
}


/*
 * Pitches, notes
 */
export var Step = {
  Do: 0,
  Du: 1,
  Re: 2,
  Me: 3,
  Mi: 4,
  Fa: 5,
  Fu: 6,
  So: 7,
  La: 9,
  Te: 10,
  Ti: 11
};

  // this little array helps map step values to staff positions. The numeric values of steps
  // correspond to whole step increments (2) or half step increments (1). This gives us the ability
  // to compare pitches precisely, but makes it challenging to place steps on the staff. this little
  // array maps the steps to an incremental position the steps take on the staff line. This works
  // so simply because chant only uses do and fa clefs, and only has a flatted ti (te), making
  // for relatively easy mapping to staff line locations.
  //                         Do Du Re Me Mi Fa Fu So    La Te Ti
var __StepToStaffPosition = [0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 6, 6];
var __StaffOffsetToStep = [Step.Do, Step.Re, Step.Mi, Step.Fa, Step.So, Step.La, Step.Ti]; // no accidentals in this one


export class Pitch {
  constructor(step, octave) {
    if(typeof octave === 'undefined') {
      octave = Math.floor(step / 12)
      step = step % 12;
    }
    this.step = step;
    this.octave = octave;
  }

  toInt() {
    return this.octave * 12 + this.step;
  }

  transpose(step) {
    return new Pitch(this.toInt() + step);
  }

  isHigherThan(pitch) {
    return this.toInt() > pitch.toInt();
  }

  isLowerThan(pitch) {
    return this.toInt() < pitch.toInt();
  }

  equals(pitch) {
    return this.toInt() === pitch.toInt();
  }

  static stepToStaffOffset(step) {
    return __StepToStaffPosition[step];
  }

  static staffOffsetToStep(offset) {
    while (offset < 0)
      offset = __StaffOffsetToStep.length + offset;

    return __StaffOffsetToStep[offset % __StaffOffsetToStep.length];
  }
}

export function generateRandomGuid() {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
      .toString(16)
      .substring(1);
  }
  return s4() + s4();
}

export function getCssForProperties(properties) {
  return Object.entries(properties)
    .map(([key, val]) =>
      key && val && key !== \"class\" ? `${key}: ${val};` : \"\"
    )
    .join(\"\");
}



// WEBPACK FOOTER //
// ./src/Exsurge.Core.js","//

/**
 * @class
 */
export class Language {
  constructor(name) {
    this.name = typeof name !== \"undefined\" ? name : \"<unknown>\";
    this.centerNeume = false;
  }

  /**
   * @param {String} text The string to parsed into words.
   * @return {Word[]} the resulting parsed words from syllabification
   */
  syllabify(text) {
    var parsedWords = [];

    if (typeof text === \"undefined\" || text === \"\") return parsedWords;

    // Divide the text into words separated by whitespace
    var words = text.split(/[\\s]+/);

    for (var i = 0, end = words.length; i < end; i++)
      parsedWords.push(this.syllabifyWord(words[i]));

    return parsedWords;
  }
}

export class English extends Language {
  constructor() {
    super(\"English\");
    this.centerNeume = true;
  }

  /**
   * @param {String} s the string to search
   * @param {Number} startIndex The index at which to start searching for a vowel in the string
   * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}
   */
  findVowelSegment(s, startIndex) {
    var regexLetter = /[a-z\\u0300-\\u0311äëïöüÿáéíóúýàèìòùỳāēīōūȳăĕĭŏŭæœ‿]+/i;
    var match = regexLetter.exec(s.slice(startIndex));
    if (match)
      return {
        found: true,
        startIndex: startIndex + match.index,
        length: match[0].length
      };

    // no vowels sets found after startIndex!
    return { found: false, startIndex: -1, length: -1 };
  }
}

/**
 * @class
 */
export class Latin extends Language {
  /**
   * @constructs
   */
  constructor() {
    super(\"Latin\");

    // fixme: ui is only diphthong in the exceptional cases below (according to Wheelock's Latin)
    this.diphthongs = [\"ae\", \"au\", \"oe\", \"aé\", \"áu\", \"oé\"];
    // for centering over the vowel, we will need to know any combinations that might be diphthongs:
    this.possibleDiphthongs = this.diphthongs.concat([
      \"ei\",
      \"eu\",
      \"ui\",
      \"éi\",
      \"éu\",
      \"úi\"
    ]);
    this.regexVowel = /(i|(?:[qg]|^)u)?([eé][iu]|[uú]i|[ao][eé]|[aá]u|[aeiouáéíóúäëïöüāēīōūăĕĭŏŭåe̊o̊ůæœǽyýÿ])/i;

    // some words that are simply exceptions to standard syllabification rules!
    var wordExceptions = new Object();

    // ui combos pronounced as diphthongs
    wordExceptions[\"huius\"] = [\"hui\", \"us\"];
    wordExceptions[\"cuius\"] = [\"cui\", \"us\"];
    wordExceptions[\"huic\"] = [\"huic\"];
    wordExceptions[\"cui\"] = [\"cui\"];
    wordExceptions[\"hui\"] = [\"hui\"];

    // eu combos pronounced as diphthongs
    wordExceptions[\"euge\"] = [\"eu\", \"ge\"];
    wordExceptions[\"seu\"] = [\"seu\"];

    this.vowels = [
      \"a\",
      \"e\",
      \"i\",
      \"o\",
      \"u\",
      \"á\",
      \"é\",
      \"í\",
      \"ó\",
      \"ú\",
      \"ä\",
      \"ë\",
      \"ï\",
      \"ö\",
      \"ü\",
      \"ā\",
      \"ē\",
      \"ī\",
      \"ō\",
      \"ū\",
      \"ă\",
      \"ĕ\",
      \"ĭ\",
      \"ŏ\",
      \"ŭ\",
      \"å\",
      \"e̊\",
      \"o̊\",
      \"ů\",
      \"æ\",
      \"œ\",
      \"ǽ\", // no accented œ in unicode?
      \"y\",
      \"ý\",
      \"ÿ\"
    ]; // y is treated as a vowel; not native to Latin but useful for words borrowed from Greek

    this.vowelsThatMightBeConsonants = [\"i\", \"u\"];

    this.muteConsonantsAndF = [\"b\", \"c\", \"d\", \"g\", \"p\", \"t\", \"f\"];

    this.liquidConsonants = [\"l\", \"r\"];
  }

  // c must be lowercase!
  isVowel(c) {
    for (var i = 0, end = this.vowels.length; i < end; i++)
      if (this.vowels[i] === c) return true;

    return false;
  }

  isVowelThatMightBeConsonant(c) {
    for (var i = 0, end = this.vowelsThatMightBeConsonants.length; i < end; i++)
      if (this.vowelsThatMightBeConsonants[i] === c) return true;

    return false;
  }

  // substring should be a vowel and the character following
  isVowelActingAsConsonant(substring) {
    return (
      this.isVowelThatMightBeConsonant(substring[0]) &&
      this.isVowel(substring[1])
    );
  }

  /**
   * f is not a mute consonant, but we lump it together for syllabification
   * since it is syntactically treated the same way
   *
   * @param {String} c The character to test; must be lowercase
   * @return {boolean} true if c is an f or a mute consonant
   */
  isMuteConsonantOrF(c) {
    for (var i = 0, end = this.muteConsonantsAndF.length; i < end; i++)
      if (this.muteConsonantsAndF[i] === c) return true;

    return false;
  }

  /**
   *
   * @param {String} c The character to test; must be lowercase
   * @return {boolean} true if c is a liquid consonant
   */
  isLiquidConsonant(c) {
    for (var i = 0, end = this.liquidConsonants.length; i < end; i++)
      if (this.liquidConsonants[i] === c) return true;

    return false;
  }

  /**
   *
   * @param {String} s The string to test; must be lowercase
   * @return {boolean} true if s is a diphthong
   */
  isDiphthong(s) {
    for (var i = 0, end = this.diphthongs.length; i < end; i++)
      if (this.diphthongs[i] === s) return true;

    return false;
  }

  /**
   *
   * @param {String} s The string to test; must be lowercase
   * @return {boolean} true if s is a diphthong
   */
  isPossibleDiphthong(s) {
    for (var i = 0, end = this.possibleDiphthongs.length; i < end; i++)
      if (this.possibleDiphthongs[i] === s) return true;

    return false;
  }

  /**
   * Rules for Latin syllabification (from Collins, \"A Primer on Ecclesiastical Latin\")
   *
   * Divisions occur when:
   *   1. After open vowels (those not followed by a consonant) (e.g., \"pi-us\" and \"De-us\")
   *   2. After vowels followed by a single consonant (e.g., \"vi-ta\" and \"ho-ra\")
   *   3. After the first consonant when two or more consonants follow a vowel
   *      (e.g., \"mis-sa\", \"minis-ter\", and \"san-ctus\").
   *
   * Exceptions:
   *   1. In compound words the consonants stay together (e.g., \"de-scribo\").
   *   2. A mute consonant (b, c, d, g, p, t) or f followed by a liquid consonant (l, r)
   *      go with the succeeding vowel: \"la-crima\", \"pa-tris\"
   *
   * In addition to these rules, Wheelock's Latin provides this sound exception:
   *   -  Also counted as single consonants are qu and the aspirates ch, ph,
   *      th, which should never be separated in syllabification:
   *      architectus, ar-chi-tec-tus; loquacem, lo-qua-cem.
   *
   */
  syllabifyWord(word) {
    var syllables = [];
    var haveCompleteSyllable = false;
    var previousWasVowel = false;
    var workingString = word.toLowerCase();
    var startSyllable = 0;

    var c, lookahead, haveLookahead;

    // a helper function to create syllables
    var makeSyllable = function(length) {
      if (haveCompleteSyllable) {
        syllables.push(word.substr(startSyllable, length));
        startSyllable += length;
      }

      haveCompleteSyllable = false;
    };

    for (var i = 0, wordLength = workingString.length; i < wordLength; i++) {
      c = workingString[i];

      // get our lookahead in case we need them...
      lookahead = \"*\";
      haveLookahead = i + 1 < wordLength;

      if (haveLookahead) lookahead = workingString[i + 1];

      var cIsVowel = this.isVowel(c);

      // i is a special case for a vowel. when i is at the beginning
      // of the word (Iesu) or i is between vowels (alleluia),
      // then the i is treated as a consonant (y)
      if (c === \"i\") {
        if (i === 0 && haveLookahead && this.isVowel(lookahead))
          cIsVowel = false;
        else if (previousWasVowel && haveLookahead && this.isVowel(lookahead)) {
          cIsVowel = false;
        }
      }

      if (c === \"-\") {
        // a hyphen forces a syllable break, which effectively resets
        // the logic...

        haveCompleteSyllable = true;
        previousWasVowel = false;
        makeSyllable(i - startSyllable);
        startSyllable++;
      } else if (cIsVowel) {
        // once we get a vowel, we have a complete syllable
        haveCompleteSyllable = true;

        if (
          previousWasVowel &&
          !this.isDiphthong(workingString[i - 1] + \"\" + c)
        ) {
          makeSyllable(i - startSyllable);
          haveCompleteSyllable = true;
        }

        previousWasVowel = true;
      } else if (haveLookahead) {
        if (
          (c === \"q\" && lookahead === \"u\") ||
          (lookahead === \"h\" && (c === \"c\" || c === \"p\" || c === \"t\"))
        ) {
          // handle wheelock's exceptions for qu, ch, ph and th
          makeSyllable(i - startSyllable);
          i++; // skip over the 'h' or 'u'
        } else if (previousWasVowel && this.isVowel(lookahead)) {
          // handle division rule 2
          makeSyllable(i - startSyllable);
        } else if (
          this.isMuteConsonantOrF(c) &&
          this.isLiquidConsonant(lookahead)
        ) {
          // handle exception 2
          makeSyllable(i - startSyllable);
        } else if (haveCompleteSyllable) {
          // handle division rule 3
          makeSyllable(i + 1 - startSyllable);
        }

        previousWasVowel = false;
      }
    }

    // if we have a complete syllable, we can add it as a new one. Otherwise
    // we tack the remaining characters onto the last syllable.
    if (haveCompleteSyllable) syllables.push(word.substr(startSyllable));
    else if (startSyllable > 0)
      syllables[syllables.length - 1] += word.substr(startSyllable);

    return syllables;
  }

  /**
   * @param {String} s the string to search
   * @param {Number} startIndex The index at which to start searching for a vowel in the string
   * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}
   */
  findVowelSegment(s, startIndex) {
    var match = this.regexVowel.exec(s.slice(startIndex));
    if (match) {
      if (match[1]) {
        // the first group should be ignored, as it is to separate an i or u that is used as a consonant.
        match.index += match[1].length;
      }
      return {
        found: true,
        startIndex: startIndex + match.index,
        length: match[2].length
      };
    }

    // no vowels sets found after startIndex!
    return { found: false, startIndex: -1, length: -1 };
  }
}

/**
 * @class
 */
export class Spanish extends Language {
  constructor() {
    super(\"Spanish\");

    this.vowels = [\"a\", \"e\", \"i\", \"o\", \"u\", \"y\", \"á\", \"é\", \"í\", \"ó\", \"ú\", \"ü\"];

    this.weakVowels = [\"i\", \"u\", \"ü\", \"y\"];

    this.strongVowels = [\"a\", \"e\", \"o\", \"á\", \"é\", \"í\", \"ó\", \"ú\"];

    this.diphthongs = [
      \"ai\",
      \"ei\",
      \"oi\",
      \"ui\",
      \"ia\",
      \"ie\",
      \"io\",
      \"iu\",
      \"au\",
      \"eu\",
      \"ou\",
      \"ua\",
      \"ue\",
      \"uo\",
      \"ái\",
      \"éi\",
      \"ói\",
      \"úi\",
      \"iá\",
      \"ié\",
      \"ió\",
      \"iú\",
      \"áu\",
      \"éu\",
      \"óu\",
      \"uá\",
      \"ué\",
      \"uó\",
      \"üe\",
      \"üi\"
    ];

    this.uDiphthongExceptions = [\"gue\", \"gui\", \"qua\", \"que\", \"qui\", \"quo\"];
  }

  // c must be lowercase!
  isVowel(c) {
    for (var i = 0, end = this.vowels.length; i < end; i++)
      if (this.vowels[i] === c) return true;

    return false;
  }

  /**
   * @param {String} c The character to test; must be lowercase
   * @return {boolean} true if c is an f or a mute consonant
   */
  isWeakVowel(c) {
    for (var i = 0, end = this.weakVowels.length; i < end; i++)
      if (this.weakVowels[i] === c) return true;

    return false;
  }

  /**
   * @param {String} c The character to test; must be lowercase
   * @return {boolean} true if c is an f or a mute consonant
   */
  isStrongVowel(c) {
    for (var i = 0, end = this.strongVowels.length; i < end; i++)
      if (this.strongVowels[i] === c) return true;

    return false;
  }

  /**
   *
   * @param {String} s The string to test; must be lowercase
   * @return {boolean} true if s is a diphthong
   */
  isDiphthong(s) {
    for (var i = 0, end = this.diphthongs.length; i < end; i++)
      if (this.diphthongs[i] === s) return true;

    return false;
  }

  createSyllable(text) {
    /*
    var accented = false;
    var ellidesToNext = false;

    if (text.length > 0) {

        if (text[0] == '`') {
            accented = true;
            text = text.substr(1);
        }

        if (text[text.length - 1] == '_') {
            ellidesToNext = true;
            text = text.substr(0, text.length - 1);
        }
    }

    var s = new Syllable(text);

    s.isMusicalAccent = accented;
    s.elidesToNext = ellidesToNext;*/

    return text;
  }

  /**
   */
  syllabifyWord(word) {
    var syllables = [];

    var haveCompleteSyllable = false;
    var previousIsVowel = false;
    var previousIsStrongVowel = false; // only valid if previousIsVowel == true
    var startSyllable = 0;

    // fixme: first check for prefixes

    for (var i = 0; i < word.length; i++) {
      var c = word[i].toLowerCase();

      if (this.isVowel(c)) {
        // we have a complete syllable as soon as we have a vowel
        haveCompleteSyllable = true;

        var cIsStrongVowel = this.isStrongVowel(c);

        if (previousIsVowel) {
          // if we're at a strong vowel, then we finish out the last syllable
          if (cIsStrongVowel) {
            if (previousIsStrongVowel) {
              syllables.push(
                this.createSyllable(
                  word.substr(startSyllable, i - startSyllable)
                )
              );
              startSyllable = i;
            }
          }
        }

        previousIsVowel = true;
        previousIsStrongVowel = cIsStrongVowel;
      } else {
        if (!haveCompleteSyllable) {
          // do nothing since we don't have a complete syllable yet...
        } else {
          // handle explicit syllable breaks
          if (word[i] === \"-\") {
            // start new syllable
            syllables.push(
              this.createSyllable(word.substr(startSyllable, i - startSyllable))
            );
            startSyllable = ++i;
          } else {
            var numberOfConsonants = 1,
              consonant2;

            // count how many more consonants there are
            for (var j = i + 1; j < word.length; j++) {
              if (this.isVowel(word[j])) break;
              numberOfConsonants++;
            }

            if (numberOfConsonants === 1) {
              // start new syllable
              syllables.push(
                this.createSyllable(
                  word.substr(startSyllable, i - startSyllable)
                )
              );
              startSyllable = i;
            } else if (numberOfConsonants === 2) {
              consonant2 = word[i + 1].toLowerCase();
              if (
                consonant2 === \"l\" ||
                consonant2 === \"r\" ||
                (c === \"c\" && consonant2 === \"h\")
              ) {
                // split before the consonant pair
                syllables.push(
                  this.createSyllable(
                    word.substr(startSyllable, i - startSyllable)
                  )
                );
                startSyllable = i++;
              } else {
                //split the consonants
                syllables.push(
                  this.createSyllable(
                    word.substr(startSyllable, ++i - startSyllable)
                  )
                );
                startSyllable = i;
              }
            } else if (numberOfConsonants === 3) {
              consonant2 = word[i + 1].toLowerCase();

              // if second consonant is s, divide cc-c, otherwise divide c-cc
              if (consonant2 === \"s\") {
                i += 2;
                syllables.push(
                  this.createSyllable(
                    word.substr(startSyllable, i - startSyllable)
                  )
                );
              } else
                syllables.push(
                  this.createSyllable(
                    word.substr(startSyllable, ++i - startSyllable)
                  )
                );

              startSyllable = i;
            } else if (numberOfConsonants === 4) {
              // four always get split cc-cc
              syllables.push(
                this.createSyllable(
                  word.substr(startSyllable, i - startSyllable + 2)
                )
              );
              startSyllable = i + 2;
              i += 3;
            }
          }

          haveCompleteSyllable = false;
        }

        previousIsVowel = false;
      }
    }

    // if we have a complete syllable, we can add it as a new one. Otherwise
    // we tack the remaining characters onto the last syllable.
    if (haveCompleteSyllable) syllables.push(word.substr(startSyllable));
    else if (startSyllable > 0)
      syllables[syllables.length - 1] += word.substr(startSyllable);
    else if (syllables.length === 0) syllables.push(this.createSyllable(word));

    return syllables;
  }

  /**
   * @param {String} s the string to search
   * @param {Number} startIndex The index at which to start searching for a vowel in the string
   * @retuns a custom class with three properties: {found: (true/false) startIndex: (start index in s of vowel segment) length ()}
   */
  findVowelSegment(s, startIndex) {
    var i, end, index;
    var workingString = s.toLowerCase();

    // do we have a diphthongs?
    for (i = 0, end = this.diphthongs.length; i < end; i++) {
      var d = this.diphthongs[i];
      index = workingString.indexOf(d, startIndex);

      if (index >= 0) {
        // check the exceptions...
        if (d[0] === \"u\" && index > 0) {
          var tripthong = s.substr(index - 1, 3).toLowerCase();

          for (
            let j = 0, endj = this.uDiphthongExceptions.length;
            i < endj;
            j++
          ) {
            if (tripthong === this.uDiphthongExceptions[j]) {
              // search from after the u...
              return this.findVowelSegment(s, index + 1);
            }
          }
        }

        return { found: true, startIndex: index, length: d.length };
      }
    }

    // no diphthongs. Let's look for single vowels then...
    for (i = 0, end = this.vowels.length; i < end; i++) {
      index = workingString.indexOf(this.vowels[i], startIndex);

      if (index >= 0) return { found: true, startIndex: index, length: 1 };
    }

    // no vowels sets found after startIndex!
    return { found: false, startIndex: -1, length: -1 };
  }
}

export const language = {
  english: new English(),
  latin: new Latin(),
  spanish: new Spanish()
};



// WEBPACK FOOTER //
// ./src/Exsurge.Text.js","//
// Author(s):
// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
//
// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the \"Software\"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

// generated based on the svg data
export let Glyphs = {
  None: {
    paths: [
      {
        type: \"positive\",
        data: \"\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    origin: {
      x: 0,
      y: 0
    },
    align: \"left\"
  },
  AcuteAccent: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M4 0C-.614.52-.614.52-.803-3.182l60.768-108.422c4.52-7.182 10.543-13.67 18.075-13.67 5.27 0 14.31 1.264 23.346 7.793 7.53 5.223 8.803 11.752 8.803 16.975 0 3.917-.52 11.1-8.05 17.628L4 0z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 0, // TODO: figure out a better way to align this horizontally.  width should be 110.992,
      height: 125.794
    },
    origin: {
      x: 0.803,
      y: 125.274
    },
    align: \"left\"
  },
  GraveAccent: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M105.386.26C110 .78 110 .78 110.189-2.922l-60.768-108.422c-4.52-7.182-10.543-13.67-18.075-13.67-5.27 0-14.31 1.264-23.346 7.793-7.53 5.223-8.803 11.752-8.803 16.975 0 3.917.52 11.1 8.05 17.628L105.386.26z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 0, //110.992,
      height: 125.794
    },
    origin: {
      x: 0, // -110.992,
      y: 125.274
    },
    align: \"left\"
  },
  Circle: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M0 -50A50 50 0 0 0 100 -50 50 50 0 0 0 0 -50M10 -50A40 40 0 0 1 90 -50 40 40 0 0 1 10 -50\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 100
    },
    origin: {
      x: -50,
      y: 100
    }
  },
  Semicircle: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M0 -50A50 50 0 0 0 100 -50 5 5 0 0 0 90 -50 40 40 0 0 1 10 -50 5 5 0 0 0 0 -50\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 55
    },
    origin: {
      x: -50,
      y: 50
    }
  },
  ReversedSemicircle: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M0 0A50 50 0 0 1 100 0 5 5 0 0 1 90 0 40 40 0 0 0 10 0 5 5 0 0 1 0 0\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 55
    },
    origin: {
      x: -50,
      y: 50
    }
  },
  Stropha: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M1.22-73.438c4.165 13.02 12.238 27.084 24.217 42.188L49.657 0 34.812 27.344C18.666 55.47-.084 72.396-21.438 78.124c4.687-3.645 7.03-8.593 7.03-14.843 0-8.853-4.947-20.572-14.843-35.155L-48 0 1.22-73.438z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 97.657,
      height: 151.562
    },
    origin: {
      x: 48,
      y: 73.438
    },
    align: \"left\"
  },
  BeginningAscLiquescent: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M-50 43.688V-61c4.167 7.292 12.76 10.938 25.78 10.938 9.376 0 20.053-1.563 32.032-4.688C31.773-60.48 45.833-71.677 50-88.344v117.97C43.75 42.645 32.812 51.5 17.187 56.186-.52 61.398-15.886 64-28.906 64-42.97 64-50 57.23-50 43.687z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 152.344
    },
    origin: {
      x: 50,
      y: 88.344
    },
    align: \"left\"
  },
  BeginningDesLiquescent: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M-50-56.03c0-13.022 7.03-19.532 21.094-19.532 13.02 0 28.385 2.604 46.093 7.812C32.813-63.583 43.75-54.73 50-41.187V76C45.833 59.854 31.77 48.656 7.812 42.406c-11.98-3.125-22.656-4.687-32.03-4.687-13.022 0-21.615 3.905-25.782 11.718v-105.47z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 151.562
    },
    origin: {
      x: 50,
      y: 75.562
    },
    align: \"left\"
  },
  CustosDescLong: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M39.063 273.472c5.73.52 7.29-6.25 4.687-20.312V-65.59c-13.542 2.083-24.22 5.468-32.03 10.156C3.905-50.226 0-43.714 0-35.904V71.91c5.73-5.21 10.677-8.594 14.844-10.157 5.73-1.562 12.24-2.343 19.53-2.343v196.875c0 11.458 1.563 17.187 4.688 17.187\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 46.353,
      height: 339.582
    },
    origin: {
      x: 0,
      y: 65.59
    },
    align: \"left\"
  },
  CustosDescShort: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M34.375 191.923c0 8.333 1.563 12.24 4.688 11.72 3.125-.522 4.687-7.033 4.687-19.533v-250c-13.542 2.084-24.22 5.47-32.03 10.157C3.905-50.525 0-44.015 0-36.203V71.61c5.73-5.208 10.677-8.593 14.844-10.156 5.73-1.562 12.24-2.344 19.53-2.344v132.813z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 43.75,
      height: 270.053
    },
    origin: {
      x: 0,
      y: 65.89
    },
    align: \"left\"
  },
  CustosLong: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M39.063-269.562c5.73-.52 7.29 6.25 4.687 20.312V69.5c-13.542-2.083-24.22-5.47-32.03-10.156C3.905 54.134 0 47.624 0 39.812V-68c5.73 5.208 10.677 8.594 14.844 10.156 5.73 1.563 12.24 2.344 19.53 2.344v-196.875c0-11.458 1.563-17.187 4.688-17.187z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 46.353,
      height: 339.582
    },
    origin: {
      x: 0,
      y: 270.082
    },
    align: \"left\"
  },
  CustosShort: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M34.375-188.125c0-8.333 1.563-12.24 4.688-11.72 3.125.522 4.687 7.033 4.687 19.532v250c-13.542-2.083-24.22-5.468-32.03-10.156C3.905 54.324 0 47.813 0 40V-67.813c5.73 5.21 10.677 8.594 14.844 10.157 5.73 1.562 12.24 2.344 19.53 2.343v-132.812z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 43.75,
      height: 270.052
    },
    origin: {
      x: 0,
      y: 200.365
    },
    align: \"left\"
  },
  DoClef: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M0 98.406V-97.688C0-118 5.99-134.275 17.97-146.516c11.978-12.24 27.603-18.36 46.874-18.36 10.937 0 19.53 3.126 25.78 9.376s9.376 14.583 9.376 25v107.813l-6.25-5.47c-4.167-3.645-10.287-7.42-18.36-11.327-8.072-3.907-16.796-5.86-26.17-5.86-11.46 0-21.486 4.427-30.08 13.282-8.593 8.854-12.89 19.53-12.89 32.03s4.297 23.308 12.89 32.423c8.594 9.115 18.62 13.672 30.08 13.672 9.374 0 18.098-1.822 26.17-5.468 8.073-3.646 14.193-7.292 18.36-10.938l6.25-6.25V132c0 9.896-3.125 18.1-9.375 24.61-6.25 6.51-14.844 9.765-25.78 9.765-19.272 0-34.897-6.25-46.876-18.75C5.99 135.125 0 118.72 0 98.405z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 331.251
    },
    origin: {
      x: 0,
      y: 164.876
    },
    align: \"left\"
  },
  FaClef: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M85.156-32v193.75c0 9.375-1.562 14.323-4.687 14.844-1.564 0-2.605-.52-3.126-1.563-.52-1.04-.782-2.603-.78-4.686V56.28c-8.335-8.332-19.793-12.5-34.376-12.5-17.71 0-31.77 3.907-42.188 11.72V-32c0-18.23 14.193-27.344 42.578-27.344 28.385 0 42.578 9.115 42.578 27.344zM98.438 93V-92.156c0-19.27 5.73-34.896 17.187-46.875 11.458-11.98 26.562-17.97 45.313-17.97 10.937 0 19.14 2.865 24.61 8.594 5.467 5.73 8.202 13.542 8.202 23.437v103.126l-5.47-4.687c-3.645-3.647-9.374-7.293-17.186-10.94-7.813-3.645-15.886-5.467-24.22-5.468-11.978 0-22.004 4.167-30.077 12.5-8.073 8.334-12.11 18.36-12.11 30.08 0 11.717 4.037 22.004 12.11 30.858s18.1 13.28 30.078 13.28c8.333 0 16.406-1.822 24.22-5.468 7.81-3.645 13.54-7.03 17.186-10.156l5.47-5.468V125.81c0 9.896-2.865 17.84-8.594 23.83-5.73 5.988-13.802 8.983-24.22 8.983-18.75 0-33.853-6.12-45.31-18.36-11.46-12.24-17.19-27.994-17.19-47.265z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 193.752,
      height: 333.595
    },
    origin: {
      x: 0.001,
      y: 157.001
    },
    align: \"left\"
  },
  Flat: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M7.813-204.406c4.166 0 6.25 5.208 6.25 15.625L12.5-10.657C33.854 13.302 54.167 25.28 73.438 25.28c9.374 0 14.062-4.686 14.062-14.06 0-6.25-1.042-11.72-3.125-16.407-2.083-4.688-7.03-9.766-14.844-15.235-7.81-5.47-13.02-8.984-15.624-10.547L27.344-45.81V-80.97c17.187 0 33.073 4.82 47.656 14.454C89.583-56.88 96.875-47.376 96.875-38c0 67.708-.26 101.562-.78 101.563-38.543 0-69.532-12.24-92.97-36.72C0-52.322-1.042-123.936 0-188c0-10.937 2.604-16.406 7.813-16.406z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 97.917,
      height: 267.969
    },
    origin: {
      x: 1.042,
      y: 204.406
    },
    align: \"left\"
  },
  Mora: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M47.478-24c6.957 0 12.793 2.288 17.49 6.883C69.662-12.52 72-6.904 72-.267c0 6.64-2.337 12.352-7.033 17.118C60.27 21.618 54.435 24 47.477 24c-6.26 0-11.748-2.383-16.444-7.15C26.337 12.086 24 6.374 24-.265c0-6.638 2.337-12.255 7.033-16.85C35.73-21.713 41.217-24 47.478-24z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 48,
      height: 48
    },
    origin: {
      x: -24,
      y: 24
    },
    align: \"left\"
  },
  Natural: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M7.906-166.563c-2.864 0-5.614.52-8.218 1.563v13.28l.78 56.25.782 78.907v85.157c.52 3.646 2.604 5.73 6.25 6.25l23.438-3.906 23.437-3.907v29.69c0 42.186-.26 63.54-.78 64.06l6.25 2.345c1.04.52 2.082.78 3.124.78 2.603 0 4.947-1.3 7.03-3.905L67.656-71.25c-.52-2.604-2.083-3.906-4.687-3.906-7.814 0-17.19 1.04-28.126 3.125l-19.53 3.124.78-38.28V-165c-2.604-1.042-5.323-1.562-8.188-1.563zM55.938-40v71.875l-41.407 7.03c0-48.436.262-72.655.783-72.655L55.938-40z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 70.311,
      height: 330.469
    },
    origin: {
      x: 0.312,
      y: 166.563
    },
    align: \"left\"
  },
  Sharp: {
    paths: [
      {
        type: \"positive\",
        data:
          \"m41.725,-73.773c-5.421,-0.241-10.878,5.856-6.549,12.357L67.061,-20.473 61.264,-12.5 13.436,-71.199c-5.634,-5.934-16.988,1.032-11.232,9.783L50.756,0.182 2.203,61.416c-6.745,7.984 3.442,17.859 11.232,9.783L61.264,12.5l5.797,7.973-31.885,40.943c-5.578,6.844 5.588,16.005 11.594,9.783L77.568,33.154 108.367,71.199c4.894,6.717 17.343,-1.575 11.232,-9.783L87.715,20.473 93.873,12.5 141.34,71.199c6.725,7.67 17.509,-2.248 11.596,-9.783L104.02,0.182 152.936,-61.416c5.52,-7.02-5.541,-16.309-11.596,-9.783L93.873,-12.5l-6.158,-7.973 31.884766,-40.943c5.407,-7.045-5.505,-15.924-11.232,-9.783L77.568,-33.154 46.77,-71.199c-1.435,-1.708-3.238,-2.494-5.044922,-2.574zM77.568,-8.516 84.09,0.182 77.568,8.516 70.684,0.182Z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 154.646,
      height: 147.987
    },
    origin: {
      x: 0,
      y: 74.098
    },
    align: \"left\"
  },
  OriscusAsc: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M50 30.25c0 12.5-3.125 21.354-9.375 26.562-3.125 2.605-7.813 3.907-14.063 3.907-3.125 0-5.99-.522-8.593-1.564-2.605-1.04-5.6-2.474-8.986-4.297C5.6 53.035 2.734 51.603.39 50.56c-2.343-1.04-5.338-2.474-8.984-4.296-3.646-1.823-6.77-3.256-9.375-4.297-2.603-1.043-5.468-1.564-8.593-1.564-6.25 0-10.937 1.563-14.062 4.688C-46.875 50.824-50 59.677-50 71.656v-106.25c0-13.02 3.125-21.875 9.375-26.562 3.125-2.604 7.813-3.906 14.063-3.907 3.125 0 5.99.52 8.593 1.563 2.605 1.042 5.73 2.474 9.376 4.297 3.646 1.823 6.51 2.995 8.594 3.516l10.938 5.468c6.25 3.126 11.458 4.69 15.624 4.69 6.25 0 10.938-1.564 14.063-4.69C46.875-55.426 50-64.02 50-76V30.25z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 147.656
    },
    origin: {
      x: 50,
      y: 76
    },
    align: \"left\"
  },
  OriscusDes: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M-50 30.844v-106.25c0 11.458 3.125 20.052 9.375 25.78 3.125 3.126 7.813 4.69 14.063 4.688 4.687 0 13.41-3.255 26.17-9.765 12.762-6.51 21.746-9.766 26.954-9.766 6.25 0 10.938 1.303 14.063 3.907C46.875-55.874 50-47.02 50-34V72.25c0-11.98-3.125-20.833-9.375-26.563C37.5 42.563 32.812 41 26.562 41 21.875 41 13.023 44.385 0 51.156c-4.167 2.604-8.594 4.948-13.28 7.032-4.69 2.083-9.116 3.124-13.283 3.124-6.25 0-10.937-1.302-14.062-3.906C-46.875 52.198-50 43.344-50 30.844z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 147.656
    },
    origin: {
      x: 50,
      y: 75.406
    },
    align: \"left\"
  },
  OriscusLiquescent: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M 19.055,78.887 C 20.242,78.487 21.532,77.890 22.925,77.097 24.318,76.304 26.700882,74.417 30.074,71.438 33.447,68.458 36.524,64.985 39.303,61.019 42.083,57.052 44.563,51.396 46.743,44.05 48.923,36.704 50.013,28.671 50.013,19.950525 L 50.013,-34.226 C 50.013,-54.464 42.074,-64.584 26.195,-64.584 20.248,-64.584 11.519,-61.410 0.007,-55.064 -11.506,-48.717 -20.235,-45.544 -26.182,-45.544 -34.515,-45.544 -40.568,-48.520 -44.340791,-54.473 -48.114,-60.426 -50.000,-67.369 -50.000,-75.303 L -50.000,30.07 C -50.000,49.909 -42.060754,59.829 -26.182,59.829 -21.023,59.829 -12.39,56.455 -0.284,49.709 11.822,42.963 20.648,39.59 26.195,39.59 29.369,40.777 30.362,44.25 29.17479,50.009 27.988,55.768 26.001,62.020829 23.216,68.767 z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 147.656
    },
    origin: {
      x: 50,
      y: 75.406
    },
    align: \"left\"
  },
  PodatusLower: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M-4.688-30.28c22.396 0 34.636-.262 36.72-.782 5.728-1.563 8.593-5.21 8.593-10.938H50v97.656c0 2.604-1.302 4.167-3.906 4.688-5.21.52-21.355.78-48.438.78-23.958 0-38.54-.26-43.75-.78-2.604 0-3.906-1.302-3.906-3.906v-82.032c0-3.646 1.302-5.468 3.906-5.468h2.344c2.604.52 15.625.78 39.063.78z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 103.124
    },
    origin: {
      x: 50,
      y: 42
    },
    align: \"left\"
  },
  PodatusUpper: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M-46.094-63.78c13.542 0 24.61 2.473 33.203 7.42C-4.298-51.41 0-43.99 0-34.093V62h-9.375c0-10.938-2.604-19.14-7.812-24.61-5.21-5.468-14.844-8.203-28.907-8.202-18.23 0-33.333 4.166-45.312 12.5v-75.782c0-19.79 15.104-29.687 45.312-29.687z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 91.406,
      height: 125.781
    },
    origin: {
      x: 91.406,
      y: 63.781
    },
    align: \"right\"
  },
  Porrectus1: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M233.594 162.875c-58.855 0-107.032-6.25-144.53-18.75C34.895 125.895-11.46 99.855-50 66V-52.75C-21.354-24.625 26.302 6.885 92.97 41.78 123.697 57.928 163.54 66 212.5 66c21.354 0 34.635-9.896 39.844-29.688V151.94c0 7.29-6.25 10.937-18.75 10.937z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 302.344,
      height: 215.627
    },
    origin: {
      x: 50,
      y: 52.75
    },
    align: \"left\"
  },
  Porrectus2: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M309.375 259.375c-50.52 0-110.938-22.396-181.25-67.188C48.437 141.667-10.938 94.272-50 50V-68.75C0-3.125 60.417 52.083 131.25 96.875c58.333 36.98 110.677 58.854 157.03 65.625h7.033c16.145 0 26.822-9.896 32.03-29.688v114.844c0 7.812-5.99 11.72-17.968 11.72z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 377.343,
      height: 328.126
    },
    origin: {
      x: 50,
      y: 68.75
    },
    align: \"left\"
  },
  Porrectus3: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M309.375 355.78c-48.96-16.666-109.115-55.468-180.47-116.405C79.428 198.23 19.793 134.687-50 48.75V-70C20 40 94.104 103.79 135.25 148.063 190 200 230 230 288.28 258.906c4.168 2.083 8.334 3.125 12.5 3.125 12.5 0 21.355-10.937 26.564-32.81v114.06c0 9.376-3.386 14.063-10.156 14.064-2.084 0-4.688-.522-7.813-1.563z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 377.344,
      height: 427.345
    },
    origin: {
      x: 50,
      y: 70
    },
    align: \"left\"
  },
  Porrectus4: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M350 453.438c-52.754-22.397-120-77.345-201.74-164.844C90.87 227.656 24.784 147.708-50 48.75V-70C-8.84-1.25 58.406 86.51 151.74 193.28c60.868 69.793 119.13 124.22 174.782 163.282 5.797 3.646 11.014 5.47 15.652 5.47 12.173 0 21.45-11.72 27.826-35.157V441.72c0 9.373-3.19 14.06-9.565 14.06-2.9 0-6.377-.78-10.435-2.342z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 420,
      height: 525.78
    },
    origin: {
      x: 50,
      y: 70
    },
    align: \"left\"
  },
  PunctumCavum: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M0-60.906c33.333 0 50 9.635 50 28.906v94.53C39.062 51.595 22.396 46.126 0 46.126s-39.063 5.47-50 16.406V-32c0-19.27 16.667-28.906 50-28.906z\"
      },
      {
        type: \"negative\",
        data:
          \"M.08-42.56c9.585.206 20.126.53 27.954 6.822 4.96 3.9 4.71 10.792 4.574 16.482v51.278C22.09 27.066 7.283 26.072.168 26.01c-7.72.23-21.895.935-32.616 4.674.04-19.197-.083-38.395.064-57.59.567-7.5 7.834-12.33 14.62-13.774 5.818-1.498 11.857-1.86 17.844-1.88z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 123.438
    },
    origin: {
      x: 50,
      y: 60.906
    },
    align: \"left\"
  },
  PunctumQuadratum: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M0-60.906c33.333 0 50 9.635 50 28.906v94.53C39.062 51.595 22.396 46.126 0 46.126s-39.063 5.47-50 16.406V-32c0-19.27 16.667-28.906 50-28.906z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 123.438
    },
    origin: {
      x: 50,
      y: 60.906
    },
    align: \"left\"
  },
  PunctumQuadratumLiquescent: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M0-36.5436c19.999799999999997 0 30 5.781 30 17.3436v56.717999999999996C23.437199999999997 30.956999999999997 13.4376 27.6756 0 27.6756s-23.4378 3.2819999999999996-30 9.843599999999999V-19.2c0-11.562 10.000200000000001-17.3436 30-17.3436z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 123.438
    },
    origin: {
      x: 50,
      y: 60.906
    },
    align: \"left\"
  },
  PunctumQuadratumAscLiquescent: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M-50 43.688V-61c4.167 7.292 12.76 10.938 25.78 10.938 9.376 0 20.053-1.563 32.032-4.688C31.773-60.48 45.833-71.677 50-88.344v117.97C43.75 42.645 32.812 51.5 17.187 56.186-.52 61.398-15.886 64-28.906 64-42.97 64-50 57.23-50 43.687z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 152.344
    },
    origin: {
      x: 50,
      y: 88.344
    },
    align: \"left\"
  },
  PunctumQuadratumDesLiquescent: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M-50-56.03c0-13.022 7.03-19.532 21.094-19.532 13.02 0 28.385 2.604 46.093 7.812C32.813-63.583 43.75-54.73 50-41.187V76C45.833 59.854 31.77 48.656 7.812 42.406c-11.98-3.125-22.656-4.687-32.03-4.687-13.022 0-21.615 3.905-25.782 11.718v-105.47z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 151.562
    },
    origin: {
      x: 50,
      y: 75.562
    },
    align: \"left\"
  },
  PunctumInclinatum: {
    paths: [
      {
        type: \"positive\",
        data: \"M0-75.78L50 0 0 75-50 0 0-75.78z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 150.78
    },
    origin: {
      x: 50,
      y: 75.78
    },
    align: \"left\"
  },
  PunctumInclinatumLiquescent: {
    paths: [
      {
        type: \"positive\",
        data: \"M 0,-53.164 35,-0.117 0,52.383 -35,-0.117 0,-53.164 z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 105.546
    },
    origin: {
      x: 50,
      y: 53.164
    },
    align: \"left\"
  },
  Quilisma: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M-50 34.938V-51c5.73 20.833 13.02 31.25 21.875 31.25 7.813 0 12.5-15.625 14.063-46.875 3.645 12.5 6.9 21.224 9.765 26.172s6.9 7.422 12.11 7.422c5.208 0 9.374-14.324 12.5-42.97 5.73 22.917 10.677 34.375 14.843 34.375 5.73 0 10.677-15.885 14.844-47.656v100c0 17.707-3.125 26.56-9.375 26.56-4.688 0-9.115-5.988-13.28-17.968-2.085 21.875-8.074 32.813-17.97 32.813-7.813 0-16.146-7.292-25-21.875-4.688 20.312-10.677 30.47-17.97 30.47-5.207 0-9.244-2.605-12.108-7.814C-48.568 47.698-50 41.708-50 34.938z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 150
    },
    origin: {
      x: 50,
      y: 89.282
    },
    align: \"left\"
  },
  TerminatingAscLiquescent: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M-9.375 40.22c0-11.98-4.948-17.97-14.844-17.97-10.936 0-19.53 3.646-25.78 10.938v-53.126c0-6.77 2.604-12.76 7.813-17.968 5.208-5.21 10.677-8.594 16.406-10.157 2.603-.52 5.207-.78 7.81-.78 3.647 0 7.032.78 10.157 2.343C-2.603-43.896 0-39.73 0-34V73.03h-9.375V40.22z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 49.999,
      height: 121.873
    },
    origin: {
      x: 49.999,
      y: 48.843
    },
    align: \"right\"
  },
  TerminatingDesLiquescent: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M-9.375-48.156V-80.97H0V26.845c0 5.73-2.604 9.896-7.813 12.5-3.125 1.562-6.51 2.343-10.156 2.343-2.603 0-5.207-.26-7.81-.78-5.73-1.563-11.2-4.95-16.407-10.157C-47.398 25.542-50 19.292-50 12v-52.344c6.25 7.292 14.844 10.938 25.78 10.938 9.897 0 14.845-6.25 14.845-18.75z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 50,
      height: 122.658
    },
    origin: {
      x: 50,
      y: 80.97
    },
    align: \"right\"
  },
  VerticalEpisemaAbove: {
    paths: [
      {
        type: \"positive\",
        data: \"M-8-4c2 3 6 4 8 4s6-1 8-4v-52c-2-3-6-4-8-4s-6 1-8 4z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 16,
      height: 60
    },
    origin: {
      x: 8,
      y: 60
    },
    align: \"left\"
  },
  VerticalEpisemaBelow: {
    paths: [
      {
        type: \"positive\",
        data: \"M-8 56c2 3 6 4 8 4s6-1 8-4v-52c-2-3-6-4-8-4s-6 1-8 4z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 16,
      height: 60
    },
    origin: {
      x: 8,
      y: 0
    },
    align: \"left\"
  },
  VirgaLong: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M50-38v285.156c0 6.77-2.344 10.937-7.03 12.5-1.564 0-2.605-.78-3.126-2.344-.52-1.562-.782-10.156-.782-25.78V54.186C29.168 45.334 16.146 40.907 0 40.907c-22.917 0-39.583 5.208-50 15.624V-38c0-19.27 16.667-28.906 50-28.906S50-57.27 50-38z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 326.562
    },
    origin: {
      x: 50,
      y: 66.906
    },
    align: \"left\"
  },
  VirgaShort: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M50-38v211.72c0 7.29-2.344 11.457-7.03 12.5-1.564 0-2.606-.783-3.126-2.345-.52-1.563-.782-10.156-.782-25.78V54.187C29.167 45.332 16.146 40.906 0 40.906c-22.917 0-39.583 5.21-50 15.625V-38c0-19.27 16.667-28.906 50-28.906S50-57.27 50-38z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 100,
      height: 253.126
    },
    origin: {
      x: 50,
      y: 66.906
    },
    align: \"left\"
  },
  Virgula: {
    paths: [
      {
        type: \"positive\",
        data:
          \"M8.178-55.66c0-22.137 12.092-33.2 36.287-33.2 11.835 0 23.53 5.66 35.108 16.98C91.15-60.547 96.94-41.766 96.94-15.534c0 53.515-31.646 87.487-94.937 101.895-2.048-2.06-3.077-5.146-3.077-9.273 0-1.03.247-1.8.76-2.316 42.71-19.027 64.075-41.678 64.075-67.92 0-11.322-2.325-20.326-6.945-27.016-4.62-6.69-9.52-11.052-14.676-13.11-5.147-2.048-11.836-3.85-20.07-5.403C12.81-39.707 8.18-45.37 8.18-55.66z\"
      }
    ],
    bounds: {
      x: 0,
      y: 0,
      width: 98.014,
      height: 175.221
    },
    origin: {
      x: 1.074,
      y: 88.86
    },
    align: \"left\"
  }
};



// WEBPACK FOOTER //
// ./src/Exsurge.Glyphs.js","//
// Author(s):
// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
//
// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the \"Software\"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

import {
  getCssForProperties, Point,
  Rect
} from \"./Exsurge.Core.js\";
import { Glyphs } from \"./Exsurge.Glyphs.js\";
import { language } from \"./Exsurge.Text.js\";
import { addAccent } from \"./addAccent.js\";
import { makeLigature } from \"./makeLigature.js\";
import { greextraGlyphs } from \"./greextraGlyphs.js\";

function getFontFilenameForProperties(properties = {}, url = \"{}\") {
  var italic = properties[\"font-style\"] === \"italic\" ? \"Italic\" : \"\",
    bold = properties[\"font-weight\"] === \"bold\" ? \"Bold\" : \"\";
  return url.replace(
    \"{}\",
    `${italic || bold ? `${bold}${italic}` : `Regular`}`
  );
}

// load in the web font for special chant characters here:
// var __exsurgeCharactersFont = require(\"url?limit=30000!../assets/fonts/ExsurgeChar.otf\")

const canAccessDOM = typeof document !== \"undefined\";

const __getNeumeFromSvgElem = (score, elem) => {
  let note =
    score.notes[
      elem.parentElement
        .querySelector(\"[element-index]\")
        .getAttribute(\"element-index\")
    ];
  return note.neume || note;
};

// for positioning markings on notes
export var MarkingPositionHint = {
  Default: 0,
  Above: 1,
  Below: 2
};

/**
 * List of types of text and their defaults relative to lyrics
 * @type Array
 */
export const TextTypes = {
  supertitle: {
    display: \"Supertitle\",
    defaultSize: (size) => (size * 7) / 6, // 14pt
    containedInScore: (score) => score.titles.hasSupertitle(),
    getFromScore: (score) => score.titles.supertitle
  },
  title: {
    display: \"Title\",
    defaultSize: (size) => (size * 3) / 2, // 18pt
    containedInScore: (score) => score.titles.hasTitle(),
    getFromScore: (score) => score.titles.title
  },
  subtitle: {
    display: \"Subtitle\",
    defaultSize: (size) => size, // 12pt
    containedInScore: (score) => score.titles.hasSubtitle(),
    getFromScore: (score) => score.titles.subtitle
  },
  leftRight: {
    display: \"Left / Right Text\",
    cssClass: \"textLeftRight\",
    defaultSize: (size) => size * 0.9,
    containedInScore: (score) =>
      score.titles.hasTextLeft() || score.titles.hasTextRight(),
    getFromScore: (score, elem) => score.titles[elem.extraClass],
    getFromSvgElem: (score, elem) =>
      score.titles[
        elem.classList.contains(\"textRight\") ? \"textRight\" : \"textLeft\"
      ]
  },
  annotation: {
    display: \"Annotation\",
    defaultSize: (size) => (size * 2) / 3,
    containedInScore: (score) =>
      !!score.annotation &&
      (!score.mergeAnnotationWithTextLeft || score.dropCap),
    getFromScore: (score, { elementIndex = 0 }) =>
      score.annotation &&
      (score.annotation.annotations
        ? score.annotation.annotations[elementIndex]
        : score.annotation)
  },
  dropCap: {
    display: \"Drop Cap\",
    defaultSize: (size) => size * 4,
    containedInScore: (score) => !!score.dropCap,
    getFromScore: (score) => score.dropCap
  },
  al: {
    display: \"Above Staff\",
    cssClass: \"aboveLinesText\",
    defaultSize: (size) => size,
    containedInScore: (score) => score.hasAboveLinesText,
    getFromScore: (score, elem) =>
      score.notations[elem.notation.notationIndex].alText[elem.alIndex],
    getFromSvgElem: (score, elem) =>
      __getNeumeFromSvgElem(score, elem).alText[
        elem.getAttribute(\"al-index\") || 0
      ]
  },
  choralSign: {
    display: \"Choral Sign\",
    size: (ctxt) => ctxt.staffInterval * 1.5,
    containedInScore: (score) => false,
    getFromScore: (score, elem) =>
      score.notes[elem.note.elementIndex].choralSign
  },
  lyric: {
    display: \"Lyric\",
    defaultSize: (size) => size * 0.9,
    containedInScore: (score) => score.hasLyrics,
    getFromScore: (score, elem) =>
      score.notations[elem.notation.notationIndex].lyrics[elem.lyricIndex],
    getFromSvgElem: (score, elem) =>
      __getNeumeFromSvgElem(score, elem).lyrics[
        elem.getAttribute(\"lyric-index\") || 0
      ]
  },
  translation: {
    display: \"Translation\",
    defaultSize: (size) => size * 0.75,
    containedInScore: (score) => score.hasTranslations,
    getFromScore: (score, elem) =>
      score.notations[elem.notation.notationIndex].translationText[
        elem.translationIndex
      ],
    getFromSvgElem: (score, elem) =>
      __getNeumeFromSvgElem(score, elem).translationText[
        elem.getAttribute(\"translation-index\") || 0
      ]
  }
};
export const TextTypesByClass = {};
Object.entries(TextTypes).forEach(([key, entry]) => {
  let cssClass = (entry.cssClass = entry.cssClass || key);
  entry.key = key;
  TextTypesByClass[cssClass] = entry;
});

export const DefaultTrailingSpace = (ctxt) =>
  ctxt.intraNeumeSpacing * ctxt.interSyllabicMultiplier;
DefaultTrailingSpace.isDefault = true;

export let GlyphCode = {
  None: \"None\",

  AcuteAccent: \"AcuteAccent\",
  GraveAccent: \"GraveAccent\",
  Circle: \"Circle\",
  Semicircle: \"Semicircle\",
  ReversedSemicircle: \"ReversedSemicircle\",
  Stropha: \"Stropha\",
  StrophaLiquescent: \"StrophaLiquescent\",

  BeginningAscLiquescent: \"BeginningAscLiquescent\",
  BeginningDesLiquescent: \"BeginningDesLiquescent\",

  CustosDescLong: \"CustosDescLong\",
  CustosDescShort: \"CustosDescShort\",
  CustosLong: \"CustosLong\",
  CustosShort: \"CustosShort\",

  // clefs and other markings
  DoClef: \"DoClef\",
  FaClef: \"FaClef\",
  Flat: \"Flat\",
  Mora: \"Mora\",
  Natural: \"Natural\",
  OriscusAsc: \"OriscusAsc\",
  OriscusDes: \"OriscusDes\",
  OriscusLiquescent: \"OriscusLiquescent\",

  PodatusLower: \"PodatusLower\",
  PodatusUpper: \"PodatusUpper\",

  Porrectus1: \"Porrectus1\", // 1 staff line difference,
  Porrectus2: \"Porrectus2\", // 2 lines difference, etc...
  Porrectus3: \"Porrectus3\",
  Porrectus4: \"Porrectus4\",

  PunctumCavum: \"PunctumCavum\",
  PunctumQuadratum: \"PunctumQuadratum\",
  PunctumQuadratumLiquescent: \"PunctumQuadratumLiquescent\",
  PunctumQuadratumAscLiquescent: \"PunctumQuadratumAscLiquescent\",
  PunctumQuadratumDesLiquescent: \"PunctumQuadratumDesLiquescent\",
  PunctumInclinatum: \"PunctumInclinatum\",
  PunctumInclinatumLiquescent: \"PunctumInclinatumLiquescent\",
  Quilisma: \"Quilisma\",

  Sharp: \"Sharp\",
  TerminatingAscLiquescent: \"TerminatingAscLiquescent\",
  TerminatingDesLiquescent: \"TerminatingDesLiquescent\",
  VerticalEpisemaAbove: \"VerticalEpisemaAbove\",
  VerticalEpisemaBelow: \"VerticalEpisemaBelow\",
  VirgaLong: \"VirgaLong\",
  VirgaShort: \"VirgaShort\",
  Virgula: \"Virgula\",

  UpperBrace: \"UpperBrace\"
}; // GlyphCode

export var QuickSvg = {
  // namespaces
  ns: \"http://www.w3.org/2000/svg\",
  xmlns: \"http://www.w3.org/2000/xmlns/\",
  xlink: \"http://www.w3.org/1999/xlink\",

  hasDOMAccess: function () {
    return canAccessDOM;
  },

  // create the root level svg object
  svg: function (width, height) {
    var node = document.createElementNS(this.ns, \"svg\");

    node.setAttribute(\"xmlns\", this.ns);
    node.setAttribute(\"version\", \"1.1\");
    node.setAttributeNS(this.xmlns, \"xmlns:xlink\", this.xlink);

    node.setAttribute(\"width\", width);
    node.setAttribute(\"height\", height);

    // create the defs element
    var defs = document.createElementNS(this.ns, \"defs\");
    node.appendChild(defs);

    node.defs = defs;

    node.clearNotations = function () {
      // clear out all children except defs
      node.removeChild(defs);

      while (node.hasChildNodes()) node.removeChild(node.lastChild);

      node.appendChild(defs);
    };

    return node;
  },

  rect: function (width, height) {
    var node = document.createElementNS(this.ns, \"rect\");

    node.setAttribute(\"width\", width);
    node.setAttribute(\"height\", height);

    return node;
  },

  line: function (x1, y1, x2, y2) {
    var node = document.createElementNS(this.ns, \"line\");

    node.setAttribute(\"x1\", x1);
    node.setAttribute(\"y1\", y1);
    node.setAttribute(\"x2\", x2);
    node.setAttribute(\"y2\", y2);

    return node;
  },

  g: function () {
    var node = document.createElementNS(this.ns, \"g\");

    return node;
  },

  text: function () {
    var node = document.createElementNS(this.ns, \"text\");

    return node;
  },

  tspan: function (str) {
    var node = document.createElementNS(this.ns, \"tspan\");
    node.textContent = str;

    return node;
  },

  // nodeRef should be the id of the object in defs (without the #)
  use: function (nodeRef) {
    var node = document.createElementNS(this.ns, \"use\");
    node.setAttributeNS(this.xlink, \"xlink:href\", \"#\" + nodeRef);

    return node;
  },

  svgFragmentForGlyph: function (glyph) {
    var svgSrc = \"\";
    for (var i = 0; i < glyph.paths.length; ++i) {
      var path = glyph.paths[i];
      svgSrc += QuickSvg.createFragment(path.data ? \"path\" : \"g\", {
        d: path.data || undefined,
        fill: path.type === \"negative\" ? \"#fff\" : undefined
      });
    }
    return svgSrc;
  },

  nodesForGlyph: function (glyph, functionName = \"createNode\") {
    var nodes = [];
    for (var i = 0; i < glyph.paths.length; ++i) {
      var path = glyph.paths[i];
      let props = {};
      if (path.data) props.d = path.data;
      if (path.type === \"negative\") props.fill = \"#fff\";
      nodes.push(QuickSvg[functionName](path.data ? \"path\" : \"g\", props));
    }
    return nodes;
  },

  createNode: function (name, attributes, children) {
    var node = document.createElementNS(this.ns, name);
    if (attributes && attributes.source) {
      node.source = attributes.source;
      delete attributes.source;
    }
    for (var attr in attributes) {
      if (
        attributes.hasOwnProperty(attr) &&
        typeof attributes[attr] !== \"undefined\"
      ) {
        var val = attributes[attr];
        var match = attr.match(/^([^:]+):([^:]+)$/);
        if (match) {
          node.setAttributeNS(this[match[1]], match[2], val);
        } else {
          node.setAttribute(attr, val);
        }
      }
    }
    if (children) {
      if (typeof children === \"string\") {
        node.textContent = children;
      } else if (children.constructor === [].constructor) {
        for (var i = 0; i < children.length; ++i) {
          node.appendChild(children[i]);
        }
      } else {
        node.appendChild(children);
      }
    }
    return node;
  },

  createSvgTree(name, props, ...children) {
    if (\"class\" in props) {
      props.className = props.class;
      delete props.class;
    }
    if (children.length === 1 && children[0] instanceof Array) {
      children = children[0];
    }
    const convertKeysToCamelCase = (obj) => {
      for (let key of Object.keys(obj)) {
        if (/[-:][a-z]/.test(key)) {
          if (/^\\w+-index$/.test(key)) continue;
          let camelCase = key.replace(/[-:]([a-z])/g, (whole, letter) =>
            letter.toUpperCase()
          );
          obj[camelCase] = obj[key];
          delete obj[key];
        }
      }
    };
    convertKeysToCamelCase(props);
    if (props.style) convertKeysToCamelCase(props.style);
    let source = props.source;
    if (source && source.sourceGabc) {
      props[\"source-gabc\"] = source.sourceGabc;
    }
    return { name, props, children };
  },

  createFragment: function (name, attributes, child) {
    if (child === undefined || child === null) child = \"\";

    var fragment = \"<\" + name + \" \";

    for (var attr in attributes) {
      if (
        attributes.hasOwnProperty(attr) &&
        typeof attributes[attr] !== \"undefined\"
      )
        fragment += attr + '=\"' + attributes[attr] + '\" ';
    }

    fragment += \">\" + child + \"</\" + name + \">\";

    return fragment;
  },

  parseFragment: function (fragment) {
    // create temporary holder
    var well = document.createElement(\"svg\");

    // act as a setter if svg is given
    if (fragment) {
      var container = this.g();

      // dump raw svg
      // do this to allow the browser to automatically create svg nodes?
      well.innerHTML =
        \"<svg>\" +
        fragment
          .replace(/\
/, \"\")
          .replace(/<(\\w+)([^<]+?)\\/>/g, \"<$1$2></$1>\") +
        \"</svg>\";

      // transplant nodes
      for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++)
        container.appendChild(well.firstChild.firstChild);

      return container;
    }
  },

  translate: function (node, x, y) {
    node.setAttribute(\"transform\", \"translate(\" + x + \",\" + y + \")\");
    return node;
  },

  scale: function (node, sx, sy) {
    node.setAttribute(\"transform\", \"scale(\" + sx + \",\" + sy + \")\");
    return node;
  }
};

export var TextMeasuringStrategy = {
  // shapes
  Svg: 0,
  Canvas: 1,
  OpenTypeJS: 2
};

/*
 * ChantContext
 */
export class ChantContext {
  constructor(
    textMeasuringStrategy = QuickSvg.hasDOMAccess()
      ? TextMeasuringStrategy.Canvas
      : TextMeasuringStrategy.OpenTypeJS
  ) {
    this.textMeasuringStrategy = textMeasuringStrategy;
    this.defs = {};
    this.makeDefs = [];
    if (QuickSvg.hasDOMAccess()) {
      this.defsNode = QuickSvg.createNode(\"defs\");
    }

    // font styles
    this.textStyles = {};
    this.textColor = \"#000\";
    this.setFont(\"'Palatino Linotype', 'Book Antiqua', Palatino, serif\", 16);

    this.rubricColor = \"#d00\";
    this.specialCharProperties = {
      \"font-family\": \"'Exsurge Characters'\",
      fill: this.rubricColor,
      class: 'rubric'
    };
    this.textBeforeSpecialChar = \"\";
    this.textAfterSpecialChar = \".\";
    this.specialCharMap = {
      \"℣\": 'v',
      \"℟\": 'r',
      \"+\": \"+\",
      \"*\": \"*\"
    };
    this.plusProperties = {};
    this.asteriskProperties = {};
    this.specialCharText = (char) => this.specialCharMap[char] || char;

    this.fontStyleDictionary = {
      b: { \"font-weight\": \"bold\" },
      i: { \"font-style\": \"italic\" },
      u: { \"text-decoration\": \"underline\" },
      ul: { \"text-decoration\": \"underline\" },
      c: { fill: this.rubricColor, class: 'rubric' },
      sc: {
        \"font-variant\": \"small-caps\",
        \"font-variant-caps\": \"small-caps\",
        \"font-feature-settings\": \"'smcp'\",
        \"-webkit-font-feature-settings\": \"'smcp'\"
      },
      v: {}
    };

    this.markupSymbolDictionary = {
      \"*\": \"b\",
      \"_\": \"i\",
      \"^\": \"c\",
      \"%\": \"sc\"
    };

    this.textStyles.al.prefix = \"<i>\";

    this.textStyles.translation.prefix = \"<i>\";

    this.textStyles.dropCap.padding = 1; // minimum padding on either side of drop cap in staffIntervals

    this.textStyles.annotation.padding = 1; // minimum padding on either side of annotation in staffIntervals

    this.minLedgerSeparation = 2; // multiple of staffInterval
    this.minSpaceAboveStaff = 2; // multiple of staffInterval
    this.minSpaceBelowStaff = 1; // multiple of staffInterval
    this.spaceBetweenSystems = 1.5; // multiple of staffInterval

    // everything depends on the scale of the punctum
    this.glyphPunctumWidth = Glyphs.PunctumQuadratum.bounds.width;
    this.glyphPunctumHeight = Glyphs.PunctumQuadratum.bounds.height;

    // max space to add between notations when justifying, in multiples of this.staffInterval
    this.maxExtraSpaceInStaffIntervals = 0.5;

    // for keeping track of the clef
    this.activeClef = null;

    this.neumeLineColor = \"#000\";
    this.staffLineColor = \"#000\";
    this.dividerLineColor = \"#000\";

    this.defaultLanguage = language.latin;

    // calculate the pixel ratio for drawing to a canvas
    this.pixelRatio = window.devicePixelRatio || 1.0;

    //this.canvasCtxt.scale(this.pixelRatio, this.pixelRatio);

    if (textMeasuringStrategy === TextMeasuringStrategy.Svg) {
      this.svgTextMeasurer = QuickSvg.svg(0, 0);
      this.svgTextMeasurer.setAttribute(\"id\", \"TextMeasurer\");
      this.svgTextMeasurer.setAttribute(\"style\", \"position:absolute\");
      document.body.insertBefore(
        this.svgTextMeasurer,
        document.body.firstChild
      );
    } else if (textMeasuringStrategy === TextMeasuringStrategy.Canvas) {
      this.makeCanvasIfNeeded();
    }

    // for connecting neume syllables...
    this.syllableConnector = \"-\";

    // set whether to scale the def tags (scaleDefs = true) or the use tags.
    this.scaleDefs = true;

    // fixme: for now, we just set these using the glyph scales as noted above, presuming a
    // staff line size of 0.5 in. Really what we should do is scale the punctum size based
    // on the text metrics, right? 1 punctum ~ x height size?
    this.setGlyphScaling(1.0 / 16.0);

    // minimum space between puncta of different syllables, in multiples of this.intraNeumeSpacing
    this.interSyllabicMultiplier = 2.5;

    // space between an accidental and the following note, in multiples of this.intraNeumeSpacing
    this.accidentalSpaceMultiplier = 2;

    // space added between puncta of different words, in multiples of this.intraNeumeSpacing
    this.interVerbalMultiplier = 1;

    this.drawGuides = false;
    this.drawDebuggingBounds = true;

    // we keep track of where we are in processing notations, so that
    // we can maintain the context for notations to know about.
    //
    // these are only gauranteed to be valid during the performLayout phase!
    this.activeNotations = null;
    this.currNotationIndex = -1;

    this.minSyllablesLastLine = 0;
    this.minNotesLastLine = 0;

    // chant notation elements are normally separated by a minimum fixed amount of space
    // on the staff line. It can happen, however, that two text elements are almost close
    // enough to merge, only to be separated much more by the required hyphen (or other
    // connecting string).
    //
    // This tolerance value allows a little bit of flexibility to merge two close lyrical
    // elements, thus bringing the chant notation elements a bit closer than otherwise
    // would be normally allowed.
    //
    // condensing tolerance is a percentage value (0.0-1.0, inclusive) that indicates
    // how much the default spacing can shrink. E.g., a value of 0.20 allows the layout
    // engine to separate two glyphs by only 80% of the normal inter-neume spacing value.
    this.condensingTolerance = 0.3;

    // if auto color is true, then exsurge tries to automatically colorize
    // some elements of the chant (directives become rubric color, etc.)
    this.autoColor = true;

    this.useExtraTextOnly = true;

    this.noteIdPrefix = 'note-';

    this.insertFontsInDoc();
  }

  getFontForProperties(properties = {}, fontFamily) {
    let key = getFontFilenameForProperties(properties),
      keyWithFontFamily = getFontFilenameForProperties(properties, fontFamily);
    return (
      this.fontDictionary &&
      (this.fontDictionary[keyWithFontFamily] ||
        this.fontDictionary[fontFamily] ||
        this.fontDictionary.Regular)
    );
  }

  setFont(font, size = 16, baseStyle = {}, opentypeFontDictionary) {
    for (let [key, textType] of Object.entries(TextTypes)) {
      let textStyle = (this.textStyles[key] = this.textStyles[key] || {});
      textStyle.size = textType.defaultSize
        ? textType.defaultSize(size, this)
        : textType.size(this);
      textStyle.font = font;
      textStyle.color = this.textColor || \"#000\";
    }

    this.baseTextStyle = baseStyle;

    if (opentypeFontDictionary) {
      this.textMeasuringStrategy = TextMeasuringStrategy.OpenTypeJS;
      this.fontDictionary = opentypeFontDictionary;
    }
  }

  setRubricColor(color) {
    this.rubricColor = color;
    this.specialCharProperties.fill = color;
    this.fontStyleDictionary.c.fill = color;
  }

  setScaleDefs(scaleDefs) {
    scaleDefs = !!scaleDefs;
    if (this.scaleDefs !== scaleDefs) {
      this.scaleDefs = scaleDefs;
      this.setGlyphScaling(this.glyphScaling);
    }
  }

  createStyleCss() {
    var style = \"\";
    for (let [key, textType] of Object.entries(TextTypes)) {
      var cssClass = textType.cssClass,
        { color, font, size } = this.textStyles[key];
      style += `svg.Exsurge .${cssClass}{fill:${color};font-family:${font};font-size:${size}px;font-kerning:normal}`;
    }
    return style;
  }

  createStyleNode() {
    var node = QuickSvg.createNode(\"style\", {});
    node.textContent = this.createStyleCss();
    return node;
  }

  createStyleTree() {
    return { name: \"style\", props: {}, children: [this.createStyleCss()] };
  }

  createStyle() {
    return \"<style>\" + this.createStyleCss() + \"</style>\";
  }

  updateHyphenWidth() {
    // measure the size of a hyphen for the lyrics
    var hyphen = new Lyric(
      this,
      this.syllableConnector,
      LyricType.SingleSyllable
    );
    var multiplier =
      this.minLyricWordSpacing /
        (this.hyphenWidth || this.minLyricWordSpacing) || 1;
    this.hyphenWidth = hyphen.bounds.width;

    this.minLyricWordSpacing = multiplier * this.hyphenWidth;
  }

  setStaffHeight(staffHeight) {
    this.setGlyphScaling(staffHeight / 600);
  }

  setGlyphScaling(glyphScaling) {
    this.glyphScaling = glyphScaling;

    this.staffInterval = this.glyphPunctumWidth * this.glyphScaling;

    // setup the line weights for the various elements.
    this.staffLineWeight = Math.ceil((5 * this.staffInterval) / 8) / 5;
    this.neumeLineWeight = this.staffLineWeight; // the weight of connecting lines in the glyphs.
    this.dividerLineWeight = this.neumeLineWeight; // of quarter bar, half bar, etc.
    this.episemaLineWeight = this.neumeLineWeight * 1.25; // of horizontal episemata

    this.intraNeumeSpacing = this.staffInterval / 2.0;

    while (this.defsNode && this.defsNode.firstChild)
      this.defsNode.removeChild(this.defsNode.firstChild);
    for (var i = 0; i < this.makeDefs.length; ++i) {
      this.makeDefs[i]();
    }

    this.updateHyphenWidth();
  }

  calculateHeightFromStaffPosition(staffPosition) {
    return -staffPosition * this.staffInterval;
  }

  insertFontsInDoc() {
    if (!canAccessDOM) return;

    var styleElement = document.getElementById(\"exsurge-fonts\");

    if (styleElement === null) {
      // create it since it doesn't exist yet.
      styleElement = document.createElement(\"style\");
      styleElement.id = \"exsurge-fonts\";

      // styleElement.appendChild(document.createTextNode(\"@font-face{font-family: 'Exsurge Characters';font-weight: normal;font-style: normal;src: url(\" + __exsurgeCharactersFont + \") format('opentype');}\"));

      document.head.appendChild(styleElement);
    }
  }

  // returns the next neume starting at this.currNotationIndex, or null
  // if there isn't a neume after this one...
  findNextNeume() {
    if (typeof this.currNotationIndex === \"undefined\")
      throw \"findNextNeume() called without a valid currNotationIndex set\";

    for (var i = this.currNotationIndex + 1; i < this.notations.length; i++) {
      var notation = this.notations[i];

      if (notation.isNeume && !notation.hasNoWidth) return notation;
    }

    return null;
  }

  makeCanvasIfNeeded() {
    if (!this.canvas) {
      this.canvas = document.createElement(\"canvas\");
      this.canvasCtxt = this.canvas.getContext(\"2d\");
    }
  }

  setCanvasSize(width, height, scale = 1) {
    this.makeCanvasIfNeeded();

    this.canvas.style.width = width * scale + \"px\";
    this.canvas.style.height = height * scale + \"px\";
    scale *= this.pixelRatio;
    this.canvas.width = width * scale;
    this.canvas.height = height * scale;

    this.canvasCtxt.setTransform(scale, 0, 0, scale, 0, 0);
  }
}

/*
 * ChantLayoutElement
 */
export class ChantLayoutElement {
  constructor() {
    this.bounds = new Rect();
    this.origin = new Point(0, 0);

    this.selected = false;
    this.highlighted = false;
  }

  // draws the element on an html5 canvas
  draw(ctxt) {
    throw \"ChantLayout Elements must implement draw(ctxt)\";
  }

  // returns svg element
  createSvgNode(ctxt) {
    throw \"ChantLayout Elements must implement createSvgNode(ctxt)\";
  }

  // returns svg code for the element, used for printing support
  createSvgFragment(ctxt) {
    throw \"ChantLayout Elements must implement createSvgFragment(ctxt)\";
  }
}

export class DividerLineVisualizer extends ChantLayoutElement {
  constructor(ctxt, staffPosition0, staffPosition1, divider) {
    super();

    this.divider = divider;

    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition0);
    var y1 = ctxt.calculateHeightFromStaffPosition(staffPosition1);

    if (y0 > y1) {
      var temp = y0;
      y0 = y1;
      y1 = temp;
    }

    this.bounds.x = 0;
    this.bounds.y = y0;
    this.bounds.width = ctxt.dividerLineWeight;
    this.bounds.height = y1 - y0;

    this.origin.x = this.bounds.width / 2;
    this.origin.y = y0;
  }

  draw(ctxt) {
    var canvasCtxt = ctxt.canvasCtxt;

    canvasCtxt.fillStyle = ctxt.dividerLineColor;

    canvasCtxt.fillRect(
      this.bounds.x,
      this.bounds.y,
      ctxt.dividerLineWeight,
      this.bounds.height
    );
  }

  getSvgProps(ctxt) {
    let props = {
      x: this.bounds.x,
      y: this.bounds.y,
      width: ctxt.dividerLineWeight,
      height: this.bounds.height,
      fill: ctxt.dividerLineColor,
      class: \"dividerLine\"
    };
    if (this.divider) {
      if (this.divider.selected) props.class += \" selected\";
      props[\"source-index\"] = this.divider.sourceIndex;
      props[\"element-index\"] = this.divider.elementIndex;
      props.source = this.divider;
    }
    return props;
  }

  createSvgNode(ctxt) {
    return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));
  }
  createSvgTree(ctxt) {
    return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));
  }

  createSvgFragment(ctxt) {
    return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));
  }
}

export class NeumeLineVisualizer extends ChantLayoutElement {
  constructor(ctxt, note0, note1, hanging) {
    super();

    var staffPosition0 = note0.staffPosition;
    var staffPosition1 = note1.staffPosition;

    // note0 should be the upper one for our calculations here
    if (staffPosition0 < staffPosition1) {
      var temp = staffPosition0;
      staffPosition0 = staffPosition1;
      staffPosition1 = temp;
    }

    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition0);
    var y1 = 0;

    if (hanging) {
      // if the difference between the notes is only one, and the upper
      // note is on a line, and the lower note is within the four staff lines,
      // then our hanging line goes past the lower note by a whole
      // staff interval
      if (
        staffPosition0 - staffPosition1 === 1 &&
        Math.abs(staffPosition0) % 2 === 1 &&
        staffPosition1 > -3
      )
        staffPosition1--;

      y1 += (ctxt.glyphPunctumHeight * ctxt.glyphScaling) / 2.2;
    }

    y1 += ctxt.calculateHeightFromStaffPosition(staffPosition1);

    this.bounds.x = 0;
    this.bounds.y = y0;
    this.bounds.width = ctxt.neumeLineWeight;
    this.bounds.height = y1 - y0;

    this.origin.x = 0;
    this.origin.y = 0;
  }

  draw(ctxt) {
    var canvasCtxt = ctxt.canvasCtxt;

    canvasCtxt.fillStyle = ctxt.neumeLineColor;

    canvasCtxt.fillRect(
      this.bounds.x,
      this.bounds.y,
      ctxt.neumeLineWeight,
      this.bounds.height
    );
  }

  getSvgProps(ctxt) {
    return {
      x: this.bounds.x,
      y: this.bounds.y,
      width: ctxt.neumeLineWeight,
      height: this.bounds.height,
      fill: ctxt.neumeLineColor,
      class: \"neumeLine\"
    };
  }

  createSvgNode(ctxt) {
    return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));
  }
  createSvgTree(ctxt) {
    return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));
  }

  createSvgFragment(ctxt) {
    return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));
  }
}

export class VirgaLineVisualizer extends ChantLayoutElement {
  constructor(ctxt, note) {
    super();

    var staffPosition = note.staffPosition;

    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition);
    var y1;

    if (Math.abs(staffPosition % 2) === 0) y1 = y0 + ctxt.staffInterval * 1.8;
    else y1 = y0 + ctxt.staffInterval * 2.7;

    this.bounds.x = 0;
    this.bounds.y = y0;
    this.bounds.width = ctxt.neumeLineWeight;
    this.bounds.height = y1 - y0;

    this.origin.x = 0;
    this.origin.y = 0;
  }

  draw(ctxt) {
    var canvasCtxt = ctxt.canvasCtxt;

    canvasCtxt.fillStyle = ctxt.neumeLineColor;
    canvasCtxt.fillRect(
      this.bounds.x,
      this.bounds.y,
      ctxt.neumeLineWeight,
      this.bounds.height
    );
  }

  getSvgProps(ctxt) {
    return {
      x: this.bounds.x,
      y: this.bounds.y,
      width: ctxt.neumeLineWeight,
      height: this.bounds.height,
      fill: ctxt.neumeLineColor,
      class: \"neumeLine\"
    };
  }

  createSvgNode(ctxt) {
    return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));
  }
  createSvgTree(ctxt) {
    return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));
  }

  createSvgFragment(ctxt) {
    return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));
  }
}

export class LineaVisualizer extends ChantLayoutElement {
  constructor(ctxt, note) {
    super();

    var staffPosition = note.staffPosition;

    var y0 = ctxt.calculateHeightFromStaffPosition(staffPosition) - note.origin.y;
    var y1 = y0 + note.bounds.height;

    this.bounds.x = 0;
    this.bounds.y = y0;
    this.bounds.width = ctxt.neumeLineWeight * 5 + note.bounds.width;
    this.bounds.height = y1 - y0;

    this.origin.x = ctxt.neumeLineWeight * 2.5;
    this.origin.y = 0;
  }

  draw(ctxt) {
    var canvasCtxt = ctxt.canvasCtxt;

    canvasCtxt.fillStyle = ctxt.neumeLineColor;
    canvasCtxt.fillRect(
      this.bounds.x,
      this.bounds.y,
      ctxt.neumeLineWeight,
      this.bounds.height
    );
    canvasCtxt.fillRect(
      this.bounds.x + this.bounds.width - ctxt.neumeLineWeight,
      this.bounds.y,
      ctxt.neumeLineWeight,
      this.bounds.height
    );
  }

  getSvgProps(ctxt, x) {
    return {
      x,
      y: this.bounds.y,
      width: ctxt.neumeLineWeight,
      height: this.bounds.height,
      fill: ctxt.neumeLineColor,
      class: \"neumeLine\"
    };
  }

  createSvgNode(ctxt) {
    return QuickSvg.createNode(\"g\", null, [
      this.bounds.x,
      this.bounds.x + this.bounds.width - ctxt.neumeLineWeight
    ].map(x => QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt, x))));
  }

  createSvgTree(ctxt) {
    return QuickSvg.createSvgTree(\"g\", {}, ...[
      this.bounds.x,
      this.bounds.x + this.bounds.width - ctxt.neumeLineWeight
    ].map(x => QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt, x))));
  }

  createSvgFragment(ctxt) {
    return QuickSvg.createFragment(\"g\", null, [
      this.bounds.x,
      this.bounds.x + this.bounds.width - ctxt.neumeLineWeight
    ].map(x => QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt, x))).join(''));
  }
}

export class GlyphVisualizer extends ChantLayoutElement {
  constructor(ctxt, glyphCode) {
    super();

    this.glyph = null;

    this.setGlyph(ctxt, glyphCode);
  }

  setGlyph(ctxt, glyphCode) {
    if (this.glyphCode !== glyphCode) {
      if (
        typeof glyphCode === \"undefined\" ||
        glyphCode === null ||
        glyphCode === \"\"
      )
        glyphCode = this.glyphCode = GlyphCode.None;
      else this.glyphCode = glyphCode;

      let glyph = this.glyph = Glyphs[glyphCode];

      // if this glyph hasn't been used yet, then load it up in the defs section for sharing
      if (!ctxt.defs.hasOwnProperty(glyphCode)) {
        var getDefProps = () => {
          var options = {
            id: glyphCode,
            class: \"glyph\"
          };
          if (ctxt.scaleDefs === true) {
            options.transform = \"scale(\" + ctxt.glyphScaling + \")\";
          }
          return options;
        };
        var makeDef = () => {
          let options = getDefProps();
          // create the ref
          ctxt.defs[glyphCode] = QuickSvg.createFragment(
            \"g\",
            options,
            QuickSvg.svgFragmentForGlyph(glyph)
          );

          if (ctxt.defsNode)
            ctxt.defsNode.appendChild(
              QuickSvg.createNode(
                \"g\",
                options,
                QuickSvg.nodesForGlyph(glyph)
              )
            );
        };
        makeDef.makeSvgTree = () => {
          return QuickSvg.createSvgTree(
            \"g\",
            getDefProps(),
            ...QuickSvg.nodesForGlyph(glyph, \"createSvgTree\")
          );
        };
        makeDef.glyphCode = glyphCode;
        makeDef();
        ctxt.makeDefs.push(makeDef);
      }

      this.align = this.glyph.align;
    }

    this.origin.x = this.glyph.origin.x * ctxt.glyphScaling;
    this.origin.y = this.glyph.origin.y * ctxt.glyphScaling;

    this.bounds.x = 0;
    this.bounds.y = -this.origin.y;
    this.bounds.width = this.glyph.bounds.width * ctxt.glyphScaling;
    this.bounds.height = this.glyph.bounds.height * ctxt.glyphScaling;
  }

  setStaffPosition(ctxt, staffPosition) {
    this.bounds.y =
      ctxt.calculateHeightFromStaffPosition(staffPosition) - this.origin.y;
  }

  draw(ctxt) {
    var canvasCtxt = ctxt.canvasCtxt;

    var x = this.bounds.x + this.origin.x;
    var y = this.bounds.y + this.origin.y;
    canvasCtxt.translate(x, y);
    canvasCtxt.scale(ctxt.glyphScaling, ctxt.glyphScaling);

    for (var i = 0; i < this.glyph.paths.length; i++) {
      var path = this.glyph.paths[i];
      canvasCtxt.fillStyle =
        path.type === \"negative\" ? \"#fff\" : ctxt.neumeLineColor;
      canvasCtxt.fill(new Path2D(path.data));
    }

    canvasCtxt.scale(1.0 / ctxt.glyphScaling, 1.0 / ctxt.glyphScaling);
    canvasCtxt.translate(-x, -y);
  }

  getSvgAttributes(ctxt, source) {
    let className = \"\";
    if (/^Porrectus\\d$/.test(this.glyphCode)) {
      let notes = source.neume.notes,
        noteIndex = notes.indexOf(source),
        nextNote = notes[noteIndex + 1];
      className = source.selected
        ? nextNote.selected
          ? \"selected\"
          : \"selectedA\"
        : nextNote.selected
        ? \"selectedB\"
        : \"\";
    } else {
      let isSelected =
        source && (source.selected || (source.model && source.model.selected));
      className = isSelected ? \"selected\" : \"\";
    }
    var result = {
      \"xlink:href\": \"#\" + this.glyphCode,
      class: className
    };
    if (source) {
      result[\"source-index\"] = source.sourceIndex;
      result[\"element-index\"] = source.elementIndex;
      if ('noteIndex' in source) {
        result.class += ' note';
        result.id = ctxt.noteIdPrefix + (source.noteIndex + 1);
        if (source.neume) {
          const glyphCode = source.glyphVisualizer.glyphCode;
          if (/^Porrectus/.test(glyphCode)) {
            result.class += ' porrectus porrectus-start';
          } else if (glyphCode === 'None') {
            result.class += ' porrectus porrectus-end';
          }
        }
      }
    }
    if (ctxt.scaleDefs === true) {
      result.x = this.bounds.x + this.origin.x;
      result.y = this.bounds.y + this.origin.y;
    } else {
      result.x = (this.bounds.x + this.origin.x) / ctxt.glyphScaling;
      result.y = (this.bounds.y + this.origin.y) / ctxt.glyphScaling;
      result.transform = \"scale(\" + ctxt.glyphScaling + \")\";
    }
    return result;
  }

  createSvgNode(ctxt, source) {
    var attributes = this.getSvgAttributes(ctxt, source);
    attributes.source = source;
    return QuickSvg.createNode(\"use\", attributes);
  }
  createSvgTree(ctxt, source) {
    var attributes = this.getSvgAttributes(ctxt, source);
    if (source) attributes.source = source;
    return QuickSvg.createSvgTree(\"use\", attributes);
  }

  createSvgFragment(ctxt, source) {
    return QuickSvg.createFragment(\"use\", this.getSvgAttributes(ctxt, source));
  }
}

export class RoundBraceVisualizer extends ChantLayoutElement {
  constructor(ctxt, x1, x2, y, isAbove) {
    super();

    if (x1 > x2) {
      // swap the xs
      var temp = x1;
      x1 = x2;
      x2 = temp;
    }

    this.isAbove = isAbove;
    this.braceHeight = (3 * ctxt.staffInterval) / 2;

    this.bounds = new Rect(
      x1,
      isAbove ? y - this.braceHeight : y,
      x2 - x1,
      this.braceHeight
    );

    this.origin.x = 0;
    this.origin.y = 0;
  }

  getSvgPathProps(ctxt) {
    return {
      d: this.generatePathString(),
      stroke: ctxt.neumeLineColor,
      \"stroke-width\": ctxt.staffLineWeight + \"px\",
      fill: \"none\",
      class: \"brace\"
    };
  }

  createSvgNode(ctxt) {
    var node = QuickSvg.createNode(\"path\", this.getSvgPathProps(ctxt));
    if (this.accent) {
      return QuickSvg.createNode(
        \"g\",
        {
          class: \"accentedBrace\"
        },
        [node, this.accent.createSvgNode(ctxt)]
      );
    } else return node;
  }
  createSvgTree(ctxt) {
    var node = QuickSvg.createSvgTree(\"path\", this.getSvgPathProps(ctxt));
    if (this.accent) {
      return QuickSvg.createSvgTree(
        \"g\",
        {
          class: \"accentedBrace\"
        },
        node,
        this.accent.createSvgTree(ctxt)
      );
    } else return node;
  }

  createSvgFragment(ctxt) {
    var fragment = QuickSvg.createFragment(\"path\", this.getSvgPathProps(ctxt));

    if (this.accent) {
      fragment += this.accent.createSvgFragment(ctxt);

      return QuickSvg.createFragment(
        \"g\",
        {
          class: \"accentedBrace\"
        },
        fragment
      );
    } else return fragment;
  }

  // returns svg path d string
  generatePathString() {
    var x1 = this.bounds.x;
    var x2 = this.bounds.right();
    var width = this.bounds.width;
    var y, dx, dy;

    dx = width / 6;
    dy = this.bounds.height;
    if (this.isAbove) {
      y = this.bounds.bottom();
      dy = -dy;
    } else {
      y = this.bounds.y;
    }

    //Calculate Control Points of path,
    var cx1 = x1 + dx;
    var cy = y + dy;
    var cx2 = x2 - dx;

    // two decimal points should be enough, but if we need more precision, we can
    // up it here.
    var dp = 2;
    return (
      \"M \" +
      x1.toFixed(dp) +
      \" \" +
      y.toFixed(dp) +
      \" C \" +
      cx1.toFixed(dp) +
      \" \" +
      cy.toFixed(dp) +
      \" \" +
      cx2.toFixed(dp) +
      \" \" +
      cy.toFixed(dp) +
      \" \" +
      x2.toFixed(dp) +
      \" \" +
      y.toFixed(dp)
    );
  }
}

export class CurlyBraceVisualizer extends ChantLayoutElement {
  constructor(ctxt, x1, x2, y, isAbove = true, addAcuteAccent = false) {
    super();

    if (x1 > x2) {
      // swap the xs
      var temp = x1;
      x1 = x2;
      x2 = temp;
    }

    this.isAbove = isAbove;
    this.braceHeight = ctxt.staffInterval / 2;

    // y is the actual vertical start of the brace (left hand side)
    // thus for a brace over notes, bounds.y is the bottom of brace,
    // but for a brace under the notes, y is simply the y passed in.
    if (isAbove) y -= this.braceHeight;

    var bounds = new Rect(x1, y, x2 - x1, this.braceHeight);

    if (addAcuteAccent && isAbove) {
      this.accent = new GlyphVisualizer(ctxt, GlyphCode.AcuteAccent);
      this.accent.bounds.x += bounds.x + (x2 - x1) / 2;
      this.accent.bounds.y += bounds.y - ctxt.staffInterval / 4;

      bounds.union(this.accent.bounds);
    }

    this.bounds = bounds;

    this.origin.x = 0;
    this.origin.y = 0;
  }

  getSvgPathProps(ctxt) {
    return {
      d: this.generatePathString(),
      stroke: ctxt.neumeLineColor,
      \"stroke-width\": ctxt.staffLineWeight + \"px\",
      fill: \"none\",
      class: \"brace\"
    };
  }

  createSvgNode(ctxt) {
    var node = QuickSvg.createNode(\"path\", this.getSvgPathProps(ctxt));

    if (this.accent) {
      return QuickSvg.createNode(
        \"g\",
        {
          class: \"accentedBrace\"
        },
        [node, this.accent.createSvgNode(ctxt)]
      );
    } else return node;
  }
  createSvgTree(ctxt) {
    var node = QuickSvg.createSvgTree(\"path\", this.getSvgPathProps(ctxt));
    if (this.accent) {
      return QuickSvg.createSvgTree(
        \"g\",
        {
          class: \"accentedBrace\"
        },
        node,
        this.accent.createSvgTree(ctxt)
      );
    } else return node;
  }

  createSvgFragment(ctxt) {
    var fragment = QuickSvg.createFragment(\"path\", this.getSvgPathProps(ctxt));

    if (this.accent) {
      fragment += this.accent.createSvgFragment(ctxt);

      return QuickSvg.createFragment(
        \"g\",
        {
          class: \"accentedBrace\"
        },
        fragment
      );
    } else return fragment;
  }

  // code below inspired by: https://gist.github.com/alexhornbake
  // optimized for braces that are only drawn horizontally.
  // returns svg path d string
  generatePathString() {
    var q = 0.6; // .5 is normal, higher q = more expressive bracket

    var x1 = this.bounds.x;
    var x2 = this.bounds.right();
    var width = this.bounds.width;
    var y, h;

    if (this.isAbove) {
      y = this.bounds.bottom();
      h = -this.braceHeight;
    } else {
      y = this.bounds.y;
      h = this.braceHeight;
    }

    // calculate Control Points of path
    var qy1 = y + q * h;
    var qx2 = x1 + 0.25 * width;
    var qy2 = y + (1 - q) * h;
    var tx1 = x1 + 0.5 * width;
    var ty1 = y + h;
    var qy3 = y + q * h;
    var qx4 = x1 + 0.75 * width;
    var qy4 = y + (1 - q) * h;

    // two decimal points should be enough, but if we need more precision, we can
    // up it here.
    var dp = 2;
    return (
      \"M \" +
      x1.toFixed(dp) +
      \" \" +
      y.toFixed(dp) +
      \" Q \" +
      x1.toFixed(dp) +
      \" \" +
      qy1.toFixed(dp) +
      \" \" +
      qx2.toFixed(dp) +
      \" \" +
      qy2.toFixed(dp) +
      \" T \" +
      tx1.toFixed(dp) +
      \" \" +
      ty1.toFixed(dp) +
      \" M \" +
      x2.toFixed(dp) +
      \" \" +
      y.toFixed(dp) +
      \" Q \" +
      x2.toFixed(dp) +
      \" \" +
      qy3.toFixed(dp) +
      \" \" +
      qx4.toFixed(dp) +
      \" \" +
      qy4.toFixed(dp) +
      \" T \" +
      tx1.toFixed(dp) +
      \" \" +
      ty1.toFixed(dp)
    );
  }
}

export class TextSpan {
  constructor(text, properties, activeTags, index = 0) {
    if (typeof properties === \"undefined\" || properties === null)
      properties = {};

    this.text = text;
    this.properties = properties;
    this.activeTags = activeTags || [];
    this.index = index;
  }

  clone() {
    return new TextSpan(
      this.text,
      this.properties,
      this.activeTags,
      this.index
    );
  }
}

function MarkupStackFrame(tagName, startIndex, properties = {}, symbol) {
  this.tagName = tagName;
  this.startIndex = startIndex;
  this.properties = properties;
  if (symbol) this.symbol = symbol;
}

MarkupStackFrame.createStackFrame = function (ctxt, tagName, startIndex, extraProperties = {}, symbol = '') {
  return new MarkupStackFrame(
    tagName,
    startIndex,
    Object.assign({}, ctxt.fontStyleDictionary[tagName], extraProperties),
    symbol
  );
};

// for escaping html strings before they go into the svgs
// adapted from http://stackoverflow.com/a/12034334/5720160
var __subsForTspans = {
  \"&\": \"&amp;\",
  \"<\": \"&lt;\",
  \">\": \"&gt;\"
};

export class TextElement extends ChantLayoutElement {
  constructor(
    ctxt,
    text,
    fontFamily,
    fontSize,
    textAnchor,
    sourceIndex,
    sourceGabc
  ) {
    super();

    // set these to some sane values for now...
    this.bounds.x = 0;
    this.bounds.y = 0;
    this.bounds.width = 0;
    this.bounds.height = 0;
    this.origin.x = 0;
    this.origin.y = 0;

    this.fontFamily = fontFamily;
    this.fontSize = fontSize;
    this.textAnchor = textAnchor;
    this.sourceIndex = sourceIndex;
    this.sourceGabc = sourceGabc;
    this.dominantBaseline = \"baseline\"; // default placement

    this.generateSpansFromText(ctxt, text);

    this.recalculateMetrics(ctxt);
  }

  getFromScore(score) {
    return this.textType.getFromScore(score, this);
  }

  generateSpansFromText(ctxt, text) {
    text = text.replace(/\\s+/g, \" \");
    this.text = \"\";
    this.spans = [];

    // save ourselves a lot of grief for a very common text:
    if (text === \"*\" || text === \"+\" || text === \"†\") {
      let properties =
        text === \"*\"
          ? ctxt.asteriskProperties
          : text === \"+\"
          ? ctxt.plusProperties
          : null;
      text = ctxt.specialCharText(text) || text;
      this.spans.push(new TextSpan(text, properties));
      return;
    }

    var markupStack = [];
    var spanStartIndex = 0;
    var newLineInNextSpan = 0;

    var filterFrames = (frame, symbol) => frame.Symbol === symbol;

    var closeSpan = (spanText, index, extraProperties) => {
      if (spanText === \"\" && !this.dropCap) return;

      this.text += spanText;

      var properties = {};
      for (var i = 0; i < markupStack.length; i++)
        Object.assign(properties, markupStack[i].properties);

      if (extraProperties) Object.assign(properties, extraProperties);
      if (newLineInNextSpan) {
        properties.newLine = newLineInNextSpan;
        newLineInNextSpan = 0;
      }

      this.spans.push(
        new TextSpan(
          spanText,
          properties,
          markupStack.map((frame) => frame.tagName),
          index
        )
      );
    };

    var markupRegex = /(<br\\/?>)|<v>([\\s\\S]*?)(?:<\\/v>|$)|(\\*)(?=\\s*\\*|[^*]*(?:$|<v>))|(\\+)|<sp>(?:(~)|(')?([ao]e|[æœaeiouy])|([arv])\\/)<\\/sp>|([arv])\\/\\.|([℣℟])\\.?|(?:([*_^%])|<(\\/)?([bciuv]|ul|sc|font)(?:\\s+(?:family=\"([^\"]+)\"|fill=\"([^\"]+)\"|class=\"([^\"]+)\"))*>)(?=(?:(.+?)(?:\\11|<\\/\\13>))?)/gi;
    var vTagRegex = /(\\\\grecross)|\\{greextra\\}\\{([^}]*)\\}/g;
    var match = null;
    var openedAsterisk = false;
    var closeCurrentSpan = () =>
      closeSpan(text.substring(spanStartIndex, match.index), spanStartIndex);
    while ((match = markupRegex.exec(text))) {
      var [
        ,
        newLine,
        vTag,
        asterisk,
        plus,
        tilde,
        accent,
        vowelLigature,
        specialChar,
        specialChar2,
        specialChar3,
        markupSymbol,
        closingTag,
        tagName,
        family,
        fill,
        cssClass,
        enclosedText
      ] = match;
      specialChar = specialChar || specialChar2 || specialChar3;
      // non-matching symbols first
      if (newLine) {
        // close the current span, if any:
        if (match.index > spanStartIndex) {
          closeCurrentSpan();
        }
        // add the newline span:
        newLineInNextSpan++;
      } else if (vTag) {
        closeCurrentSpan();
        let vMatch;
        let lastIndex = 0;
        let iOffset = 0;
        while ((vMatch = vTagRegex.exec(vTag))) {
          if (lastIndex < vMatch.index) {
            closeSpan(vTag.slice(lastIndex, vMatch.index), match.index + lastIndex + iOffset);
            iOffset = 3; // length of '<v>'
          }
          let [, grecross, greextra] = vMatch;
          if (grecross) {
            // grecross is just the command for the Cross:
            // set up greextra so it will get handled with it below:
            greextra = 'Cross';
          }    
          const char = greextraGlyphs[greextra];
          if (char) {
            closeSpan(char, match.index + vMatch.index + iOffset, { 'font-family': 'greextra' })
          }
          lastIndex = vTagRegex.lastIndex;
          iOffset = 3; // length of '<v>'
        }
        if (lastIndex < vTag.length) {
          closeSpan(vTag.slice(lastIndex), match.index + lastIndex + iOffset);
        }
      } else if (asterisk) {
        closeCurrentSpan();
        // first check if it is just a symbol to close:
        if (
          markupStack.length > 0 &&
          markupStack[markupStack.length - 1].symbol === asterisk
        ) {
          // close asterisk tag
          markupStack.pop();
        } else {
          // add special asterisk:
          closeSpan(ctxt.specialCharText(asterisk) || '*', match.index, ctxt.asteriskProperties);
        }
      } else if (plus) {
        closeCurrentSpan();
        closeSpan(ctxt.specialCharText(plus) || '+', match.index, ctxt.plusProperties);
      } else if (tilde) {
        closeCurrentSpan();
        closeSpan('∼', match.index);
      } else if (vowelLigature) {
        let vowel = makeLigature(vowelLigature);
        if (accent) vowel = addAccent(vowel);
        closeCurrentSpan();
        closeSpan(vowel, match.index);
      } else if (specialChar) {
        closeCurrentSpan();
        closeSpan(
          ctxt.textBeforeSpecialChar +
            ctxt.specialCharText(specialChar) +
            ctxt.textAfterSpecialChar,
          match.index,
          ctxt.specialCharProperties
        );
      } else {
        // otherwise we're dealing with matching markup delimeters
        if (markupSymbol === \"*\") {
          // we are only strict with the asterisk, because there are cases when it needs to be displayed rather than count as a markup symbol
          if (enclosedText && /[^\\s*]/.test(enclosedText)) {
            openedAsterisk = true;
          } else if (openedAsterisk) {
            openedAsterisk = false;
          } else {
            // actually use the asterisk, since it doesn't have a matching closing asterisk
            continue;
          }
        }
        if (markupSymbol) {
          tagName = ctxt.markupSymbolDictionary[markupSymbol];
          if (
            markupStack.length > 0 &&
            markupStack[markupStack.length - 1].tagName === tagName &&
            markupStack[markupStack.length - 1].symbol === markupSymbol
          ) {
            closingTag = true;
          }
        }
        if (
          markupStack.length > 0 &&
          markupStack[markupStack.length - 1].tagName === tagName
        ) {
          if (closingTag) {
            // group close
            closeCurrentSpan();
            markupStack.pop();
          }
        } else if (markupStack.filter(filterFrames).length > 0) {
          // trying to open a recursive group (or forgot to close a previous group)
          // in either case, we just unwind to the previous stack frame
          spanStartIndex = markupStack[markupStack.length - 1].startIndex;
          markupStack.pop();
          continue;
        } else {
          closeCurrentSpan();
          if (closingTag) {
            // out of order group close:
            let index = markupStack.findIndex(
              (frame) => frame.tagName === tagName
            );
            if (index >= 0) {
              markupStack.splice(index, 1);
            }
          } else {
            // group open
            const extraProperties = {};
            if (family) extraProperties['font-family'] = family;
            if (fill) extraProperties.fill = fill;
            if (cssClass) extraProperties.class = cssClass;
            markupStack.push(
              MarkupStackFrame.createStackFrame(ctxt, tagName, match.index, extraProperties, markupSymbol)
            );
          }
        }
      }

      // advance the start index past the current markup
      spanStartIndex = match.index + match[0].length;
    }

    // if we finished matches, and there is still some text left,
    // or if we haven't generated any spans yet, create one final run
    if (spanStartIndex < text.length || this.spans.length === 0)
      closeSpan(text.slice(spanStartIndex), spanStartIndex);
  }

  getCanvasFontForProperties(ctxt, properties = {}) {
    var font = \"\";
    if (properties[\"font-style\"] === \"italic\") font += \"italic \";
    if (properties[\"font-variant\"] === \"small-caps\") font += \"small-caps \";
    if (properties[\"font-weight\"] === \"bold\") font += \"bold \";
    let fontSize = parseFloat(properties[\"font-size\"]) || this.fontSize(ctxt);
    if (/%$/.test(properties[\"font-size\"])) {
      fontSize *= this.fontSize(ctxt) / 100;
    }
    font += `${fontSize * (this.resize || 1)}px `;
    font += properties[\"font-family\"] || this.fontFamily(ctxt);
    return font;
  }

  measureSubstringBBox(ctxt, length) {
    return this.measureSubstring(ctxt, length, true);
  }

  // if length is undefined and this.rightAligned === true, then offsets will be marked for each newLine span
  measureSubstring(ctxt, length, returnBBox = false) {
    if (length === 0) return 0;
    if (!length) length = Infinity;
    if (length < 0) {
      var lines = -length;
      length = Infinity;
    }
    var canvasCtxt = ctxt.canvasCtxt;
    var width = 0;
    var widths = [];
    var newLineSpans = [this.spans[0]];
    var subStringLength = 0;
    var numLines = 1;
    var fontSize = this.fontSize(ctxt) * (this.resize || 1);
    var bbox = new Rect(0, 0, 0, 0);
    for (var i = 0; i < this.spans.length; i++) {
      var span = this.spans[i],
        myText = span.text.slice(0, length - subStringLength);
      if (span.properties.newLine) {
        numLines += parseInt(span.properties.newLine) || 1;
        if (!lines && this.rightAligned === true && length === Infinity) {
          newLineSpans[newLineSpans.length - 1].properties.xOffset =
            this.firstLineMaxWidth - width;
          newLineSpans.push(span);
        } else if (--lines === 0) break;
        widths.push(width);
        width = 0;
      }
      if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Canvas) {
        canvasCtxt.font = this.getCanvasFontForProperties(
          ctxt,
          span.properties
        );
        let metrics = canvasCtxt.measureText(
          myText,
          width,
          fontSize * (numLines - 1)
        );
        if (\"actualBoundingBoxAscent\" in metrics) {
          let left = metrics.actualBoundingBoxLeft;
          bbox.union(
            new Rect(
              width - left,
              fontSize * (numLines - 1) - metrics.actualBoundingBoxAscent,
              metrics.width + left,
              metrics.actualBoundingBoxDescent + metrics.actualBoundingBoxAscent
            )
          );
          if (this instanceof DropCap) {
            width += Math.max(0, left);
          }
        } else {
          bbox.union(
            new Rect(width, fontSize * (numLines - 2), metrics.width, fontSize)
          );
        }
        width += metrics.width;
      } else if (
        ctxt.textMeasuringStrategy === TextMeasuringStrategy.OpenTypeJS &&
        ctxt.fontDictionary
      ) {
        // get the bounding box for the substring, placing it at x = width, y = fontSize * (numLines - 1)
        let font = ctxt.getFontForProperties(
          span.properties,
          span.properties[\"font-family\"] || this.fontFamily(ctxt)
        );
        let options = { features: { liga: true } };
        if (span.properties[\"font-variant\"] === \"small-caps\") {
          options.features.smcp = true;
        }
        let spanFontSize = parseFloat(span.properties[\"font-size\"]) || fontSize;
        if (/%$/.test(span.properties[\"font-size\"])) {
          spanFontSize *= fontSize / 100;
        }
        let subBbox = font
          .getPath(
            myText,
            width,
            fontSize * (numLines - 1),
            spanFontSize,
            options
          )
          .getBoundingBox();
        let subWidth = font.getAdvanceWidth(myText, spanFontSize, options);

        bbox.union(
          new Rect(
            width + subBbox.x1,
            subBbox.y1,
            subWidth - subBbox.x1,
            subBbox.y2 - subBbox.y1
          )
        );
        width += subWidth;
        if (this instanceof DropCap) {
          width -= subBbox.x1;
        }
      }
      subStringLength += myText.length;
      if (subStringLength === length) break;
    }
    if (
      !lines &&
      width &&
      newLineSpans.length &&
      this.rightAligned === true &&
      length === Infinity
    ) {
      newLineSpans[newLineSpans.length - 1].properties.xOffset =
        this.firstLineMaxWidth - width;
    }
    width = Math.max(width, ...widths);
    if (returnBBox === true) {
      let height = bbox.height;
      let y = bbox.y,
        x = bbox.x;
      return { width, height, x, y };
    } else {
      return width;
    }
  }

  recalculateMetrics(ctxt, resetNewLines = true) {
    if (resetNewLines) {
      delete this.maxWidth;
      delete this.firstLineMaxWidth;
      delete this.rightAligned;
      delete this.resize;
      delete this.numLines;
      // replace newlines with spaces
      this.spans.forEach((span) => {
        delete span.properties.xOffset;
        if (span.properties.newLine === true) {
          delete span.properties.newLine;
          span.text = \" \" + span.text;
        }
      });
    }

    this.bounds.x = 0;
    this.bounds.y = 0;

    this.origin.x = 0;

    if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Svg) {
      while (ctxt.svgTextMeasurer.firstChild)
        ctxt.svgTextMeasurer.removeChild(ctxt.svgTextMeasurer.firstChild);
      ctxt.svgTextMeasurer.appendChild(this.createSvgNode(ctxt));
      ctxt.svgTextMeasurer.appendChild(ctxt.createStyleNode());

      var bbox = ctxt.svgTextMeasurer.firstChild.getBBox();
      this.bounds.width = bbox.width;
      this.bounds.height = bbox.height;
      this.origin.y = -bbox.y; // offset to baseline from top
      this.origin.x = -bbox.x;
    } else {
      let bbox = this.measureSubstringBBox(ctxt);
      this.bounds.width = bbox.width;
      this.bounds.height = bbox.height;
      this.origin.y = -bbox.y;
      this.origin.x = -bbox.x;
    }
    this.numLines = this.spans.reduce(
      (result, span) =>
        result +
        (span.properties.newLine ? parseInt(span.properties.newLine) || 1 : 0),
      1
    );
  }

  setMaxWidth(ctxt, maxWidth, firstLineMaxWidth = maxWidth) {
    if (this.spans.filter((s) => s.properties.newLine === true).length) {
      // first get rid of any new lines set from a previous maxWidth
      this.recalculateMetrics(ctxt);
    }
    if (this.bounds.width > maxWidth) {
      this.maxWidth = maxWidth;
      var percentage = maxWidth / this.bounds.width;
      if (this instanceof Lyric && percentage >= 0.85) {
        this.resize = percentage;
      } else {
        if (firstLineMaxWidth < 0) firstLineMaxWidth = maxWidth;
        this.firstLineMaxWidth = firstLineMaxWidth;
        var lastWidth = 0,
          lastMatch = null,
          regex = /\\s+|$/g,
          max = firstLineMaxWidth,
          match;
        while (
          (match = regex.exec(this.text)) &&
          (!lastMatch || match.index > lastMatch.index)
        ) {
          var width = this.measureSubstring(ctxt, match.index);
          if (width > max && lastMatch) {
            var spanIndex = 0,
              length = 0;
            while (length < lastMatch.index && spanIndex < this.spans.length) {
              let span = this.spans[spanIndex++];
              length += span.text.length + (span.properties.newLine ? 1 : 0);
            }
            if (length > lastMatch.index) {
              let span = this.spans[--spanIndex];
              length -= span.text.length;
            }
            var splitSpan = this.spans[spanIndex],
              textLeft = splitSpan.text.slice(0, lastMatch.index - length),
              textRight = splitSpan.text.slice(
                lastMatch.index + lastMatch[0].length - length
              ),
              newSpans = [];
            this.rightAligned =
              max === firstLineMaxWidth && firstLineMaxWidth !== maxWidth;
            if (textLeft)
              newSpans.push(
                new TextSpan(
                  textLeft,
                  splitSpan.properties,
                  splitSpan.activeTags
                )
              );
            if (textRight) {
              newSpans.push(
                new TextSpan(
                  textRight,
                  Object.assign({}, splitSpan.properties, { newLine: true }),
                  splitSpan.activeTags
                )
              );
            } else if (this.spans[spanIndex + 1]) {
              this.spans[spanIndex + 1].properties.newLine = true;
            }
            this.spans.splice(spanIndex, 1, ...newSpans);
            this.needsLayout = true;
            max = maxWidth;
            if (
              match.index === this.text.length ||
              this.measureSubstring(ctxt) <= maxWidth
            )
              break;
            width = 0;
            match = lastMatch = null;
          }
          lastWidth = width;
          lastMatch = match;
        }
      }
      this.recalculateMetrics(ctxt, false);
    }
  }

  getCssClasses() {
    return (this.textType && this.textType.cssClass) || \"\";
  }

  getExtraStyleProperties(ctxt) {
    return ctxt.baseTextStyle || {};
  }

  static escapeForTspan(string) {
    return String(string).replace(/[&<>]/g, function (s) {
      return __subsForTspans[s];
    });
  }

  draw(ctxt) {
    var canvasCtxt = ctxt.canvasCtxt;

    if (this.textAnchor === \"middle\") canvasCtxt.textAlign = \"center\";
    else canvasCtxt.textAlign = \"start\";

    var translateWidth = 0,
      translateHeight = 0;
    for (var i = 0; i < this.spans.length; i++) {
      var span = this.spans[i];
      var xOffset = span.properties.xOffset || 0;
      if (span.properties.newLine) {
        count = parseInt(span.properties.newLine) || 1;
        canvasCtxt.translate(
          translateWidth + xOffset,
          this.fontSize(ctxt) * count
        );
        translateWidth = -xOffset;
        translateHeight -= this.fontSize(ctxt);
      } else if (xOffset) {
        canvasCtxt.translate(translateWidth + xOffset, 0);
        translateWidth = -xOffset;
      }
      var properties = Object.assign(
        {},
        this.getExtraStyleProperties(ctxt),
        span.properties
      );
      canvasCtxt.font = this.getCanvasFontForProperties(ctxt, properties);
      canvasCtxt.fillStyle = properties.fill || \"#000\";
      canvasCtxt.fillText(
        span.text,
        this.bounds.x,
        this.bounds.y,
        span.properties.textLength || undefined
      );
      var metrics = canvasCtxt.measureText(
        span.text,
        this.bounds.x,
        this.bounds.y
      );
      translateWidth -= metrics.width;
      canvasCtxt.translate(metrics.width, 0);
    }
    canvasCtxt.translate(translateWidth, translateHeight);
  }

  getSvgProps() {
    return {
      \"source-index\": this.sourceIndex,
      x: this.bounds.x,
      y: this.bounds.y,
      class: this.getCssClasses().trim(),
      \"text-anchor\": this.textAnchor
      //'dominant-baseline': this.dominantBaseline, // hanging baseline doesn't work in Safari
    };
  }

  getSpanOptions(span, ctxt, useStyleObject = false) {
    var options = {
      \"source-index\": span.index,
      class: span.properties.class,
      style: useStyleObject
        ? Object.assign({}, span.properties)
        : getCssForProperties(span.properties)
    };

    if (span.properties.newLine) {
      var xOffset = span.properties.xOffset || 0;
      options.dy = 1.1 * (parseInt(span.properties.newLine) || 1) + \"em\";
      options.x = this.bounds.x + xOffset;
    } else if (span.properties.xOffset) {
      options.x = this.bounds.x + span.properties.xOffset;
    }
    if (span.properties.textLength) {
      options.textLength = span.properties.textLength;
      options.lengthAdjust = \"spacingAndGlyphs\";
      options.y = this.bounds.y;
    }
    if (this.resize) {
      options[\"font-size\"] =
        span.properties[\"font-size\"] || this.fontSize(ctxt) * this.resize;
    }
    // if (ctxt.setFontFamilyAttributes) {
    //   options[\"font-family\"] =
    //     span.properties[\"font-family\"] ||
    //     getFontFilenameForProperties(span.properties, this.fontFamily(ctxt));
    //   let properties = Object.assign({}, span.properties);
    //   delete properties[\"font-weight\"];
    //   delete properties[\"font-style\"];
    //   options[\"style\"] = getCssForProperties(properties);
    // } else {
    //   options[\"style\"] = getCssForProperties(span.properties);
    // }

    return options;
  }

  createSvgNode(ctxt) {
    var spans = [];

    for (var i = 0; i < this.spans.length; i++) {
      let span = this.spans[i];
      let options = this.getSpanOptions(span, ctxt);

      spans.push(QuickSvg.createNode(\"tspan\", options, span.text));
    }

    let options = this.getSvgProps();
    const extraStyleProperties = this.getExtraStyleProperties(ctxt);
    options.style = getCssForProperties(extraStyleProperties);
    if (extraStyleProperties.class) {
      options.class = extraStyleProperties.class + ' ' + options.class;
    }
    options.source = this;

    return (this.svgNode = QuickSvg.createNode(\"text\", options, spans));
  }
  createSvgTree(ctxt) {
    var spans = [];

    for (var i = 0; i < this.spans.length; i++) {
      let span = this.spans[i];
      let options = this.getSpanOptions(span, ctxt, true);

      spans.push(QuickSvg.createSvgTree(\"tspan\", options, span.text));
    }

    let options = this.getSvgProps();
    options.style = this.getExtraStyleProperties(ctxt);
    if (options.style.class) {
      options.class = options.style.class + ' ' + options.class;
    }
    options.source = this;

    return QuickSvg.createSvgTree(\"text\", options, ...spans);
  }

  createSvgFragment(ctxt) {
    var spans = \"\";

    for (var i = 0; i < this.spans.length; i++) {
      let span = this.spans[i];
      let options = this.getSpanOptions(span, ctxt);

      spans += QuickSvg.createFragment(
        \"tspan\",
        options,
        TextElement.escapeForTspan(span.text)
      );
    }

    let options = this.getSvgProps();
    const extraStyleProperties = this.getExtraStyleProperties(ctxt)
    options.style = getCssForProperties(extraStyleProperties);
    if (extraStyleProperties.class) {
      options.class = extraStyleProperties.class + ' ' + options.class;
    }
    if (ctxt.setFontFamilyAttributes) {
      options[\"font-size\"] = this.fontSize(ctxt);
    }

    return QuickSvg.createFragment(\"text\", options, spans);
  }
}

export var LyricType = {
  SingleSyllable: 0,
  BeginningSyllable: 1,
  MiddleSyllable: 2,
  EndingSyllable: 3,

  Directive: 4 // for asterisks, \"ij.\" elements, or other performance notes.
};

export var LyricArray = {
  getLeft: function (lyricArray) {
    if (lyricArray.length === 0) return NaN;

    var x = Number.MAX_VALUE;
    for (var i = 0; i < lyricArray.length; i++) {
      if (lyricArray[i])
        x = Math.min(
          x,
          lyricArray[i].notation.bounds.x + lyricArray[i].bounds.x
        );
    }

    return x;
  },

  getRight: function (lyricArray, presumeConnectorNeeded) {
    if (lyricArray.length === 0) return NaN;

    var x = Number.MIN_VALUE;
    for (var i = 0; i < lyricArray.length; i++) {
      let l = lyricArray[i];
      if (l)
        x = Math.max(
          x,
          l.notation.bounds.x +
            l.bounds.x +
            l.bounds.width +
            (presumeConnectorNeeded && l.allowsConnector() && !l.needsConnector
              ? l.getConnectorWidth()
              : 0)
        );
    }

    return x;
  },

  hasOnlyOneLyric: function (lyricArray) {
    return lyricArray.filter((l) => l.originalText).length === 1;
  },

  indexOfLyric: function (lyricArray) {
    return lyricArray.indexOf(lyricArray.filter((l) => l.originalText)[0]);
  },

  mergeIn: function (lyricArray, newLyrics) {
    for (var i = 0; i < newLyrics.length; ++i) {
      if (newLyrics[i].originalText || !lyricArray[i])
        lyricArray[i] = newLyrics[i];
    }
  },

  mergeInArray: function (lyricArray, notations) {
    for (var i = 0; i < notations.length; ++i) {
      this.mergeIn(lyricArray, notations[i].lyrics);
    }
  },

  setNotation: function (lyricArray, notation) {
    notation.lyrics = lyricArray;
    for (var i = 0; i < lyricArray.length; ++i) {
      lyricArray[i].notation = notation;
    }
  }
};

export class Lyric extends TextElement {
  constructor(ctxt, text, lyricType, notation, notations, sourceIndex) {
    super(
      ctxt,
      (ctxt.textStyles.lyric.prefix || \"\") + text,
      (ctxt) => ctxt.textStyles.lyric.font,
      (ctxt) => ctxt.textStyles.lyric.size,
      \"start\",
      sourceIndex,
      text
    );
    this.textType = TextTypes.lyric;

    // save the original text in case we need to later use the lyric
    // in a dropcap...
    this.originalText = text;

    this.notation = notation;
    this.notations = notations;

    if (
      typeof lyricType === \"undefined\" ||
      lyricType === null ||
      lyricType === \"\"
    )
      this.lyricType = LyricType.SingleSyllable;
    else this.lyricType = lyricType;

    // Lyrics keep track of how to center them on notation elements.
    // centerTextIndex is the index in this.text where the centering starts,
    // centerLength is how many characters comprise the center point.
    // performLayout will do the processing
    this.centerStartIndex = -1;
    this.centerLength = text.length;

    this.needsConnector = false;

    // Lyrics can have their own language defined, which affects the alignment
    // of the text with the notation element
    this.language = null;

    if (this.allowsConnector)
      this.connectorSpan = new TextSpan(ctxt.syllableConnector);
  }

  allowsConnector() {
    return (
      this.lyricType === LyricType.BeginningSyllable ||
      this.lyricType === LyricType.MiddleSyllable
    );
  }

  setForceConnector(force) {
    this.forceConnector = force && this.allowsConnector();
  }

  setNeedsConnector(needs, width) {
    if (needs === true || this.forceConnector) {
      this.needsConnector = true;
      if (typeof width !== \"undefined\") {
        this.setConnectorWidth(width);
      } else {
        this.bounds.width =
          this.widthWithoutConnector + this.getConnectorWidth();
      }

      if (
        this.spans.length > 0 &&
        this.spans[this.spans.length - 1] !== this.connectorSpan
      )
        this.spans.push(this.connectorSpan);
    } else {
      this.connectorWidth = 0;
      this.needsConnector = false;
      this.bounds.width = this.widthWithoutConnector;

      var span = this.spans.pop();
      if (span && span !== this.connectorSpan) this.spans.push(span);
    }
  }

  setConnectorWidth(width) {
    this.connectorWidth = width;
    this.connectorSpan.properties = Object.assign(
      {},
      this.connectorSpan.properties,
      { textLength: width }
    );
    if (this.needsConnector)
      this.bounds.width = this.widthWithoutConnector + this.getConnectorWidth();
  }

  getConnectorWidth() {
    return this.connectorWidth || this.defaultConnectorWidth;
  }

  getLeft() {
    return this.notation.bounds.x + this.bounds.x;
  }

  getRight() {
    return this.notation.bounds.x + this.bounds.x + this.bounds.width;
  }

  recalculateMetrics(ctxt, resetNewLines = true) {
    this.setNeedsConnector();

    super.recalculateMetrics(ctxt, resetNewLines);

    this.widthWithoutConnector = this.bounds.width;

    this.connectorWidth = 0;
    this.defaultConnectorWidth = ctxt.hyphenWidth;

    var activeLanguage = this.language || ctxt.defaultLanguage;

    // calculate the point where the text lines up to the staff notation
    // and offset the rect that much. By default we just center the text,
    // but the logic below allows for smarter lyric alignment based
    // on manual override or language control.
    var offset = this.widthWithoutConnector / 2,
      x1,
      x2,
      vowelSegmentWidth = this.widthWithoutConnector;

    // some simple checks for sanity, and disable manual centering if the numbers are bad
    if (
      this.centerStartIndex >= 0 &&
      (this.centerStartIndex >= this.text.length ||
        this.centerLength < 0 ||
        this.centerStartIndex + this.centerLength > this.text.length)
    )
      this.centerStartIndex = -1;

    if (this.text.length === 0) {
      // if we have no text to work with, then there's nothing to do!
      // Unless it's a drop cap, in which case we center the connector:
      if (this.dropCap && this.originalText) {
        offset = ctxt.hyphenWidth / 2;
        vowelSegmentWidth = ctxt.hyphenWidth;
      }
    } else if (this.centerStartIndex >= 0) {
      // if we have manually overriden the centering logic for this lyric,
      // then always use that.
      if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Svg) {
        // svgTextMeasurer still has the current lyric in it...
        x1 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(
          0,
          this.centerStartIndex
        );
        x2 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(
          0,
          this.centerStartIndex + this.centerLength
        );
      } else {
        x1 = this.measureSubstring(ctxt, this.centerStartIndex);
        x2 = this.measureSubstring(
          ctxt,
          this.centerStartIndex + this.centerLength
        );
      }
      offset = (x1 + x2) / 2;
      vowelSegmentWidth = x2 - x1;
    } else {
      // if it's a directive with no manual centering override, then
      // just center the text.
      if (this.lyricType !== LyricType.Directive) {
        // only consider text content after the last space (if any)
        var startIndex = this.text.lastIndexOf(\" \") + 1;

        // unless there are no text characters following the space:
        if (
          startIndex > 0 &&
          !this.text
            .slice(startIndex)
            .match(/[a-záéíóúýäëïöüÿàèìòùỳāēīōūȳăĕĭŏŭ]/i)
        ) {
          startIndex = 0;
        }

        // Non-directive elements are lined up to the chant notation based on vowel segments,
        var result = activeLanguage.findVowelSegment(this.text, startIndex);

        if (result.found !== true) {
          var match = this.text.slice(startIndex).match(/[a-z]+/i);
          if (match) {
            result.startIndex = startIndex + match.index;
            result.length = match[0].length;
          } else {
            result.startIndex = startIndex;
            result.length = this.text.length - startIndex;
          }
        }
        if (ctxt.textMeasuringStrategy === TextMeasuringStrategy.Svg) {
          // svgTextMeasurer still has the current lyric in it...
          x1 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(
            0,
            result.startIndex
          );
          x2 = ctxt.svgTextMeasurer.firstChild.getSubStringLength(
            0,
            result.startIndex + result.length
          );
        } else {
          x1 = this.measureSubstring(ctxt, result.startIndex);
          x2 = this.measureSubstring(ctxt, result.startIndex + result.length);
        }
        offset = (x1 + x2) / 2;
        vowelSegmentWidth = x2 - x1;
      }
    }

    this.vowelSegmentWidth = vowelSegmentWidth;

    this.bounds.x = -offset;
    this.bounds.y = 0;

    this.origin.x = offset;
  }

  generateDropCap(ctxt) {
    if (this.dropCap) return this.dropCap;
    // disallow special characters:
    if (this.spans[0].properties['font-family'] === ctxt.specialCharProperties['font-family']) {
      return null;
    }
    let dropCapSpan = this.spans[0].clone();
    dropCapSpan.text = dropCapSpan.text.slice(0, 1).toUpperCase();
    let dropCapLowerCase = dropCapSpan.text.toLowerCase();
    // disallow any characters that do not change from .toUpperCase():
    if (dropCapSpan.text === dropCapLowerCase) return null;

    if (dropCapSpan.activeTags.indexOf(\"sc\") >= 0)
      dropCapSpan.text = dropCapLowerCase;

    var dropCap = (this.dropCap = new DropCap(ctxt, \"\", this.sourceIndex));
    dropCap.spans = [dropCapSpan];
    let dropCapSourceGabcLength = this.sourceGabc.match(
      /^(?:<\\/?[^>]>)*.?(?:<\\/[^>]>)*/
    )[0].length;
    dropCap.sourceGabc = this.sourceGabc.slice(0, dropCapSourceGabcLength);
    this.sourceIndex += dropCap.sourceGabc.length;
    this.sourceGabc = this.sourceGabc.slice(dropCapSourceGabcLength);

    this.spans[0].text = this.spans[0].text.slice(1);
    this.text = this.text.slice(1);
    this.centerStartIndex--; // lost a letter, so adjust centering accordingly

    return dropCap;
  }

  getCssClasses() {
    var classes = this.lyricType === LyricType.Directive ? \"directive \" : \"\";

    return classes + super.getCssClasses();
  }

  getExtraStyleProperties(ctxt) {
    var props = super.getExtraStyleProperties(ctxt);

    if (this.lyricType === LyricType.Directive && ctxt.autoColor === true)
      props = Object.assign({}, props, { fill: ctxt.rubricColor });

    return props;
  }
}

export class ChoralSign extends TextElement {
  constructor(ctxt, text, note, sourceIndex) {
    super(
      ctxt,
      (ctxt.textStyles.choralSign.prefix || \"\") + text,
      (ctxt) => ctxt.textStyles.choralSign.font,
      TextTypes.choralSign.size,
      \"start\",
      sourceIndex,
      text
    );
    this.positionHint = MarkingPositionHint.Default;
    this.note = note;
    this.textType = TextTypes.choralSign;
  }

  recalculateMetrics(ctxt) {
    super.recalculateMetrics(ctxt);
  }

  performLayout(ctxt) {
    this.recalculateMetrics(ctxt);
    this.bounds.x =
      this.note.bounds.x +
      Math.max(0, (ctxt.staffInterval - this.bounds.width) / 2); // center on the note itself

    let offset, staffPosition;
    if (this.positionHint === MarkingPositionHint.Below) {
      offset = -1;
      staffPosition = this.note.staffPosition + 2 * offset;
      staffPosition += staffPosition % 2 === 0 ? 0.3 : 1;
    } else {
      offset = 1;
      staffPosition = this.note.staffPosition + 2 * offset;
      staffPosition += staffPosition % 2 === 0 ? 0.3 : -0.4;
    }
    // if (staffPosition % 2 === 0) staffPosition += offset;
    this.bounds.y =
      ctxt.calculateHeightFromStaffPosition(staffPosition) + this.origin.y;
  }
}

export class AboveLinesText extends TextElement {
  /**
   * @param {String} text
   */
  constructor(ctxt, text, notation, sourceIndex) {
    super(
      ctxt,
      (ctxt.textStyles.al.prefix || \"\") + text,
      (ctxt) => ctxt.textStyles.al.font,
      (ctxt) => ctxt.textStyles.al.size,
      \"start\",
      sourceIndex,
      text
    );
    this.notation = notation;
    this.textType = TextTypes.al;

    this.padding = ctxt.staffInterval / 2;
  }
}

export class TranslationText extends TextElement {
  /**
   * @param {String} text
   */
  constructor(ctxt, text, notation, sourceIndex) {
    var gabcSource = text;
    var anchor = \"start\";
    if (text === \"/\") {
      text = \"\";
      anchor = \"end\";
    } else {
      text = (ctxt.textStyles.translation.prefix || \"\") + text;
    }
    super(
      ctxt,
      text,
      (ctxt) => ctxt.textStyles.translation.font,
      (ctxt) => ctxt.textStyles.translation.size,
      anchor,
      sourceIndex,
      gabcSource
    );
    this.notation = notation;
    this.textType = TextTypes.translation;

    this.padding = ctxt.staffInterval / 2;
  }
}

export class DropCap extends TextElement {
  /**
   * @param {String} text
   */
  constructor(ctxt, text, sourceIndex) {
    super(
      ctxt,
      (ctxt.textStyles.dropCap.prefix || \"\") + text,
      (ctxt) => ctxt.textStyles.dropCap.font,
      (ctxt) => ctxt.textStyles.dropCap.size,
      \"middle\",
      sourceIndex,
      text
    );
    this.textType = TextTypes.dropCap;

    this.padding = ctxt.staffInterval * ctxt.textStyles.dropCap.padding;
  }
}

export class TitleTextElement extends TextElement {
  constructor(
    ctxt,
    text,
    fontFamily,
    fontSize,
    textAnchor,
    sourceIndex,
    sourceGabc
  ) {
    super(
      ctxt,
      text,
      fontFamily,
      fontSize,
      textAnchor,
      sourceIndex,
      sourceGabc
    );
  }
}

export class Supertitle extends TitleTextElement {
  constructor(ctxt, text, sourceIndex) {
    super(
      ctxt,
      (ctxt.textStyles.supertitle.prefix || \"\") + text,
      (ctxt) => ctxt.textStyles.supertitle.font,
      (ctxt) => ctxt.textStyles.supertitle.size,
      \"middle\",
      sourceIndex,
      text
    );
    this.textType = TextTypes.supertitle;

    this.padding = (ctxt) => (
      (Number(ctxt.textStyles.supertitle.padding) || 1) * ctxt.textStyles.supertitle.size / 3
    );
  }
}

export class Title extends TitleTextElement {
  constructor(ctxt, text, sourceIndex) {
    super(
      ctxt,
      (ctxt.textStyles.title.prefix || \"\") + text,
      (ctxt) => ctxt.textStyles.title.font,
      (ctxt) => ctxt.textStyles.title.size,
      \"middle\",
      sourceIndex,
      text
    );
    this.textType = TextTypes.title;

    this.padding = (ctxt) => (
      (Number(ctxt.textStyles.title.padding) || 1) * ctxt.textStyles.title.size / 3
    );
  }
}

export class Subtitle extends TitleTextElement {
  constructor(ctxt, text, sourceIndex) {
    super(
      ctxt,
      (ctxt.textStyles.subtitle.prefix || \"\") + text,
      (ctxt) => ctxt.textStyles.subtitle.font,
      (ctxt) => ctxt.textStyles.subtitle.size,
      \"middle\",
      sourceIndex,
      text
    );
    this.textType = TextTypes.subtitle;

    this.padding = (ctxt) => (
      (Number(ctxt.textStyles.subtitle.padding) || 1) * ctxt.textStyles.subtitle.size / 3
    );
  }
}

export class TextLeftRight extends TitleTextElement {
  constructor(ctxt, text, type, sourceIndex) {
    super(
      ctxt,
      (ctxt.textStyles.leftRight.prefix || \"\") + text,
      (ctxt) => ctxt.textStyles.leftRight.font,
      (ctxt) => ctxt.textStyles.leftRight.size,
      type === \"textLeft\" ? \"start\" : \"end\",
      sourceIndex,
      text
    );
    this.textType = TextTypes.leftRight;
    this.extraClass = type === \"textLeft\" ? \"textLeft\" : \"textRight\";
    this.headerKey = type === \"textLeft\" ? \"text-left\" : \"text-right\";
    this.padding = (ctxt) => (
      (Number(ctxt.textStyles.leftRight.padding) || 1) * ctxt.textStyles.leftRight.size / 5
    );
  }

  getCssClasses() {
    return this.extraClass + \" \" + super.getCssClasses();
  }
}

export class Annotation extends TextElement {
  /**
   * @param {String} text
   */
  constructor(ctxt, text) {
    super(
      ctxt,
      (ctxt.textStyles.annotation.prefix || \"\") + text,
      (ctxt) => ctxt.textStyles.annotation.font,
      (ctxt) => ctxt.textStyles.annotation.size,
      \"middle\"
    );
    this.textType = TextTypes.annotation;
    this.padding = ctxt.staffInterval * ctxt.textStyles.annotation.padding;
    this.dominantBaseline = \"hanging\"; // so that annotations can be aligned at the top.
  }
}

export class Annotations extends ChantLayoutElement {
  /**
   * @param {String} text
   */
  constructor(ctxt, ...texts) {
    super();

    this.lineHeight = 1.1;
    this.annotations = texts.map(function (text) {
      return new Annotation(ctxt, text);
    });
    this.padding = Math.max.apply(
      null,
      this.annotations.map(function (annotation) {
        return annotation.padding;
      })
    );
  }

  updateBounds(multiplier) {
    if (!multiplier) multiplier = 1;
    for (var i = 0; i < this.annotations.length; ++i) {
      var annotation = this.annotations[i];
      annotation.bounds.x += this.bounds.x * multiplier;
      annotation.bounds.y += this.bounds.y * multiplier;
    }
  }

  recalculateMetrics(ctxt) {
    this.bounds.x = 0;
    this.bounds.y = 0;

    this.bounds.width = 0;
    this.bounds.height = 0;

    this.origin.x = 0;
    this.origin.y = 0;

    let y = 0;
    for (var i = 0; i < this.annotations.length; ++i) {
      var annotation = this.annotations[i];
      annotation.recalculateMetrics(ctxt);
      this.bounds.width = Math.max(this.bounds.width, annotation.bounds.width);
      annotation.bounds.y += y;
      this.bounds.height = annotation.bounds.bottom();
      this.origin.y = this.origin.y || annotation.origin.y;
      y += annotation.fontSize(ctxt) * (annotation.resize || 1) * this.lineHeight;
    }
  }

  draw(ctxt) {
    this.updateBounds();
    this.annotations.forEach(function (annotation) {
      annotation.draw(ctxt);
    });
    this.updateBounds(-1);
  }

  createSvgNode(ctxt) {
    this.updateBounds();
    var result = this.annotations.map(function (annotation) {
      return annotation.createSvgNode(ctxt);
    });
    this.updateBounds(-1);
    return result;
  }
  createSvgTree(ctxt) {
    this.updateBounds();
    var result = this.annotations.map(function (annotation) {
      return annotation.createSvgTree(ctxt);
    });
    this.updateBounds(-1);
    return { children: result };
  }

  createSvgFragment(ctxt) {
    this.updateBounds();
    var result = this.annotations
      .map(function (annotation) {
        return annotation.createSvgFragment(ctxt);
      })
      .join(\"\");
    this.updateBounds(-1);
    return result;
  }
}

export class ChantNotationElement extends ChantLayoutElement {
  constructor() {
    super();

    //double
    this.leadingSpace = 0.0;
    this.trailingSpace = DefaultTrailingSpace;
    this.keepWithNext = false;
    this.needsLayout = true;

    this.lyrics = [];

    this.score = null; // the ChantScore
    this.line = null; // the ChantLine

    this.visualizers = [];
  }

  hasLyrics() {
    return this.lyrics.length !== 0;
  }

  getAllLyricsLeft() {
    if (this.lyrics.length === 0) return this.bounds.right();

    var x = Number.MAX_VALUE;
    for (var i = 0; i < this.lyrics.length; i++) {
      if (this.lyrics[i]) x = Math.min(x, this.lyrics[i].bounds.x);
    }

    return this.bounds.x + x;
  }

  getAllLyricsRight() {
    if (this.lyrics.length === 0) return this.bounds.x;

    var x = Number.MIN_VALUE;
    for (var i = 0; i < this.lyrics.length; i++) {
      if (this.lyrics[i])
        x = Math.max(x, this.lyrics[i].bounds.x + this.lyrics[i].bounds.width);
    }

    return this.bounds.x + x;
  }

  // used by subclasses while building up the chant notations.
  addVisualizer(chantLayoutElement) {
    if (!chantLayoutElement.ignoreBounds) {
      if (this.bounds.isEmpty())
        this.bounds = chantLayoutElement.bounds.clone();
      else this.bounds.union(chantLayoutElement.bounds);
    }

    this.visualizers.push(chantLayoutElement);
  }

  // same as addVisualizer, except the element is unshifted to the front
  // of the visualizer array rather than the end. This way, some
  // visualizers can be placed behind the others...ledger lines for example.
  prependVisualizer(chantLayoutElement) {
    if (this.bounds.isEmpty()) this.bounds = chantLayoutElement.bounds.clone();
    else this.bounds.union(chantLayoutElement.bounds);

    this.visualizers.unshift(chantLayoutElement);
  }

  // chant notation elements are given an opportunity to perform their layout via this function.
  // subclasses should call this function first in overrides of this function.
  // on completion, exsurge presumes that the bounds, the origin, and the fragment objects are
  // all valid and prepared for higher level layout.
  performLayout(ctxt) {
    if (typeof this.trailingSpace === \"function\")
      this.calculatedTrailingSpace = this.trailingSpace(ctxt);
    else this.calculatedTrailingSpace = this.trailingSpace;

    // reset the bounds and the staff notations before doing a layout
    this.visualizers = [];
    this.bounds = new Rect(Infinity, Infinity, -Infinity, -Infinity);

    for (var i = 0; i < this.lyrics.length; i++)
      this.lyrics[i].recalculateMetrics(ctxt);

    if (this.alText)
      for (i = 0; i < this.alText.length; i++)
        this.alText[i].recalculateMetrics(ctxt);

    if (this.translationText)
      for (i = 0; i < this.translationText.length; i++)
        this.translationText[i].recalculateMetrics(ctxt);
  }

  // some subclasses have internal dependencies on other notations (for example,
  // a custos can depend on a later neume which it uses to set its height).
  // subclasses can override this function so that when the notations are
  // altered, the subclass can correctly invalidate (and later restore) its own
  // depedencies
  resetDependencies() {}

  // a helper function for subclasses to call after they are done performing layout...
  finishLayout(ctxt) {
    this.bounds.x = 0;

    let language =
      (this.lyrics[0] && this.lyrics[0].language) || ctxt.defaultLanguage;
    // center the neume itself over the syllable, or just the first punctum
    // if the neume is wider than the syllable + the width of a punctum, we always revert to centering just over the punctum
    let calculateLyricX = language.centerNeume
      ? (lyric) =>
          (lyric.bounds.x =
            this.bounds.width + ctxt.staffInterval < lyric.vowelSegmentWidth
              ? this.bounds.width / 2 - lyric.origin.x
              : this.origin.x - lyric.origin.x)
      : (lyric) => (lyric.bounds.x = this.origin.x - lyric.origin.x);
    this.lyrics.forEach(calculateLyricX);

    this.needsLayout = false;
  }

  draw(ctxt) {
    var canvasCtxt = ctxt.canvasCtxt;
    canvasCtxt.translate(this.bounds.x, 0);

    for (var i = 0; i < this.visualizers.length; i++)
      this.visualizers[i].draw(ctxt);

    for (i = 0; i < this.lyrics.length; i++) this.lyrics[i].draw(ctxt);

    if (this.translationText)
      for (i = 0; i < this.translationText.length; i++)
        this.translationText[i].draw(ctxt);

    if (this.alText)
      for (i = 0; i < this.alText.length; i++) this.alText[i].draw(ctxt);

    canvasCtxt.translate(-this.bounds.x, 0);
  }

  getInnerSvgNodes(ctxt, functionName = \"createSvgNode\") {
    var inner = [];

    for (i = 0; i < this.lyrics.length; i++)
      inner.push(this.lyrics[i][functionName](ctxt));

    if (this.translationText)
      for (i = 0; i < this.translationText.length; i++)
        inner.push(this.translationText[i][functionName](ctxt));

    if (this.alText)
      for (i = 0; i < this.alText.length; i++)
        inner.push(this.alText[i][functionName](ctxt));

    if (this.visualizers.length) {
      let visualizers = [];
      for (var i = 0; i < this.visualizers.length; i++)
        visualizers.push(this.visualizers[i][functionName](ctxt, this));

      if (functionName === \"createSvgTree\") {
        inner.push(
          QuickSvg.createSvgTree(\"g\", { class: \"Notations\" }, ...visualizers)
        );
      } else {
        inner.push(
          QuickSvg.createNode(\"g\", { class: \"Notations\" }, visualizers)
        );
      }
    }
    return inner;
  }

  getSvgProps() {
    return {
      // this.constructor.name will not be the same after being mangled by UglifyJS
      class: \"ChantNotationElement \" + this.constructor.name,
      transform: \"translate(\" + this.bounds.x + \",\" + 0 + \")\"
    };
  }

  createSvgNode(ctxt) {
    var inner = this.getInnerSvgNodes(ctxt, \"createSvgNode\");
    var svgProps = this.getSvgProps();
    svgProps.source = this;
    return QuickSvg.createNode(\"g\", svgProps, inner);
  }
  createSvgTree(ctxt) {
    var inner = this.getInnerSvgNodes(ctxt, \"createSvgTree\");
    var svgProps = this.getSvgProps();
    svgProps.source = this;
    return QuickSvg.createSvgTree(\"g\", svgProps, ...inner);
  }

  createSvgFragment(ctxt) {
    var inner = \"\";

    for (i = 0; i < this.lyrics.length; i++)
      inner += this.lyrics[i].createSvgFragment(ctxt);

    if (this.translationText)
      for (i = 0; i < this.translationText.length; i++)
        inner += this.translationText[i].createSvgFragment(ctxt);

    if (this.alText)
      for (i = 0; i < this.alText.length; i++)
        inner += this.alText[i].createSvgFragment(ctxt);

    for (var i = 0; i < this.visualizers.length; i++)
      inner += this.visualizers[i].createSvgFragment(ctxt, this);

    return QuickSvg.createFragment(\"g\", this.getSvgProps(), inner);
  }
}



// WEBPACK FOOTER //
// ./src/Exsurge.Drawing.js","export const addAccent = (vowel) =>
  ({
    \"Æ\": \"Ǽ\",
    \"Œ\": \"Œ́\",
    \"A\": \"Á\",
    \"E\": \"É\",
    \"I\": \"Í\",
    \"O\": \"Ó\",
    \"U\": \"Ú\",
    \"Y\": \"Ý\",
    \"æ\": \"ǽ\",
    \"œ\": \"œ́\",
    \"a\": \"á\",
    \"e\": \"é\",
    \"i\": \"í\",
    \"o\": \"ó\",
    \"u\": \"ú\",
    \"y\": \"ý\"
  }[vowel] || vowel);



// WEBPACK FOOTER //
// ./src/addAccent.js","export const makeLigature = (vowels) =>
  ({
    AE: \"Æ\",
    Ae: \"Æ\",
    ae: \"æ\",
    OE: \"Œ\",
    Oe: \"Œ\",
    oe: \"œ\"
  }[vowels] || vowels);



// WEBPACK FOOTER //
// ./src/makeLigature.js","export const greextraGlyphs = {
  MedicaeaFlat: \"\",
  HufnagelCustosUpShort: \"\",
  HufnagelCustosUpLong: \"\",
  HufnagelCustosUpMedium: \"\",
  HufnagelCustosDownShort: \"\",
  HufnagelCustosDownLong: \"\",
  HufnagelCustosDownMedium: \"\",
  MedicaeaCustosUpShort: \"\",
  MedicaeaCustosUpLong: \"\",
  MedicaeaCustosUpMedium: \"\",
  MedicaeaCustosDownShort: \"\",
  MedicaeaCustosDownLong: \"\",
  MedicaeaCustosDownMedium: \"\",
  MensuralCustosUpShort: \"\",
  MensuralCustosUpLong: \"\",
  MensuralCustosUpMedium: \"\",
  MensuralCustosDownShort: \"\",
  MensuralCustosDownLong: \"\",
  MensuralCustosDownMedium: \"\",
  MensuralFlat: \"\",
  HufnagelFlat: \"\",
  MedicaeaCClef: \"\",
  MedicaeaCClefChange: \"\",
  MedicaeaFClef: \"\",
  MedicaeaFClefChange: \"\",
  HufnagelCClef: \"\",
  HufnagelCClefChange: \"\",
  HufnagelFClef: \"\",
  HufnagelFClefChange: \"\",
  HugnagelCFClef: \"\",
  HufnagelCFClefChange: \"\",
  MensuralFlatHole: \"\",
  HufnagelFlatHole: \"\",
  MedicaeaFlatHole: \"\",
  StarSix: \"\",
  Dagger: \"\",
  \"Bar.alt\": \"\",
  StarHeight: \"\",
  Cross: \"\",
  \"RBar.alt\": \"\",
  \"VBar.alt\": \"\",
  Drawing1: \"\",
  Drawing2: \"\",
  RWithBarGoth: \"\",
  VWithBarGoth: \"\",
  Line1: \"\",
  Line2: \"\",
  Line3: \"\",
  Line4: \"\",
  Line5: \"\",
  \"Cross.alt\": \"\",
  ABarCaption: \"\",
  RBarCaption: \"\",
  VBarCaption: \"\",
  ABarCaptionSC: \"\",
  RBarCaptionSC: \"\",
  VBarCaptionSC: \"\",
  ABar: \"\",
  RBar: \"\",
  VBar: \"\",
  ABarSC: \"\",
  RBarSC: \"\",
  VBarSC: \"\",
  ABarSmall: \"\",
  RBarSmall: \"\",
  VBarSmall: \"\",
  ABarSmallSC: \"\",
  RBarSmallSC: \"\",
  VBarSmallSC: \"\",
  \"RBar.alt2\": \"\",
  \"VBar.alt2\": \"\",
  ABarCaptionSlant: \"\",
  RBarCaptionSlant: \"\",
  VBarCaptionSlant: \"\",
  ABarSlant: \"\",
  RBarSlant: \"\",
  VBarSlant: \"\",
  ABarSmallSlant: \"\",
  RBarSmallSlant: \"\",
  VBarSmallSlant: \"\"
};



// WEBPACK FOOTER //
// ./src/greextraGlyphs.js","//
// Author(s):
// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
//
// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the \"Software\"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

import { ChantLine } from \"./Exsurge.Chant.ChantLine.js\";
import { InsertionCursor } from \"./Exsurge.Chant.Signs.js\";
import { Pitch, Rect, Step } from \"./Exsurge.Core.js\";
import {
  Annotation, ChantLayoutElement,
  ChantNotationElement,
  GlyphCode,
  GlyphVisualizer, QuickSvg, TextLeftRight,
  TextSpan
} from \"./Exsurge.Drawing.js\";
import { Gabc } from \"./Exsurge.Gabc.js\";
import { Titles } from \"./Exsurge.Titles.js\";

export var LiquescentType = {
  None: 0,

  // flags that can be combined, though of course it
  // it doesn't make sense to combine some!
  Large: 1 << 0,
  Small: 1 << 1,
  Ascending: 1 << 2,
  Descending: 1 << 3,
  InitioDebilis: 1 << 4,

  // handy liquescent types
  LargeAscending: (1 << 0) | (1 << 2),
  LargeDescending: (1 << 0) | (1 << 3),
  SmallAscending: (1 << 1) | (1 << 2),
  SmallDescending: (1 << 1) | (1 << 3)
};

export var NoteShape = {
  // shapes
  Default: 0,
  Virga: 1,
  Inclinatum: 2,
  Quilisma: 3,
  Stropha: 4,
  Oriscus: 5
};

export var NoteShapeModifiers = {
  // flags which modify the shape
  // not all of them apply to every shape of course
  None: 0,
  Ascending: 1 << 0,
  Descending: 1 << 1,
  Cavum: 1 << 2,
  Stemmed: 1 << 3,
  Linea: 1 << 4,
  Reverse: 1 << 5
};

/**
 * @class
 */
export class Note extends ChantLayoutElement {
  /**
   * @para {Pitch} pitch
   */
  constructor(pitch) {
    super();

    if (typeof pitch !== \"undefined\") this.pitch = pitch;
    else this.pitch = null;

    this.glyphVisualizer = null;

    // The staffPosition on a note is an integer that indicates the vertical position on the staff.
    // 0 is the center space on the staff (equivalent to gabc 'g'). Positive numbers go up
    // the staff, and negative numbers go down, i.e., 1 is gabc 'h', 2 is gabc 'i', -1 is gabc 'f', etc.
    this.staffPosition = 0;
    this.liquescent = LiquescentType.None;
    this.shape = NoteShape.Default;
    this.shapeModifiers = NoteShapeModifiers.None;

    // notes keep track of the neume they belong to in order to facilitate layout
    // this.neume gets set when a note is added to a neume via Neume.addNote()
    this.neume = null;

    // various markings that can exist on a note, organized by type
    // for faster access and simpler code logic
    this.episemata = [];
    this.morae = []; // silly to have an array of these, but gabc allows multiple morae per note!

    // these are set on the note when they are needed, otherwise, they're undefined
    // this.ictus
    // this.accuteAccent
    // this.braceStart
    // this.braceEnd
  }

  setGlyph(ctxt, glyphCode) {
    if (this.glyphVisualizer) this.glyphVisualizer.setGlyph(ctxt, glyphCode);
    else this.glyphVisualizer = new GlyphVisualizer(ctxt, glyphCode);

    this.glyphVisualizer.setStaffPosition(ctxt, this.staffPosition);

    // assign glyphvisualizer metrics to this note
    this.bounds.x = this.glyphVisualizer.bounds.x;
    this.bounds.y = this.glyphVisualizer.bounds.y;
    this.bounds.width = this.glyphVisualizer.bounds.width;
    this.bounds.height = this.glyphVisualizer.bounds.height;

    this.origin.x = this.glyphVisualizer.origin.x;
    this.origin.y = this.glyphVisualizer.origin.y;
  }

  // a utility function for modifiers
  shapeModifierMatches(shapeModifier) {
    if (shapeModifier === NoteShapeModifiers.None)
      return this.shapeModifier === NoteShapeModifiers.None;
    else return this.shapeModifier & (shapeModifier !== 0);
  }

  draw(ctxt) {
    this.glyphVisualizer.bounds.x = this.bounds.x;
    this.glyphVisualizer.bounds.y = this.bounds.y;

    this.glyphVisualizer.draw(ctxt);
  }

  createSvgNode(ctxt) {
    this.glyphVisualizer.bounds.x = this.bounds.x;
    this.glyphVisualizer.bounds.y = this.bounds.y;
    this.svgNode = this.glyphVisualizer.createSvgNode(ctxt, this);
    return this.svgNode;
  }
  createSvgTree(ctxt) {
    this.glyphVisualizer.bounds.x = this.bounds.x;
    this.glyphVisualizer.bounds.y = this.bounds.y;
    return this.glyphVisualizer.createSvgTree(ctxt, this);
  }

  createSvgFragment(ctxt) {
    this.glyphVisualizer.bounds.x = this.bounds.x;
    this.glyphVisualizer.bounds.y = this.bounds.y;
    return this.glyphVisualizer.createSvgFragment(ctxt, this);
  }
}

export class Clef extends ChantNotationElement {
  constructor(staffPosition, octave, defaultAccidental = null) {
    super();

    this.isClef = true;
    this.staffPosition = staffPosition;
    this.octave = octave;
    this.defaultAccidental = defaultAccidental;
    this.activeAccidental = defaultAccidental;
    this.keepWithNext = true;
  }

  resetAccidentals() {
    this.activeAccidental = this.defaultAccidental;
  }

  pitchToStaffPosition(pitch) {}

  performLayout(ctxt) {
    ctxt.activeClef = this;

    if (this.defaultAccidental) this.defaultAccidental.performLayout(ctxt);

    super.performLayout(ctxt);
  }

  finishLayout(ctxt) {
    // if we have a default accidental, then add a glyph for it now
    if (this.defaultAccidental) {
      var accidentalGlyph = this.defaultAccidental.createGlyphVisualizer(ctxt);
      accidentalGlyph.bounds.x +=
        this.visualizers[0].bounds.right() + ctxt.intraNeumeSpacing;
      this.addVisualizer(accidentalGlyph);
    }

    super.finishLayout(ctxt);
  }

  static default() {
    return __defaultDoClef;
  }

  clone() {
    if (this.model) return this.model.clone();
    let clone = new this.constructor(
      this.staffPosition,
      this.octave,
      this.defaultAccidental
    );
    clone.sourceGabc = this.sourceGabc;
    clone.sourceIndex = this.sourceIndex;
    clone.elementIndex = this.elementIndex;
    clone.model = this;
    return clone;
  }
}

export class DoClef extends Clef {
  constructor(staffPosition, octave, defaultAccidental = null) {
    super(staffPosition, octave, defaultAccidental);

    this.leadingSpace = 0.0;
  }

  pitchToStaffPosition(pitch) {
    return (
      (pitch.octave - this.octave) * 7 +
      this.staffPosition +
      Pitch.stepToStaffOffset(pitch.step) -
      Pitch.stepToStaffOffset(Step.Do)
    );
  }

  staffPositionToPitch(staffPosition) {
    var offset = staffPosition - this.staffPosition;
    var octaveOffset = Math.floor(offset / 7);

    var step = Pitch.staffOffsetToStep(offset);

    if (
      this.activeAccidental &&
      this.activeAccidental.staffPosition === staffPosition
    )
      step += this.activeAccidental.accidentalType;

    return new Pitch(step, this.octave + octaveOffset);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    var glyph = new GlyphVisualizer(ctxt, GlyphCode.DoClef);
    glyph.setStaffPosition(ctxt, this.staffPosition);
    this.addVisualizer(glyph);

    this.finishLayout(ctxt);
  }
}

var __defaultDoClef = new DoClef(3, 2);

export class FaClef extends Clef {
  constructor(staffPosition, octave, defaultAccidental = null) {
    super(staffPosition, octave, defaultAccidental);

    this.octave = octave;

    this.leadingSpace = 0;
  }

  pitchToStaffPosition(pitch) {
    return (
      (pitch.octave - this.octave) * 7 +
      this.staffPosition +
      Pitch.stepToStaffOffset(pitch.step) -
      Pitch.stepToStaffOffset(Step.Fa)
    );
  }

  staffPositionToPitch(staffPosition) {
    var offset = staffPosition - this.staffPosition + 3; // + 3 because it's a fa clef (3 == offset from Do)
    var octaveOffset = Math.floor(offset / 7);

    var step = Pitch.staffOffsetToStep(offset);

    if (
      this.activeAccidental &&
      this.activeAccidental.staffPosition === staffPosition
    )
      step += this.activeAccidental.accidentalType;

    return new Pitch(step, this.octave + octaveOffset);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    var glyph = new GlyphVisualizer(ctxt, GlyphCode.FaClef);
    glyph.setStaffPosition(ctxt, this.staffPosition);
    this.addVisualizer(glyph);

    this.finishLayout(ctxt);
  }
}

/*
 * TextOnly
 */
export class TextOnly extends ChantNotationElement {
  constructor(sourceIndex, sourceLength) {
    super();
    this.sourceIndex = sourceIndex;
    this.sourceLength = sourceLength;
    this.sourceGabc = \"\";
    this.trailingSpace = 0;
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    // add an empty glyph as a placeholder
    this.addVisualizer(new GlyphVisualizer(ctxt, GlyphCode.None));

    this.origin.x = 0;
    this.origin.y = 0;

    this.finishLayout(ctxt);
  }
}

export class ChantLineBreak extends ChantNotationElement {
  constructor(justify) {
    super();
    this.calculatedTrailingSpace = this.trailingSpace = 0;
    this.justify = justify;
  }

  performLayout(ctxt) {
    // reset the bounds before doing a layout
    this.bounds = new Rect(0, 0, 0, 0);
  }

  clone() {
    var lb = new ChantLineBreak();
    lb.justify = this.justify;

    return lb;
  }
}

// a chant mapping is a lightweight format independent way of
// tracking how a chant language (e.g., gabc) has been
// mapped to exsurge notations.
export class ChantMapping {
  // source can be any object type. in the case of gabc, source is a text
  // string that maps to a gabc word (e.g.: \"no(g)bis(fg)\").
  // notations is an array of ChantNotationElements
  constructor(source, notations, sourceIndex) {
    this.source = source;
    this.notations = notations;
    this.sourceIndex = sourceIndex;
  }
}

const __connectorSpan = new TextSpan(\" • \"),
  __mergeAnnotationWithTextLeft = (...annotationSpans) =>
    annotationSpans.reduce((result, spans) => {
      if (result && result.length) {
        if (spans && spans.length) return result.concat(__connectorSpan, spans);
        else return result;
      } else if (spans && spans.length) {
        return spans;
      }
      return [];
    });

/*
 * Score, document
 */
export class ChantScore {
  // mappings is an array of ChantMappings.
  constructor(ctxt, mappings = [], useDropCap) {
    this.mappings = mappings;

    this.lines = [];
    this.notes = [];
    if (ctxt) this.titles = new Titles(ctxt, this);

    this.startingClef = null;

    this.useDropCap = useDropCap;
    this.dropCap = null;

    this.annotation = null;

    this.compiled = false;

    this.autoColoring = true;
    this.needsLayout = true;

    // valid after chant lines are created...
    this.bounds = new Rect();

    this.mergeAnnotationWithTextLeft = __mergeAnnotationWithTextLeft;

    if (ctxt) this.updateNotations(ctxt);
  }

  /**
   * Make a copy of the score, only including the specified lines
   * @param  {number} startLine starting index
   * @param  {number} endLine   ending index
   * @return {ChantScore}           the partial score
   */
  copyLines(startLine, endLine) {
    let result = new ChantScore();
    result.lines = this.lines.slice(startLine, endLine);
    result.bounds = this.bounds.clone();
    let lastLine = result.lines.slice(-1)[0];
    result.bounds.height = lastLine.bounds.bottom() - lastLine.origin.y;
    if (startLine === 0) {
      result.titles = this.titles;
      result.dropCap = this.dropCap;
      result.annotation = this.annotation;
    }
    return result;
  }

  updateSelection(selection) {
    this.selection = selection;
    const elementSelection = (selection && selection.element) || {
      indices: []
    };
    const selectedIndices = elementSelection.indices;
    let insertion = elementSelection.insertion;
    if (
      !insertion &&
      selectedIndices.length === 1 &&
      this.notes[selectedIndices[0]] instanceof TextOnly
    ) {
      // if there is only one selection, and its a text only, it should display as an insertion cursor:
      insertion = { afterElementIndex: selectedIndices[0] };
    }
    // update the selected elements so that they can be given a .selected class when rendered
    for (let i = 0; i < this.notes.length; ++i) {
      let element = this.notes[i];
      element.selected = selectedIndices.includes(i);
    }
    (
      this.startingClef.model || this.startingClef
    ).selected = selectedIndices.includes(-1);
    for (let i = 0; i < this.lines.length; ++i) {
      this.lines[i].insertionCursor = null;
    }
    // update the insertion cursor, so it can be drawn on the correct system
    this.insertionElement = null;
    let insertionLine = null;
    if (insertion) {
      if (typeof insertion.chantLine === \"number\") {
        insertionLine = this.lines[insertion.chantLine];
        this.insertionElement = insertionLine.startingClef;
        insertionLine.insertionCursor = new InsertionCursor();
      } else if (typeof insertion.afterElementIndex === \"number\") {
        this.insertionElement = this.notes[insertion.afterElementIndex];
        if (!this.insertionElement) {
          insertionLine = this.lines[0];
          this.insertionElement = insertionLine.startingClef;
        } else if (this.insertionElement.neume) {
          this.insertionElement = this.insertionElement.neume;
        }
        if (!insertionLine) {
          insertionLine = this.insertionElement.line || this.lines[this.lines.length - 1];
        }
        insertionLine.insertionCursor = new InsertionCursor();
      }
    }
  }

  updateNotations(ctxt) {
    var i, j, mapping, notation;

    // flatten all mappings into one array for N(0) access to notations
    this.notations = [];
    this.notes = [];
    this.hasLyrics = false;
    this.hasAboveLinesText = false;
    this.hasTranslations = false;
    const elementSelection = (this.selection && this.selection.element) || {
      indices: []
    };
    const selectedIndices = elementSelection.indices;
    let nonNoteElementCount = 0;

    // find the starting clef...
    // start with a default clef in case the notations don't provide one.
    this.startingClef = null;

    for (i = 0; i < this.mappings.length; i++) {
      mapping = this.mappings[i];
      for (j = 0; j < mapping.notations.length; j++) {
        notation = mapping.notations[j];
        notation.score = this;
        notation.mapping = mapping;

        if (!this.startingClef) {
          if (notation.isNeume) {
            this.startingClef = Clef.default();
          } else if (notation.isClef) {
            this.startingClef = notation;
            continue;
          }
        }

        notation.notationIndex = this.notations.push(notation) - 1;
        if (!this.hasLyrics && notation.hasLyrics()) this.hasLyrics = true;
        if (!this.hasAboveLinesText && notation.alText)
          this.hasAboveLinesText = true;
        if (!this.hasTranslations && notation.translationText)
          this.hasTranslations = true;

        // Update this.notes and find element indices:
        let elements = notation.notes || [notation];
        for (let element of elements) {
          let elementIndex = (element.elementIndex =
            this.notes.push(element) - 1);
          if (element instanceof Note) {
            element.noteIndex = elementIndex - nonNoteElementCount;
          } else {
            ++nonNoteElementCount;
          }
          
          element.selected = selectedIndices.includes(elementIndex);
        }
      }
    }

    // if we've reached this far and we *still* don't have a clef, then there aren't even
    // any neumes in the score. still, set the default clef just for good measure
    if (!this.startingClef) this.startingClef = Clef.default();
    this.startingClef.elementIndex = -1;

    // update drop cap
    if (this.useDropCap) this.recreateDropCap(ctxt);
    else this.dropCap = null;

    this.needsLayout = true;
  }

  recreateDropCap(ctxt) {
    this.dropCap = null;

    // find the first notation with lyrics to use
    for (var i = 0; i < this.notations.length; i++) {
      if (
        this.notations[i].hasLyrics() &&
        this.notations[i].lyrics[0] !== null &&
        this.notations[i].lyrics[0].spans &&
        this.notations[i].lyrics[0].spans.length
      ) {
        let notation = this.notations[i],
          lyrics = notation.lyrics[0];
        if (this.useDropCap) {
          this.dropCap = lyrics.generateDropCap(ctxt);
        } else {
          lyrics.dropCap = null;
          lyrics.generateSpansFromText(ctxt, lyrics.originalText);
        }
        notation.needsLayout = true;
        return;
      }
    }
  }

  /**
   * Shared layout initialization method for performLayout() and performLayoutAsync()
   * @param  {ChantContext} ctxt
   */
  initializeLayout(ctxt) {
    // setup the context
    ctxt.activeClef = this.startingClef;
    ctxt.notations = this.notations;
    ctxt.currNotationIndex = 0;

    if (this.dropCap) this.dropCap.recalculateMetrics(ctxt);

    if (this.annotation) this.annotation.recalculateMetrics(ctxt);
  }

  // this is the the synchronous version of performLayout that
  // process everything without yielding to any other workers/threads.
  // good for server side processing or very small chant pieces.
  performLayout(ctxt, force) {
    if (!force && this.needsLayout === false) return; // nothing to do here!

    ctxt.updateHyphenWidth();

    this.initializeLayout(ctxt);

    for (let i = 0; i < this.notations.length; i++) {
      let notation = this.notations[i];
      if (force || notation.needsLayout) {
        ctxt.currNotationIndex = i;
        notation.performLayout(ctxt);
      }
    }

    this.needsLayout = false;
  }

  // for web applications, probably performLayoutAsync would be more
  // apppropriate that the above performLayout, since it will process
  // the notations without locking up the UI thread.
  performLayoutAsync(ctxt, finishedCallback) {
    if (this.needsLayout === false) {
      if (finishedCallback) setTimeout(() => finishedCallback(), 0);

      return; // nothing to do here!
    }

    if (ctxt.onFontLoaded) {
      ctxt.onFontLoaded.push(() =>
        this.performLayoutAsync(ctxt, finishedCallback)
      );
      return;
    }

    // check for sane value of hyphen width:
    ctxt.updateHyphenWidth();
    if (
      !ctxt.hyphenWidth ||
      ctxt.hyphenWidth / ctxt.textStyles.lyric.size > 0.6
    ) {
      setTimeout(() => {
        this.performLayoutAsync(ctxt, finishedCallback);
      }, 100);
      return;
    }

    this.initializeLayout(ctxt);

    setTimeout(() => this.layoutElementsAsync(ctxt, 0, finishedCallback), 0);
  }

  layoutElementsAsync(ctxt, index, finishedCallback) {
    if (index >= this.notations.length) {
      this.needsLayout = false;

      if (finishedCallback) setTimeout(() => finishedCallback(), 0);

      return;
    }

    if (index === 0) ctxt.activeClef = this.startingClef;

    var timeout = new Date().getTime() + 50; // process for fifty milliseconds
    do {
      var notation = this.notations[index];
      if (notation.needsLayout) {
        ctxt.currNotationIndex = index;
        notation.performLayout(ctxt);
      }

      index++;
    } while (index < this.notations.length && new Date().getTime() < timeout);

    // schedule the next block of processing
    setTimeout(
      () => this.layoutElementsAsync(ctxt, index, finishedCallback),
      0
    );
  }

  layoutChantLines(ctxt, width, finishedCallback) {
    this.lines = [];

    if (this.mergeAnnotationWithTextLeft && this.annotation && !this.dropCap) {
      let annotation = this.annotation,
        annotationSpans = annotation.annotations
          ? annotation.annotations.map((annotation) => annotation.spans)
          : [annotation.spans];
      this.overrideTextLeft = new TextLeftRight(ctxt, \"\", \"textLeft\");
      if (ctxt.mapAnnotationSpansToTextLeft) {
        annotationSpans = annotationSpans.map(ctxt.mapAnnotationSpansToTextLeft);
      }
      this.overrideTextLeft.spans = this.mergeAnnotationWithTextLeft(
        ...annotationSpans,
        this.titles.textLeft && this.titles.textLeft.spans
      );
    } else {
      this.overrideTextLeft = null;
    }

    var y = width > 0 ? this.titles.layoutTitles(ctxt, width) : 0;
    var currIndex = 0;

    ctxt.activeClef = this.startingClef;

    var spaceBetweenSystems = ctxt.staffInterval * ctxt.spaceBetweenSystems;

    do {
      var line = new ChantLine(this);

      line.buildFromChantNotationIndex(ctxt, currIndex, width);
      currIndex = line.notationsStartIndex + line.numNotationsOnLine;
      line.performLayout(ctxt);
      line.elementIndex = this.lines.length;
      this.lines.push(line);

      line.bounds.y = -line.bounds.y + y;
      y += line.bounds.height + spaceBetweenSystems;
    } while (currIndex < this.notations.length);

    var lastLine = this.lines[this.lines.length - 1];

    this.bounds.x = 0;
    this.bounds.y = 0;
    this.bounds.width = lastLine.bounds.width;
    this.bounds.height = y - spaceBetweenSystems;

    this.pages = [this];

    if (this.selection) {
      this.updateSelection(this.selection);
    }

    if (finishedCallback) finishedCallback(this);
  }

  paginate(height) {
    if (!height) return;
    this.pages = [];
    let pageHeightOffset = 0,
      startLineIndex = 0;
    for (let i = 1; i < this.lines.length; ++i) {
      let line = this.lines[i];
      let pageHeight = line.bounds.bottom() - pageHeightOffset - line.origin.y;

      if (pageHeight > height) {
        // this line will be the first on the new page
        this.pages.push(this.copyLines(startLineIndex, i));
        startLineIndex = i;
        pageHeightOffset = line.bounds.y - line.origin.y;
        line.bounds.y = line.origin.y;
      } else {
        // not a new page yet...update the bounds:
        line.bounds.y -= pageHeightOffset;
      }
    }
    this.pages.push(this.copyLines(startLineIndex, this.lines.length));
  }

  draw(ctxt, scale = 1) {
    ctxt.setCanvasSize(this.bounds.width, this.bounds.height, scale);

    var canvasCtxt = ctxt.canvasCtxt;

    canvasCtxt.clearRect(0, 0, ctxt.canvas.width, ctxt.canvas.height);

    canvasCtxt.translate(this.bounds.x, this.bounds.y);

    if (this.titles) this.titles.draw(ctxt);

    for (var i = 0; i < this.lines.length; i++) this.lines[i].draw(ctxt);

    canvasCtxt.translate(-this.bounds.x, -this.bounds.y);
  }

  getSvgProps(ctxt, zoom) {
    let width =
        typeof zoom === \"number\"
          ? zoom * this.bounds.width
          : zoom
          ? undefined
          : this.bounds.width,
      height = zoom ? undefined : this.bounds.height;

    return {
      xmlns: \"http://www.w3.org/2000/svg\",
      version: \"1.1\",
      class: \"Exsurge ChantScore\" + (ctxt.editable ? \" EditableChantScore\" : \"\"),
      width,
      height,
      viewBox: [0, 0, this.bounds.width, this.bounds.height].join(\" \")
    };
  }

  createSvgNode(ctxt) {
    // create defs section
    var node = [ctxt.defsNode.cloneNode(true)];
    node[0].appendChild(ctxt.createStyleNode());

    if (this.titles) node.push(this.titles.createSvgNode(ctxt));

    for (var i = 0; i < this.lines.length; i++)
      node.push(this.lines[i].createSvgNode(ctxt));

    node = QuickSvg.createNode(\"g\", {}, node);

    node = QuickSvg.createNode(\"svg\", this.getSvgProps(ctxt), node);

    node.source = this;
    this.svg = node;

    return node;
  }

  createSvgTree(ctxt, zoom) {
    // create defs section
    var node = [
      QuickSvg.createSvgTree(
        \"defs\",
        {},
        ...ctxt.makeDefs.map((makeDef) => makeDef.makeSvgTree()),
        ctxt.createStyleTree()
      )
    ];

    if (this.titles) node.push(this.titles.createSvgTree(ctxt));

    for (var i = 0; i < this.lines.length; i++)
      node.push(this.lines[i].createSvgTree(ctxt));

    node = QuickSvg.createSvgTree(\"g\", {}, ...node);
    let svgProps = this.getSvgProps(ctxt, zoom);
    svgProps.source = this;
    node = QuickSvg.createSvgTree(\"svg\", svgProps, node);

    return node;
  }

  createSvg(ctxt) {
    var fragment = \"\";

    // create defs section
    for (var def in ctxt.defs)
      if (ctxt.defs.hasOwnProperty(def)) fragment += ctxt.defs[def];
    fragment += ctxt.createStyle();

    fragment = QuickSvg.createFragment(\"defs\", {}, fragment);

    if (this.titles) fragment += this.titles.createSvgFragment(ctxt);

    for (var i = 0; i < this.lines.length; i++)
      fragment += this.lines[i].createSvgFragment(ctxt);

    fragment = QuickSvg.createFragment(\"g\", {}, fragment);

    fragment = QuickSvg.createFragment(\"svg\", this.getSvgProps(ctxt), fragment);

    return fragment;
  }

  createSvgNodeForEachLine(ctxt) {
    var node = [];

    var top = 0;
    for (var i = 0; i < this.lines.length; i++) {
      var lineFragment = [
        ctxt.defsNode.cloneNode(true),
        this.lines[i].createSvgNode(ctxt, top)
      ];
      lineFragment[0].appendChild(ctxt.createStyleNode());
      var height = this.lines[i].bounds.height + ctxt.staffInterval * 1.5;
      lineFragment = QuickSvg.createNode(\"g\", {}, lineFragment);
      lineFragment = QuickSvg.createNode(
        \"svg\",
        {
          xmlns: \"http://www.w3.org/2000/svg\",
          version: \"1.1\",
          class: \"Exsurge ChantScore\",
          width: this.bounds.width,
          height: height,
          viewBox: [0, 0, this.bounds.width, height].join(\" \")
        },
        lineFragment
      );
      node.push(lineFragment);
      top += height;
    }
    return node;
  }

  createSvgForEachLine(ctxt) {
    var fragment = \"\",
      fragmentDefs = \"\";

    // create defs section
    for (var def in ctxt.defs)
      if (ctxt.defs.hasOwnProperty(def)) fragmentDefs += ctxt.defs[def];
    fragmentDefs += ctxt.createStyle();

    fragmentDefs = QuickSvg.createFragment(\"defs\", {}, fragmentDefs);
    var top = 0;
    for (var i = 0; i < this.lines.length; i++) {
      var lineFragment =
        fragmentDefs + this.lines[i].createSvgFragment(ctxt, top);
      var height = this.lines[i].bounds.height + ctxt.staffInterval * 1.5;
      lineFragment = QuickSvg.createFragment(\"g\", {}, lineFragment);
      lineFragment = QuickSvg.createFragment(
        \"svg\",
        {
          xmlns: \"http://www.w3.org/2000/svg\",
          version: \"1.1\",
          \"xmlns:xlink\": \"http://www.w3.org/1999/xlink\",
          class: \"Exsurge ChantScore\",
          width: this.bounds.width,
          height: height
        },
        lineFragment
      );
      fragment += lineFragment;
      top += height;
    }
    return fragment;
  }

  unserializeFromJson(data, ctxt) {
    this.autoColoring = data[\"auto-coloring\"];

    if (data.annotation !== null && data.annotation !== \"\") {
      // create the annotation
      this.annotation = new Annotation(ctxt, data.annotation);
    } else this.annotation = null;

    var createDropCap = data[\"drop-cap\"] === \"auto\" ? true : false;

    Gabc.parseChantNotations(data.notations, this, createDropCap);
  }

  serializeToJson() {
    var data = {};

    data[\"type\"] = \"score\";
    data[\"auto-coloring\"] = true;

    if (this.annotation !== null)
      data.annotation = this.annotation.unsanitizedText;
    else data.annotation = \"\";

    return data;
  }
}

export class ChantDocument {
  constructor() {
    var defaults = {
      layout: {
        units: \"mm\",
        \"default-font\": {
          \"font-family\": \"Crimson\",
          \"font-size\": 14
        },
        page: {
          width: 8.5,
          height: 11,
          \"margin-left\": 0,
          \"margin-top\": 0,
          \"margin-right\": 0,
          \"margin-bottom\": 0
        }
      },
      scores: []
    };

    // default layout
    this.copyLayout(this, defaults);

    this.scores = defaults.scores;
  }

  copyLayout(to, from) {
    to.layout = {
      units: from.layout.units,
      \"default-font\": {
        \"font-family\": from.layout[\"default-font\"][\"font-family\"],
        \"font-size\": from.layout[\"default-font\"][\"font-size\"]
      },
      page: {
        width: from.layout.page.width,
        height: from.layout.page.height,
        \"margin-left\": from.layout.page[\"margin-left\"],
        \"margin-top\": from.layout.page[\"margin-top\"],
        \"margin-right\": from.layout.page[\"margin-right\"],
        \"margin-bottom\": from.layout.page[\"margin-bottom\"]
      }
    };
  }

  unserializeFromJson(data) {
    this.copyLayout(this, data);

    this.scores = [];

    // read in the scores
    for (var i = 0; i < data.scores.length; i++) {
      var score = new ChantScore();

      score.unserializeFromJson(data.scores[i]);
      this.scores.push(score);
    }
  }

  serializeToJson() {
    var data = {};

    this.copyLayout(data, this);

    data.scores = [];

    // save scores...
    for (var i = 0; i < this.scores.length; i++)
      data.scores.push(this.scores[i].serializeToJson());

    return data;
  }
}



// WEBPACK FOOTER //
// ./src/Exsurge.Chant.js","//
// Author(s):
// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
//
// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the \"Software\"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

import { ChantLineBreak, NoteShape, TextOnly } from \"./Exsurge.Chant.js\";
import {
  BraceAttachment, BracePoint, BraceShape, HorizontalEpisemaAlignment
} from \"./Exsurge.Chant.Markings.js\";
import {
  Custos,
  DoubleBar,
  FullBar
} from \"./Exsurge.Chant.Signs.js\";
import { Point, Rect } from \"./Exsurge.Core.js\";
import {
  ChantLayoutElement, CurlyBraceVisualizer, GlyphCode, Lyric,
  LyricArray,
  LyricType, MarkingPositionHint, QuickSvg, RoundBraceVisualizer
} from \"./Exsurge.Drawing.js\";
import { Glyphs } from \"./Exsurge.Glyphs.js\";

// a chant line represents one staff line on the page. ChantLines are created by the score
// and laid out by the page
export class ChantLine extends ChantLayoutElement {
  constructor(score) {
    super();

    this.score = score;

    this.notationsStartIndex = 0;
    this.numNotationsOnLine = 0;
    this.notationBounds = null; // Rect

    this.staffLeft = 0;
    this.staffRight = 0;

    this.startingClef = null; // necessary for the layout process
    this.custos = null;

    this.justify = true;

    // these are markings that exist at the chant line level rather than at the neume level.
    this.ledgerLines = [];
    this.braces = [];

    this.nextLine = null;
    this.previousLine = null; // for layout assistance

    this.lyricLineHeight = 0; // height of each text line
    this.lyricLineBaseline = 0; // offsets from the top of the text line to the baseline
    this.numLyricLines = 0; // maximum count of lyrics on the same syllable

    // fixme: make these configurable values from the score
    this.spaceAfterNotations = 0; // the space between the notation bounds and the first text track
    this.spaceBetweenTextTracks = 0; // spacing between each text track

    this.lastLyrics = [];
  }

  performLayout(ctxt) {
    // start off with a rectangle that holds at least the four staff lines
    this.notationBounds = new Rect(
      this.staffLeft,
      -(ctxt.staffLineWeight / 2 + 3 + ctxt.minSpaceAboveStaff) *
        ctxt.staffInterval,
      this.staffRight - this.staffLeft,
      (ctxt.staffLineWeight + 6 + ctxt.minSpaceAboveStaff) * ctxt.staffInterval
    );

    // run through all the elements of the line and calculate the bounds of the notations,
    // as well as the bounds of each text track we will use
    var i;
    var notations = this.score.notations;
    var lastNeumeIndex =
      this.extraTextOnlyIndex === null
        ? this.notationsStartIndex + this.numNotationsOnLine
        : this.extraTextOnlyIndex;
    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;
    var notation = null;

    this.notationBounds.union(this.startingClef.bounds);

    // reset the lyric line offsets before we [re]calculate them now
    this.lyricLineHeight = ctxt.textStyles.lyric.size * 1.1;
    this.lyricLineBaseline = 0;
    this.numLyricLines = 0;

    this.altLineHeight = 0;
    this.altLineBaseline = 0;
    this.numAltLines = 0;

    this.translationLineHeight = ctxt.textStyles.translation.size * 1.1;
    this.translationLineBaseline = 0;
    this.numTranslationLines = 0;

    for (i = this.notationsStartIndex; i < lastNeumeIndex; i++) {
      notation = notations[i];

      this.notationBounds.union(notation.bounds);

      // keep track of lyric line offsets
      if (notation.lyrics.length && notation.lyrics[0].text) {
        // if (notation.lyrics[0].bounds.height > this.lyricLineHeight)
        //   this.lyricLineHeight = notation.lyrics[0].bounds.height;
        if (notation.lyrics[0].origin.y > this.lyricLineBaseline)
          this.lyricLineBaseline = notation.lyrics[0].origin.y;
        if (notation.lyrics.length > this.numLyricLines)
          this.numLyricLines = notation.lyrics.length;
      }

      if (notation.alText && this.numAltLines < notation.alText.length) {
        if (notation.alText[0].bounds.height > this.altLineHeight)
          this.altLineHeight = notation.alText[0].bounds.height;
        if (notation.alText[0].origin.y > this.altLineBaseline)
          this.altLineBaseline = notation.alText[0].origin.y;
        if (notation.alText.length > this.numAltLines)
          this.numAltLines = notation.alText.length;
      }

      if (
        notation.translationText &&
        notation.translationText[0] &&
        notation.translationText[0].text
      ) {
        // if (
        //   notation.translationText[0].bounds.height > this.translationLineHeight
        // )
        //   this.translationLineHeight =
        //     notation.translationText[0].bounds.height;
        if (notation.translationText[0].origin.y > this.translationLineBaseline)
          this.translationLineBaseline = notation.translationText[0].origin.y;
        if (notation.translationText.length > this.numTranslationLines)
          this.numTranslationLines = notation.translationText.length;
      }
    }

    if (this.custos) this.notationBounds.union(this.custos.bounds);

    // add any braces to the notationBounds as well
    for (i = 0; i < this.braces.length; i++)
      this.notationBounds.union(this.braces[i].bounds);

    // finalize the lyrics placement
    var notationBoundsOffset =
      this.notationBounds.bottom() +
      ctxt.minSpaceBelowStaff * ctxt.staffInterval;
    this.lyricLineBaseline += notationBoundsOffset;
    this.translationLineBaseline += notationBoundsOffset;
    this.altLineBaseline +=
      this.notationBounds.y - this.altLineHeight - ctxt.staffInterval * 0.5;

    for (i = this.notationsStartIndex; i < lastNeumeIndex; i++) {
      notation = notations[i];
      var offset = 0;
      for (var j = 0; j < notation.lyrics.length; j++) {
        notation.lyrics[j].bounds.y = offset + this.lyricLineBaseline;
        offset += this.lyricLineHeight;
      }

      if (notation.translationText) {
        for (j = 0; j < notation.translationText.length; j++) {
          notation.translationText[j].bounds.y =
            offset + this.translationLineBaseline;
          offset += this.translationLineHeight;
        }
      }

      if (notation.alText) {
        offset = 0;
        for (j = 0; j < notation.alText.length; j++) {
          notation.alText[j].bounds.y = offset + this.altLineBaseline;
          offset -= ctxt.textStyles.al.size * 1.1;
        }
      }
    }

    this.extraTextOnlyHeight = 0;
    // handle placement of extra TextOnly elements:
    if (ctxt.useExtraTextOnly) {
      var extraTextOnlyLyricIndex = this.extraTextOnlyLyricIndex;
      if (this.extraTextOnlyIndex === null) {
        // even if extraTextOnlyIndex is null, there might be extra lines on the last lyric if it is TextOnly:
        let lastNotation = notations[lastNeumeIndex - 1] || {};
        if (lastNotation.constructor === ChantLineBreak)
          lastNotation = notations[lastNeumeIndex - 2];
        if (
          lastNotation.constructor === TextOnly &&
          lastNotation.lyrics.length === 1 &&
          lastNotation.lyrics[0].bounds.height > this.lyricLineHeight
        ) {
          this.extraTextOnlyHeight = this.lyricLineHeight;
        }
      } else {
        let lastLyrics = null;
        let xOffset = 0;
        offset = (this.numLyricLines - 1) * this.lyricLineHeight;
        offset += this.numTranslationLines * this.translationLineHeight;
        let extraLines = 0;
        for (i = this.extraTextOnlyIndex; i < lastIndex; i++) {
          notation = notations[i];
          if (!notation.lyrics[extraTextOnlyLyricIndex]) continue;
          lastLyrics = notation.lyrics[extraTextOnlyLyricIndex];
          if (lastLyrics.lineWidth) {
            xOffset = this.staffRight - lastLyrics.lineWidth;
            offset += this.lyricLineHeight;
            extraLines++;
          }
          extraLines += lastLyrics.numLines - 1;
          lastLyrics.bounds.y = offset + this.lyricLineBaseline;
          notation.bounds.x += xOffset;
        }
        this.extraTextOnlyHeight = this.lyricLineHeight * extraLines;
      }
    }

    if (this.startingClef.hasLyrics()) {
      offset = 0;
      for (j = 0; j < this.startingClef.lyrics.length; j++) {
        this.startingClef.lyrics[j].bounds.y = offset + this.lyricLineBaseline;
        offset += this.lyricLineHeight;
      }
    }

    // dropCap and the annotations
    if (this.notationsStartIndex === 0) {
      if (this.score.annotation !== null) {
        // annotations use dominant-baseline to align text to the top
        this.score.annotation.bounds.x = this.staffLeft / 2;
        this.score.annotation.bounds.y = -ctxt.staffInterval * 3;
        if (this.score.dropCap !== null) {
          var lowestPossibleAnnotationY =
            this.lyricLineBaseline -
            this.score.annotation.bounds.height -
            ctxt.staffInterval * ctxt.textStyles.annotation.padding -
            this.score.dropCap.origin.y;
          // if the annotation would overlap with the drop cap, move the annotation higher.
          // otherwise, center the annotation in the vertical space between the top of the drop cap and the top of the staff.
          if (lowestPossibleAnnotationY < this.score.annotation.bounds.y) {
            this.score.annotation.bounds.y = lowestPossibleAnnotationY;
          } else {
            this.score.annotation.bounds.y =
              (this.score.annotation.bounds.y + lowestPossibleAnnotationY) / 2;
          }
          if (this.score.annotation.bounds.y < this.notationBounds.y) {
            this.notationBounds.y = this.score.annotation.bounds.y;
            this.notationBounds.height +=
              this.notationBounds.y - this.score.annotation.bounds.y;
          }
        }
        this.score.annotation.bounds.y += this.score.annotation.origin.y;
      }

      if (this.score.dropCap !== null) {
        // drop caps and annotations are drawn from their center, so aligning them
        // horizontally is as easy as this.staffLeft / 2
        this.score.dropCap.bounds.x = this.staffLeft / 2;
        this.score.dropCap.bounds.y =
          this.lyricLineBaseline - this.score.dropCap.origin.y;
        this.notationBounds.union(this.score.dropCap.bounds);
        this.score.dropCap.bounds.y = this.lyricLineBaseline;
      }
    }

    if (this.numLyricLines > 0) {
      // add up the lyric line heights to get the total height of the chant line
      var lyricAndTextRect = new Rect(
        0,
        notationBoundsOffset,
        0,
        this.lyricLineHeight * this.numLyricLines +
          this.extraTextOnlyHeight +
          this.translationLineHeight * this.numTranslationLines
      );
      this.notationBounds.union(lyricAndTextRect);
    }
    if (this.numAltLines > 0) {
      var altLineTextRect = new Rect(
        0,
        this.notationBounds.y -
          this.altLineHeight -
          0.5 * ctxt.staffInterval -
          ctxt.textStyles.al.size * 1.1 * (this.numAltLines - 1),
        0,
        ctxt.textStyles.al.size * 1.1 * this.numAltLines
      );
      this.notationBounds.union(altLineTextRect);
    }
    // Ensure that there is at least minSpaceBelowStaff below the lowest staff line:
    this.notationBounds.union(
      new Rect(
        0,
        0,
        0,
        (3 + ctxt.staffLineWeight / 2 + ctxt.minSpaceBelowStaff) *
          ctxt.staffInterval
      )
    );
    var totalHeight = this.notationBounds.height;

    this.bounds.x = 0;
    this.bounds.y = this.notationBounds.y;
    this.bounds.width = this.notationBounds.right();
    this.bounds.height = totalHeight;

    // the origin of the chant line's coordinate space is at the center line of the left extremity of the staff
    this.origin = new Point(this.staffLeft, -this.notationBounds.y);
  }

  // TODO: remove if not necsessary
  layoutInsertionCursor(ctxt) {
    if (this.insertionCursor) {
      // we have either a Notation to draw the cursor after, or the ChantLine itself when the cursor is the first thing on the line
      this.insertionCursor.performLayout(ctxt);
      this.insertionCursor.bounds.x =
        this.score.insertionElement.bounds.right() +
        ((this.score.insertionElement.trailingSpace &&
          this.score.insertionElement.calculatedTrailingSpace) ||
          0) /
          2 -
        this.insertionCursor.origin.x;
    }
    return this.insertionCursor;
  }

  draw(ctxt) {
    var canvasCtxt = ctxt.canvasCtxt;

    canvasCtxt.translate(this.bounds.x, this.bounds.y);

    // draw the staff lines
    var i,
      x1 = this.staffLeft,
      x2 = this.staffRight,
      y;
    canvasCtxt.lineWidth = ctxt.staffLineWeight;
    canvasCtxt.strokeStyle = ctxt.staffLineColor;

    for (i = -3; i <= 3; i += 2) {
      y = ctxt.staffInterval * i;

      canvasCtxt.beginPath();
      canvasCtxt.moveTo(x1, y);
      canvasCtxt.lineTo(x2, y);
      canvasCtxt.stroke();
    }

    if (this.layoutInsertionCursor(ctxt)) {
      this.insertionCursor.draw(ctxt);
    }

    // draw the ledger lines
    for (i = 0; i < this.ledgerLines.length; i++) {
      var ledgerLine = this.ledgerLines[i];
      y = ctxt.calculateHeightFromStaffPosition(ledgerLine.staffPosition);

      canvasCtxt.beginPath();
      canvasCtxt.moveTo(ledgerLine.x1, y);
      canvasCtxt.lineTo(ledgerLine.x2, y);
      canvasCtxt.stroke();
    }

    // fixme: draw the braces

    // draw the dropCap and the annotations
    if (this.notationsStartIndex === 0) {
      if (this.score.dropCap !== null) this.score.dropCap.draw(ctxt);

      if (
        this.score.annotation !== null &&
        (!this.score.mergeAnnotationWithTextLeft || this.score.dropCap)
      )
        // only draw it if there is a dropCap or there is no mergeAnnotationWithTextLeft
        this.score.annotation.draw(ctxt);
    }

    // draw the notations
    var notations = this.score.notations;
    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;

    for (i = this.notationsStartIndex; i < lastIndex; i++)
      notations[i].draw(ctxt);

    this.startingClef.draw(ctxt);

    if (this.custos) this.custos.draw(ctxt);

    canvasCtxt.translate(-this.bounds.x, -this.bounds.y);
  }

  getInnerNodes(
    ctxt,
    top = 0,
    functionNames = { quickSvg: \"createNode\", elements: \"createSvgNode\" }
  ) {
    var inner = [];

    // add the chant lines
    var i,
      x1 = this.staffLeft,
      x2 = this.staffRight;

    if (ctxt.editable) {
      inner.push(
        QuickSvg[functionNames.quickSvg](\"rect\", {
          key: \"insertion\",
          x: x1,
          y: ctxt.staffInterval * -3,
          width: x2 - x1,
          height: ctxt.staffInterval * 6,
          fill: \"none\"
        })
      );
    }

    // create the staff lines
    for (i = -3; i <= 3; i += 2) {
      inner.push(
        QuickSvg[functionNames.quickSvg](\"line\", {
          key: i,
          x1: x1,
          y1: ctxt.staffInterval * i,
          x2: x2,
          y2: ctxt.staffInterval * i,
          stroke: ctxt.staffLineColor,
          \"stroke-width\": ctxt.staffLineWeight,
          class: \"staffLine\"
        })
      );
    }

    inner = [
      QuickSvg[functionNames.quickSvg](\"g\", { class: \"staffLines\" }, inner)
    ];

    if (this.layoutInsertionCursor(ctxt)) {
      inner.push(this.insertionCursor[functionNames.elements](ctxt));
    }

    // create the ledger lines
    for (i = 0; i < this.ledgerLines.length; i++) {
      var ledgerLine = this.ledgerLines[i];
      var y = ctxt.calculateHeightFromStaffPosition(ledgerLine.staffPosition);

      inner.push(
        QuickSvg[functionNames.quickSvg](\"line\", {
          x1: ledgerLine.x1,
          y1: y,
          x2: ledgerLine.x2,
          y2: y,
          stroke: ctxt.staffLineColor,
          \"stroke-width\": ctxt.staffLineWeight,
          class: \"ledgerLine\"
        })
      );
    }

    // add any braces
    for (i = 0; i < this.braces.length; i++)
      inner.push(this.braces[i][functionNames.elements](ctxt));

    // dropCap and the annotations
    if (this.notationsStartIndex === 0) {
      if (this.score.dropCap !== null)
        inner.push(this.score.dropCap[functionNames.elements](ctxt));

      if (
        this.score.annotation !== null &&
        (!this.score.mergeAnnotationWithTextLeft || this.score.dropCap)
      )
        // only draw it if there is a dropCap or there is no mergeAnnotationWithTextLeft
        inner = inner.concat(
          this.score.annotation[functionNames.elements](ctxt)
        );
    }

    inner.push(this.startingClef[functionNames.elements](ctxt));

    var notations = this.score.notations;
    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;

    // add all of the notations
    for (i = this.notationsStartIndex; i < lastIndex; i++)
      inner.push(notations[i][functionNames.elements](ctxt));

    if (this.custos) inner.push(this.custos[functionNames.elements](ctxt));
    return inner;
  }

  createSvgNode(ctxt, top = 0) {
    let inner = this.getInnerNodes(ctxt, top, {
      quickSvg: \"createNode\",
      elements: \"createSvgNode\"
    });

    return QuickSvg.createNode(
      \"g\",
      {
        class: \"chantLine\",
        transform:
          \"translate(\" + this.bounds.x + \",\" + (this.bounds.y - top) + \")\",
        \"element-index\": this.elementIndex,
        source: this
      },
      inner
    );
  }

  createSvgTree(ctxt, top = 0) {
    let inner = this.getInnerNodes(ctxt, top, {
      quickSvg: \"createSvgTree\",
      elements: \"createSvgTree\"
    });

    return QuickSvg.createSvgTree(
      \"g\",
      {
        class: \"chantLine\",
        transform:
          \"translate(\" + this.bounds.x + \",\" + (this.bounds.y - top) + \")\",
        \"element-index\": this.elementIndex
      },
      ...inner
    );
  }

  createSvgFragment(ctxt, top = 0) {
    var inner = \"\";

    // add the chant lines
    var i,
      x1 = this.staffLeft,
      x2 = this.staffRight;

    // create the staff lines
    for (i = -3; i <= 3; i += 2) {
      inner += QuickSvg.createFragment(\"line\", {
        x1: x1,
        y1: ctxt.staffInterval * i,
        x2: x2,
        y2: ctxt.staffInterval * i,
        stroke: ctxt.staffLineColor,
        \"stroke-width\": ctxt.staffLineWeight,
        class: \"staffLine\"
      });
    }

    inner = QuickSvg.createFragment(\"g\", { class: \"staffLines\" }, inner);

    if (this.layoutInsertionCursor(ctxt)) {
      inner += this.insertionCursor.createSvgFragment(ctxt);
    }

    // create the ledger lines
    for (i = 0; i < this.ledgerLines.length; i++) {
      var ledgerLine = this.ledgerLines[i];
      var y = ctxt.calculateHeightFromStaffPosition(ledgerLine.staffPosition);

      inner += QuickSvg.createFragment(\"line\", {
        x1: ledgerLine.x1,
        y1: y,
        x2: ledgerLine.x2,
        y2: y,
        stroke: ctxt.staffLineColor,
        \"stroke-width\": ctxt.staffLineWeight,
        class: \"ledgerLine\"
      });
    }

    // add any braces
    for (i = 0; i < this.braces.length; i++)
      inner += this.braces[i].createSvgFragment(ctxt);

    // dropCap and the annotations
    if (this.notationsStartIndex === 0) {
      if (this.score.dropCap !== null)
        inner += this.score.dropCap.createSvgFragment(ctxt);

      if (
        this.score.annotation !== null &&
        (!this.score.mergeAnnotationWithTextLeft || this.score.dropCap)
      )
        // only draw it if there is a dropCap or there is no mergeAnnotationWithTextLeft
        inner += this.score.annotation.createSvgFragment(ctxt);
    }

    inner += this.startingClef.createSvgFragment(ctxt);

    var notations = this.score.notations;
    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;

    // add all of the notations
    for (i = this.notationsStartIndex; i < lastIndex; i++)
      inner += notations[i].createSvgFragment(ctxt);

    if (this.custos) inner += this.custos.createSvgFragment(ctxt);

    return QuickSvg.createFragment(
      \"g\",
      {
        class: \"chantLine\",
        transform:
          \"translate(\" + this.bounds.x + \",\" + (this.bounds.y - top) + \")\",
        \"element-index\": this.elementIndex
      },
      inner
    );
  }

  // code below based on code by: https://gist.github.com/alexhornbake
  //
  // optimized for braces that are only drawn horizontally.
  // returns svg path string ready to insert into svg doc
  generateCurlyBraceDrawable(ctxt, x1, x2, y, isAbove) {
    var h;

    if (isAbove) h = -ctxt.staffInterval / 2;
    else h = ctxt.staffInterval / 2;

    // and q factor, .5 is normal, higher q = more expressive bracket
    var q = 0.6;

    var len = x2 - x1;

    //Calculate Control Points of path,
    var qx1 = x1;
    var qy1 = y + q * h;
    var qx2 = x1 + 0.25 * len;
    var qy2 = y + (1 - q) * h;
    var tx1 = x1 + 0.5 * len;
    var ty1 = y + h;
    var qx3 = x2;
    var qy3 = y + q * h;
    var qx4 = x1 + 0.75 * len;
    var qy4 = y + (1 - q) * h;
    var d =
      \"M \" +
      x1 +
      \" \" +
      y +
      \" Q \" +
      qx1 +
      \" \" +
      qy1 +
      \" \" +
      qx2 +
      \" \" +
      qy2 +
      \" T \" +
      tx1 +
      \" \" +
      ty1 +
      \" M \" +
      x2 +
      \" \" +
      y +
      \" Q \" +
      qx3 +
      \" \" +
      qy3 +
      \" \" +
      qx4 +
      \" \" +
      qy4 +
      \" T \" +
      tx1 +
      \" \" +
      ty1;

    return QuickSvg.createFragment(\"path\", {
      d: d,
      stroke: ctxt.neumeLineColor,
      \"stroke-width\": ctxt.neumeLineWeight + \"px\",
      fill: \"none\"
    });
  }

  buildFromChantNotationIndex(ctxt, newElementStart, width) {
    // todo: reset / clear the children we have in case they have data
    var notations = this.score.notations,
      beginningLyrics = null,
      prev = null,
      prevNeume = null,
      prevLyrics = [];
    var condensableSpaces = [];
    this.notationsStartIndex = newElementStart;
    this.numNotationsOnLine = 0;

    this.staffLeft = 0;
    this.paddingLeft = 0;

    this.extraTextOnlyIndex = null;
    this.extraTextOnlyLyricIndex = 0;

    if (width > 0) this.staffRight = width;
    else this.staffRight = Infinity; // no limit to staff size

    // If this is the first chant line, then we have to make room for a
    // drop cap and/or annotation, if present
    if (this.notationsStartIndex === 0) {
      var padding = 0;

      if (this.score.dropCap !== null)
        padding =
          this.score.dropCap.bounds.width + this.score.dropCap.padding * 2;

      if (
        this.score.annotation !== null &&
        (!this.score.mergeAnnotationWithTextLeft || this.score.dropCap)
      )
        padding = Math.max(
          padding,
          this.score.annotation.bounds.width + this.score.annotation.padding * 2
        );

      this.staffLeft += padding;
      if (this.score.dropCap !== null)
        this.paddingLeft = (padding - this.score.dropCap.bounds.width) / 2;
    } else {
      prev = notations[newElementStart - 1];
      if (
        prev.constructor === DoubleBar &&
        prev.hasLyrics() &&
        (prev.lyrics.length > 1 || !prev.lyrics[0].text.match(/^(i\\.?)+j\\.?/))
      ) {
        beginningLyrics = prev.lyrics.map(function(lyric) {
          var newLyric = new Lyric(
            ctxt,
            lyric.originalText,
            lyric.lyricType,
            lyric.notation,
            lyric.notations,
            lyric.sourceIndex
          );
          newLyric.elidesToNext = lyric.elidesToNext;
          // Hide the original lyric by setting its bounds.y to an extremely high number.
          // If the chant is re-laid out, this value will be recalculated so that it won't stay hidden.
          lyric.bounds.y = Number.MAX_SAFE_INTEGER;
          return newLyric;
        });
        var minX = beginningLyrics
          .map(function(l) {
            return l.bounds.x;
          })
          .reduce(function(a, b) {
            return a < b ? a : b;
          });
        beginningLyrics.forEach(function(l) {
          l.bounds.x -= minX;
        });
      }
    }

    // set up the clef...
    // if the first notation on the line is a starting clef, then we treat it a little differently...
    // the clef becomes this line's starting clef and we skip over the clef in the notations array
    if (notations.length && notations[newElementStart].isClef) {
      ctxt.activeClef = notations[newElementStart];
      newElementStart++;
      this.notationsStartIndex++;
    }

    // make a copy for this line to use at the beginning
    this.startingClef = ctxt.activeClef.clone();
    this.startingClef.performLayout(ctxt);
    this.startingClef.bounds.x = this.staffLeft;

    var curr = this.startingClef;

    if (beginningLyrics) {
      LyricArray.setNotation(beginningLyrics, curr);
    }

    // estimate how much space we have available to us
    var rightNotationBoundary =
      this.staffRight - Glyphs.CustosLong.bounds.width * ctxt.glyphScaling; // possible custos on the line
    var lastTranslationTextWithEndNeume = null;

    // iterate through the notations, fittng what we can on this line
    var i,
      j,
      lastNotationIndex = notations.length - 1;

    if (curr.hasLyrics()) LyricArray.mergeIn(this.lastLyrics, curr.lyrics);

    // if we already have a start brace on the context, we must be continuing it from the previous system.
    if (ctxt.lastStartBrace && !ctxt.lastStartBrace.note) {
      ctxt.lastStartBrace.note = this.startingClef;
    }
    var lastLyricsBeforeTextOnly;
    var textOnlyStartIndex;

    for (i = newElementStart; i <= lastNotationIndex; i++) {
      prev = curr;
      if (curr.constructor !== TextOnly) prevNeume = curr;

      curr = notations[i];

      var actualRightBoundary;
      if (
        i === lastNotationIndex ||
        curr.constructor === Custos ||
        (prev.constructor === Custos && curr.isDivider) ||
        (curr.constructor === ChantLineBreak &&
          prevNeume.constructor === Custos)
      ) {
        // on the last notation of the score, we don't need a custos or trailing space, so we use staffRight as the
        // right boundary.
        // Also, if the current notation is a divider and the previous was a custos, we don't need extra space
        // because if the following notation won't fit, we can switch the order and use the custos as the end-of-the-line custos
        // Ditto in the case of the current element being a chant line break and the previous neume a custos, because that custos will become our end-of-line custos
        actualRightBoundary = this.staffRight;
      } else if (i === lastNotationIndex - 1) {
        // on the penultimate notation, make sure there is at least enough room for whichever takes up less space,
        // between the final notation and a custos:
        actualRightBoundary = Math.max(
          rightNotationBoundary,
          this.staffRight - notations[lastNotationIndex].bounds.width
        );
      } else {
        // Otherwise, we use rightNotationBoundary, which leaves room for a custos...
        actualRightBoundary = rightNotationBoundary;
      }

      // First check if we're already beyond the rightNotationBoundary (due to condensing that hasn't yet happened) and have a good element to end with
      // but if we have 2 or fewer elements, or if the current element is a line break or a custos, we'll go ahead and try for them anyway.
      var forceBreak =
        !curr.isDivider &&
        curr.constructor !== ChantLineBreak &&
        curr.constructor !== Custos &&
        !(
          curr.constructor === TextOnly &&
          curr.hasLyrics() &&
          /^(?:[*†]|i+j\\.?)$/.test(curr.lyrics[0].text)
        ) &&
        lastNotationIndex - i > 1 &&
        !prevNeume.keepWithNext &&
        prevNeume.bounds.right() >= rightNotationBoundary;

      // also force a break if we've run into extra TextOnly elements, but the current notation is not a TextOnly and has lyrics
      forceBreak =
        forceBreak ||
        (this.extraTextOnlyIndex !== null &&
          curr.constructor !== TextOnly &&
          curr.constructor !== ChantLineBreak &&
          curr.constructor !== Custos &&
          curr.hasLyrics());

      if (curr instanceof TextOnly && prev === prevNeume) {
        lastLyricsBeforeTextOnly = this.lastLyrics.slice();
        textOnlyStartIndex = i;
      }
      if (
        curr instanceof TextOnly &&
        notations[textOnlyStartIndex] &&
        !notations[textOnlyStartIndex].hasLyrics()
      ) {
        // we want textOnlyStartIndex to be the first TextOnly that actually has lyrics,
        // so if the current \"textOnlyStart\" element does not have lyrics, and we have another textOnly
        // that does have lyrics, we will use it instead
        textOnlyStartIndex = i;
      }

      if (curr.hasLyrics() && curr.lyrics[0].needsLayout) {
        curr.lyrics[0].recalculateMetrics(ctxt);
      }

      // try to fit the curr element on this line.
      // if it doesn't fit, we finish up here.
      var fitsOnLine =
        !forceBreak &&
        this.positionNotationElement(
          ctxt,
          this.lastLyrics,
          prevNeume,
          curr,
          actualRightBoundary,
          this.extraTextOnlyIndex ? [] : condensableSpaces // no spaces are condensable once we are on extra text only lyrics
        );
      var candidateForExtraTextOnlyLine =
        ctxt.useExtraTextOnly &&
        curr.constructor === TextOnly &&
        LyricArray.hasOnlyOneLyric(curr.lyrics) &&
        (fitsOnLine === false || this.extraTextOnlyIndex !== null);
      var extraTextOnlyLyricIndex;
      if (candidateForExtraTextOnlyLine && this.extraTextOnlyIndex === null) {
        // check to make sure there is enough text to put on the text only line:
        extraTextOnlyLyricIndex = LyricArray.indexOfLyric(curr.lyrics);
        if (textOnlyStartIndex === i) {
          var currentLyric = notations[i].lyrics[extraTextOnlyLyricIndex].text;
          if (currentLyric.length <= 1) {
            var nextNotation = notations[i + 1];
            candidateForExtraTextOnlyLine =
              nextNotation &&
              nextNotation.constructor === TextOnly &&
              nextNotation.lyrics[extraTextOnlyLyricIndex] &&
              nextNotation.lyrics[extraTextOnlyLyricIndex].text.length > 0;
          }
        }
      }
      if (candidateForExtraTextOnlyLine) {
        // a special case for TextOnly elements that don't fit on the line: since they don't have neumes associated with them, we can place this
        // and any additional TextOnly elements just below the current lyric lines, but we can only do this if the TextOnly elements have only one
        // line of lyrics associated with them.
        var firstOnLine;
        extraTextOnlyLyricIndex = this.extraTextOnlyLyricIndex;
        if (
          this.extraTextOnlyIndex === null &&
          notations[textOnlyStartIndex].lyrics.length
        ) {
          if (
            textOnlyStartIndex === this.notationsStartIndex ||
            !ctxt.startExtraTextOnlyFromFirst
          ) {
            textOnlyStartIndex = i;
            let lastNotationWithLyrics = notations
              .slice(this.notationsStartIndex, i)
              .reverse()
              .find(notation => notation.hasLyrics());
            lastLyricsBeforeTextOnly =
              (lastNotationWithLyrics &&
                lastNotationWithLyrics.lyrics.slice()) ||
              [];
          }
          // go back to the first in this string of consecutive TextOnly elements.
          this.extraTextOnlyIndex = textOnlyStartIndex;
          extraTextOnlyLyricIndex = this.extraTextOnlyLyricIndex = LyricArray.indexOfLyric(
            curr.lyrics
          );
          this.lastLyricsBeforeTextOnly = lastLyricsBeforeTextOnly;
          this.lastLyrics = [];
          i = textOnlyStartIndex - 1;
          this.numNotationsOnLine =
            textOnlyStartIndex - this.notationsStartIndex;
          continue;
        }
        delete curr.lyrics[extraTextOnlyLyricIndex].lineWidth;
        if (!fitsOnLine || i === this.extraTextOnlyIndex) {
          curr.bounds.x = curr.lyrics[extraTextOnlyLyricIndex].origin.x;
          let lastLyricRight = ctxt.startExtraTextOnlyFromFirst
            ? LyricArray.getRight(this.lastLyrics) +
              (ctxt.minLyricWordSpacing || 0)
            : 0;
          curr.lyrics[extraTextOnlyLyricIndex].setMaxWidth(
            ctxt,
            this.staffRight,
            this.staffRight - lastLyricRight
          );
          firstOnLine = curr;
        }
        if (firstOnLine)
          firstOnLine.lyrics[extraTextOnlyLyricIndex].lineWidth = curr.lyrics[
            extraTextOnlyLyricIndex
          ].getRight();
      } else if (fitsOnLine === false) {
        const isTextOnlyBeforeDivider = (i) => {
          const curr = notations[i];
          if (curr.constructor !== TextOnly) return false;
          const firstDivider = notations.slice(i + 1).findIndex(notation => notation.isDivider);
          if (firstDivider < 0) return false;
          return notations.slice(i + 1, i + 1 + firstDivider).every(notation => notation.constructor === TextOnly);
        }
        // first check for elements that cannot begin a system: dividers and custodes
        while (
          this.numNotationsOnLine > 1 &&
          (curr.isDivider || curr.constructor === Custos || isTextOnlyBeforeDivider(i))
        ) {
          curr = notations[--i];
          this.numNotationsOnLine--;
          if (this.lastLyricsBeforeTextOnly && isTextOnlyBeforeDivider(i)) {
            delete this.lastLyricsBeforeTextOnly;
          }
        }

        if (lastTranslationTextWithEndNeume) {
          // console.info(notations[i - 1], lastTranslationTextWithEndNeume);
          // TODO?: need to go back to before the last translation text start:
        }

        // count syllables and notes
        const notationsAfterBreak = notations.slice(i + 1);
        let countSyllables = 0;
        let countNotes = 0;
        if (ctxt.minSyllablesLastLine && ctxt.minNotesLastLine) {
          countSyllables = notationsAfterBreak.filter(notation => notation.hasLyrics()).length;
          countNotes = notationsAfterBreak.flatMap(notation => notation.notes).filter(note => !!note).length;
        }

        // check if the prev elements want to be kept with this one
        for (j = i - 1; j > this.notationsStartIndex; j--) {
          var cne = notations[j];
          curr = notations[j + 1];

          // curr is the first notation on the next line
          // cne is the last notation on this line
          if (ctxt.minSyllablesLastLine && ctxt.minNotesLastLine) {
            countSyllables += curr.hasLyrics() ? 1 : 0;
            countNotes += (curr.notes || []).length;
          }

          if (cne.firstWithNoWidth) {
            this.numNotationsOnLine--;
            continue;
          }

          // don't let a line break occur in the middle of a translation
          if (lastTranslationTextWithEndNeume) {
            this.numNotationsOnLine--;
            if (cne === lastTranslationTextWithEndNeume) {
              lastTranslationTextWithEndNeume = null;
            }
            continue;
          }

          // force any notations starting with a quilisma or inclinatum (diamond) to be kept with the previous notation:
          if (
            curr &&
            curr.notes &&
            (curr.notes[0].shape === NoteShape.Quilisma ||
              curr.notes[0].shape === NoteShape.Inclinatum)
          ) {
            this.numNotationsOnLine--;
            continue;
          }

          if (countSyllables < ctxt.minSyllablesLastLine && countNotes < ctxt.minNotesLastLine) {
            this.numNotationsOnLine--;
            continue;
          }

          // if the line break is allowed (cne.allowLineBreakBeforeNext), keep this number of notations around so we can check during justification
          // whether there would be too much space introduced between
          if (cne.keepWithNext === true) {
            if (cne.allowLineBreakBeforeNext && !this.maxNumNotationsOnLine)
              this.maxNumNotationsOnLine = this.numNotationsOnLine;
            this.numNotationsOnLine--;
          } else break;
        }
        if (this.extraTextOnlyIndex && (this.notationsStartIndex + this.numNotationsOnLine) <= this.extraTextOnlyIndex) {
          // we've cut back to before the extra text only index, so we have to remove it:
          this.extraTextOnlyIndex = null;
        }

        // if for some reason not a single notation can fit on the line, we'd better put it on anyway, to avoid an infinite loop:
        if (this.numNotationsOnLine === 0) this.numNotationsOnLine = 1;

        // determine the neumes we can space apart, if we do end up justifying
        curr = this.findNeumesToJustify(prevLyrics);

        this.lastLyrics = prevLyrics;
        if (this.maxNumNotationsOnLine) {
          // Check whether we should squeeze some extra notations on the line to avoid too much space after justification:
          // Check how much space we would have without the extra notations
          var extraSpace = this.getWhitespaceOnRight(ctxt);
          if (
            extraSpace / this.toJustify.length >
            ctxt.staffInterval * ctxt.maxExtraSpaceInStaffIntervals
          ) {
            LyricArray.mergeInArray(
              prevLyrics,
              notations.slice(
                this.notationsStartIndex + this.numNotationsOnLine,
                this.notationsStartIndex + this.maxNumNotationsOnLine
              )
            );
            this.numNotationsOnLine = this.maxNumNotationsOnLine;
            delete this.maxNumNotationsOnLine;
          }
        }

        // if the next line begins with a fresh word, than there can be extra space between the last notation on this line and the custos:
        let next = this.score.notations[
          this.extraTextOnlyIndex === null
            ? this.notationsStartIndex + this.numNotationsOnLine
            : this.extraTextOnlyIndex
        ];
        if (
          next &&
          next.hasLyrics() &&
          (next.lyrics[0].lyricType === LyricType.BeginningSyllable ||
            next.lyrics[0].lyricType === LyricType.SingleSyllable)
        ) {
          this.toJustify.push(this.custos);
        }

        if (
          j >= 1 &&
          notations[j].isDivider &&
          notations[j - 1].constructor === Custos
        ) {
          // reverse the order: put the divider first, and end the line with the custos.
          prevLyrics = [];
          for (i = j - 2; i >= this.notationsStartIndex; i--) {
            if (notations[i].hasLyrics()) {
              LyricArray.mergeIn(prevLyrics, notations[i].lyrics);
              break;
            }
          }
          // remove the custos and divider from the condensable spaces list, before adding the divider back, when repositioning it.
          condensableSpaces.sum -= condensableSpaces.pop().condensable;
          condensableSpaces.sum -= condensableSpaces.pop().condensable;
          this.positionNotationElement(
            ctxt,
            prevLyrics,
            notations[j - 2],
            notations[j],
            this.staffRight,
            condensableSpaces
          );
          this.custos = notations[j - 1];
          this.custos.bounds.x =
            this.staffRight -
            this.custos.bounds.width -
            this.custos.leadingSpace;
        }

        // we are at the end of the line!
        break;
      }

      if (curr.hasLyrics()) LyricArray.mergeIn(this.lastLyrics, curr.lyrics);

      if (
        lastTranslationTextWithEndNeume &&
        curr === lastTranslationTextWithEndNeume.translationText[0].endNeume
      ) {
        lastTranslationTextWithEndNeume = null;
      } else if (
        curr.translationText &&
        curr.translationText.length &&
        curr.translationText[0].endNeume
      ) {
        lastTranslationTextWithEndNeume = curr;
      }

      curr.line = this;
      this.numNotationsOnLine++;

      if (curr.isClef) ctxt.activeClef = curr;

      // line breaks are a special case indicating to stop processing here
      if (curr.constructor === ChantLineBreak && width > 0) {
        this.justify =
          curr.justify ||
          this.extraTextOnlyIndex !== null ||
          this.getWhitespaceOnRight(ctxt) < 0;
        if (this.justify) this.findNeumesToJustify(prevLyrics);
        break;
      }

      if (curr.constructor === Custos) {
        this.custos = curr;
      } else if (curr.isNeume) {
        this.custos = null;
      }
    }

    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine - 1;
    var last = notations[lastIndex] || {};
    while (
      lastIndex > 0 &&
      (last.constructor === ChantLineBreak ||
        last.constructor === Custos ||
        last.constructor === TextOnly)
    ) {
      last = notations[--lastIndex];
    }
    var isLastLine =
      this.notationsStartIndex + this.numNotationsOnLine === notations.length;
    if (
      (this.justify && this.extraTextOnlyIndex !== null) ||
      (width > 0 && isLastLine)
    ) {
      // this is the last chant line, or it has extra TextOnly elements at the end
      if (!this.toJustify) this.findNeumesToJustify(prevLyrics);
      this.justify =
        (!isLastLine || last.isDivider) &&
        this.getWhitespaceOnRight(ctxt) / (this.toJustify.length || 1) <=
          ctxt.staffInterval * ctxt.maxExtraSpaceInStaffIntervals;
    }

    if (!this.custos) {
      // create the automatic custos at the end of the line if there are neumes left in the notations
      for (
        i = this.notationsStartIndex + this.numNotationsOnLine;
        i < notations.length;
        i++
      ) {
        var notation = notations[i];

        if (notation.isNeume) {
          this.custos = new Custos(true);
          ctxt.currNotationIndex = i - 1; // make sure the context knows where the custos is
          this.custos.performLayout(ctxt);

          if (this.justify) {
            // Put the custos at the very end of the line
            this.custos.bounds.x =
              this.staffRight -
              this.custos.bounds.width -
              this.custos.leadingSpace;
          } else {
            this.custos.bounds.x =
              prevNeume.bounds.right() + prevNeume.calculatedTrailingSpace;
          }
          // nothing more to see here...
          break;
        }
      }
    }

    if (this.lastLyricsBeforeTextOnly) {
      this.lastLyrics = this.lastLyricsBeforeTextOnly;
      delete this.lastLyricsBeforeTextOnly;
    }

    // find the final lyric and mark it as connecting if needed.
    if (width > 0) {
      var whitespace = this.getWhitespaceOnRight();
      var rightEdge = this.staffRight;
      if (whitespace < 0) {
        rightEdge -= whitespace;
      }
    }
    i = 0;
    while (this.lastLyrics && this.lastLyrics[i]) {
      let lyrics = this.lastLyrics[i];
      if (lyrics.allowsConnector()) {
        lyrics.setNeedsConnector(true, 0);
        if (width > 0 && ctxt.minLyricWordSpacing < ctxt.hyphenWidth) {
          whitespace = rightEdge - lyrics.getRight();
          // shrink the hyphen if we are already out of whitespace or if we would be if we used a regular hyphen:
          if (whitespace < 0) {
            var minHyphenWidth = Math.max(
              ctxt.hyphenWidth + whitespace,
              this.lastLyrics.length > 1
                ? ctxt.intraNeumeSpacing
                : ctxt.minLyricWordSpacing
            );
            // we might not need to shift the syllable, but we do want to shrink the hyphen...
            lyrics.setConnectorWidth(minHyphenWidth);
          }
        }
      }
      ++i;
    }

    // if the provided width is less than zero, then set the width of the line
    // based on the last notation
    if (width <= 0) {
      this.staffRight = notations[
        this.notationsStartIndex + this.numNotationsOnLine - 1
      ].bounds.right();
      this.justify = false;
    }

    // Justify the line if we need to
    this.justifyElements(ctxt, this.justify, condensableSpaces);

    this.centerDividers();

    this.finishLayout(ctxt);
  }

  centerDividers() {
    var lastIndex =
        this.extraTextOnlyIndex === null
          ? this.notationsStartIndex + this.numNotationsOnLine
          : this.extraTextOnlyIndex,
      curr;
    for (var i = this.notationsStartIndex; i < lastIndex; i++) {
      curr = this.score.notations[i];

      if (curr && curr.isDivider) {
        var j = 1;
        var prev = this.score.notations[i - 1];
        var next =
          i + 1 === lastIndex ? this.custos : this.score.notations[i + 1];
        if (prev === next && next === this.custos) {
          prev = this.score.notations[i - 2];
          // force custos to right edge in this case, since it is a custos that exists
          // regardless of line break, and would normally be before the double bar, but in this case it ends the line:
          next.bounds.x = this.staffRight - next.bounds.width;
        }
        if (prev && next) {
          //if (prev instanceof TextOnly || next instanceof TextOnly) continue;
          var oldBoundsX = curr.bounds.x;
          var barWidth = curr.bounds.width;
          var leftPoint =
              prev instanceof TextOnly && prev.hasLyrics()
                ? prev.lyrics[0].getRight()
                : prev.bounds.right(),
            rightPoint =
              next instanceof TextOnly && next.hasLyrics()
                ? next.lyrics[0].getLeft()
                : next.bounds.x;
          if (prev instanceof TextOnly) {
            let prev = this.score.notations.slice(this.notationsStartIndex, i).reverse().find(notation => !(notation instanceof TextOnly));
            leftPoint = prev ? prev.bounds.right() : 0;
          }
          if (leftPoint) {
            curr.bounds.x = (leftPoint + rightPoint - barWidth) / 2;
          }
          if (curr.hasLyrics()) {
            var offset = oldBoundsX - curr.bounds.x;
            for (j = curr.lyrics.length - 1; j >= 0; j--) {
              curr.lyrics[j].bounds.x += offset;
              curr.lyrics[j].needsLayout = true;
            }
          }
        } else if (
          i === lastIndex - 1 &&
          this.justify &&
          (curr.constructor === DoubleBar || curr.constructor === FullBar)
        ) {
          curr.bounds.x = this.staffRight - curr.bounds.width;
        }
      }
    }
  }

  findNeumesToJustify(prevLyrics) {
    this.toJustify = [];
    var prev,
      curr = null,
      next = null,
      nextOrCurr = null,
      lastIndex = this.notationsStartIndex + this.numNotationsOnLine;
    for (var i = this.notationsStartIndex; i < lastIndex; i++) {
      prev = nextOrCurr;
      curr = this.score.notations[i];
      next = curr.isAccidental && this.score.notations[++i];
      nextOrCurr = next || curr;
      var hasLyrics = nextOrCurr.hasLyrics();

      if (!curr || !prev) continue;

      if (
        this.extraTextOnlyIndex !== null &&
        i >= this.extraTextOnlyIndex &&
        curr.constructor === TextOnly
      )
        continue;

      if (prev !== null) {
        LyricArray.mergeIn(prevLyrics, prev.lyrics);
        if (prev.keepWithNext === true) continue;
      }

      if (
        !curr.isDivider &&
        prevLyrics.length &&
        prevLyrics[0].allowsConnector() &&
        hasLyrics
      )
        continue;

      if (nextOrCurr.constructor === ChantLineBreak) continue;

      if (nextOrCurr === this.custos && !hasLyrics) continue;

      if (i === 0 && this.score.useDropCap && hasLyrics) continue;

      // otherwise, we can add space before this element
      this.toJustify.push(curr);
    }
    if (nextOrCurr !== null) LyricArray.mergeIn(prevLyrics, nextOrCurr.lyrics);
    return nextOrCurr;
  }

  getWhitespaceOnRight(ctxt) {
    var notations = this.score.notations;
    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;
    var last = notations[lastIndex - 1];
    if (this.extraTextOnlyIndex !== null && last.constructor === TextOnly) {
      lastIndex = this.extraTextOnlyIndex;
      last = notations[lastIndex - 1];
    }
    var lastRightNeume = last
      ? last.bounds.right() + last.calculatedTrailingSpace
      : 0;
    var lastLyrics = this.lastLyricsBeforeTextOnly || this.lastLyrics;
    var lastRightLyric = lastLyrics.length
      ? LyricArray.getRight(lastLyrics)
      : 0;

    if (this.custos) {
      lastRightNeume += this.custos.bounds.width + this.custos.leadingSpace;
      if (this.custos.hasLyrics()) {
        lastRightLyric = LyricArray.getRight(this.custos.lyrics);
      }
    } else if (ctxt && lastIndex < notations.length) {
      lastRightNeume += Glyphs.CustosLong.bounds.width * ctxt.glyphScaling;
    }
    return this.staffRight - Math.max(lastRightLyric, lastRightNeume);
  }

  justifyElements(ctxt, doJustify, condensableSpaces) {
    var i;
    var toJustify = this.toJustify || [];
    var notations = this.score.notations;
    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;

    // if it wasn't an ideal line break, and the last note is further from the custos than it would have been from its next punctum,
    // move the custos over.
    // We do this first so that if it opens up any new whitespace, that gets accounted for when we do the justification
    var lastNotation =
      notations[this.notationsStartIndex + this.numNotationsOnLine - 1];
    var extraSpaceBeforeCustos =
      this.staffRight < Infinity &&
      this.custos &&
      lastNotation.keepWithNext &&
      this.custos.bounds.x -
        lastNotation.bounds.right() -
        lastNotation.calculatedTrailingSpace;
    if (extraSpaceBeforeCustos > 0) {
      // first, shrink the hyphen(s) if applicable, to move the neumes closer to the custos:
      i = 0;
      while (this.lastLyrics && this.lastLyrics[i]) {
        let lyrics = this.lastLyrics[i];
        if (lyrics.allowsConnector()) {
          var connectorWidth = lyrics.getConnectorWidth();
          if (ctxt.minLyricWordSpacing < connectorWidth) {
            var minHyphenWidth = Math.max(
              connectorWidth - extraSpaceBeforeCustos,
              this.lastLyrics.length > 1
                ? ctxt.intraNeumeSpacing
                : ctxt.minLyricWordSpacing
            );
            // we might not need to shift the syllable, but we do want to shrink the hyphen...
            lyrics.setConnectorWidth(minHyphenWidth);
          }
        }
        ++i;
      }
      this.custos.bounds.x =
        lastNotation.bounds.right() + lastNotation.calculatedTrailingSpace;
    }

    // first step of justification is to determine how much space we have to use up
    var extraSpace = this.getWhitespaceOnRight();

    if (
      Math.abs(extraSpace) < 0.5 ||
      (extraSpace > 0 && ((doJustify && toJustify.length === 0) || !doJustify))
    )
      return;

    this.condensableSpaces = condensableSpaces;

    var curr, prev;
    var offset = 0;
    var increment = extraSpace / toJustify.length;
    var multiplier = 0;
    var toJustifyIndex = 0;
    if (extraSpace < 0) {
      toJustify = condensableSpaces.filter(s => s.condensable > 0);
      multiplier = extraSpace / condensableSpaces.sum;
      increment = 0;
    }
    var nextToJustify = toJustify[toJustifyIndex++];
    var incrementOffsetAtNextChance = false;
    for (i = this.notationsStartIndex; i < lastIndex; i++) {
      prev = curr;
      curr = notations[i];

      if (
        this.extraTextOnlyIndex !== null &&
        i >= this.extraTextOnlyIndex &&
        curr.constructor === TextOnly
      ) {
        continue;
      }

      if (!multiplier && curr === this.custos) {
        if (curr.hasLyrics()) {
          curr.bounds.x = Math.min(
            curr.bounds.x +
              (this.staffRight - LyricArray.getRight(curr.lyrics)),
            this.staffRight - curr.bounds.width
          );
          offset += increment;
        } else {
          curr.bounds.x = Math.min(
            curr.bounds.x + offset,
            this.staffRight - curr.bounds.width
          );
        }
        continue;
      }

      if (multiplier) {
        if (nextToJustify && nextToJustify.notation === curr) {
          offset += multiplier * nextToJustify.condensable;
          nextToJustify = toJustify[toJustifyIndex++];
        }
      } else if (nextToJustify === curr) {
        if (prev.hasNoWidth) {
          incrementOffsetAtNextChance = true;
        } else {
          offset += increment;
        }
        nextToJustify = toJustify[toJustifyIndex++];
      } else if (incrementOffsetAtNextChance && !prev.hasNoWidth) {
        incrementOffsetAtNextChance = false;
        offset += increment;
      }

      curr.bounds.x += offset;
    }

    if (extraSpaceBeforeCustos > 0) {
      this.custos.bounds.x =
        lastNotation.bounds.right() + lastNotation.calculatedTrailingSpace;
    }
  }

  handleEndBrace(ctxt, note, i) {
    var startBrace = ctxt.lastStartBrace;
    if (!startBrace) return;
    // calculate the y value of the brace by iterating over all notations
    // under/over the brace.
    var y;
    var k = startBrace.notationIndex;
    var notations = this.score.notations;
    var dy = ctxt.intraNeumeSpacing / 2; // some safe space between brace and notes.
    var startNote = startBrace.note;

    if (startBrace.isAbove) {
      y = Math.min(
        ctxt.calculateHeightFromStaffPosition(4),
        ...[startNote, note]
          .concat(notations.slice(k, i + 1))
          .map(n => n.bounds.y - dy)
      );
    } else {
      y = Math.max(
        ctxt.calculateHeightFromStaffPosition(-4),
        ...[startNote, note]
          .concat(notations.slice(k, i + 1))
          .map(n => n.bounds.bottom() + dy)
      );
    }

    var addAcuteAccent = false;

    if (startBrace.shape === BraceShape.RoundBrace) {
      this.braces.push(
        new RoundBraceVisualizer(
          ctxt,
          startBrace.getAttachmentX(startNote),
          note.braceEnd.getAttachmentX(note),
          y,
          startBrace.isAbove
        )
      );
    } else {
      if (startBrace.shape === BraceShape.AccentedCurlyBrace)
        addAcuteAccent = true;

      this.braces.push(
        new CurlyBraceVisualizer(
          ctxt,
          startBrace.getAttachmentX(startNote),
          note.braceEnd.getAttachmentX(note),
          y,
          startBrace.isAbove,
          addAcuteAccent
        )
      );
    }

    delete ctxt.lastStartBrace;
  }

  finishLayout(ctxt) {
    this.ledgerLines = []; // clear any existing ledger lines

    var notations = this.score.notations;
    var lastIndex = this.notationsStartIndex + this.numNotationsOnLine;

    // an element needs to have a staffPosition property, as well as the standard
    // bounds property. so it could be a note, or it could be a custos
    // offsetX can be used to add to the position info for the element,
    // useful in the case of notes.
    var processElementForLedgerLine = (
      element,
      endElem = element,
      staffPosition = element.staffPosition,
      offsetX = element.neume ? element.neume.bounds.x : 0
    ) => {
      // do we need a ledger line for this note?

      if (staffPosition >= 5 || staffPosition <= -5) {
        var x1 = offsetX + element.bounds.x - ctxt.intraNeumeSpacing;
        var x2 =
          offsetX +
          endElem.bounds.x +
          endElem.bounds.width +
          ctxt.intraNeumeSpacing;

        // round the staffPosition to the nearest line
        if (staffPosition > 0)
          staffPosition = staffPosition - ((staffPosition - 1) % 2);
        else staffPosition = staffPosition - ((staffPosition + 1) % 2);

        // if we have a ledger line close by, then average out the distance between the two
        var minLedgerSeparation = ctxt.staffInterval * ctxt.minLedgerSeparation;

        if (
          this.ledgerLines.length > 0 &&
          this.ledgerLines[this.ledgerLines.length - 1].x2 +
            minLedgerSeparation >=
            x1
        ) {
          // average out the distance
          var half =
            (x1 - this.ledgerLines[this.ledgerLines.length - 1].x2) / 2;
          this.ledgerLines[this.ledgerLines.length - 1].x2 += half;
          x1 -= half;
        }

        // never let a ledger line extend past the staff width
        if (x2 > this.staffRight) x2 = this.staffRight;

        // finally, add the ledger line
        this.ledgerLines.push({
          x1: x1,
          x2: x2,
          staffPosition: staffPosition
        });
      }
    };

    var episemata = []; // keep track of episemata in case we can connect some
    var startBrace = null;
    var minY = Number.MAX_VALUE,
      maxY = Number.MIN_VALUE; // for braces

    var positionNonLyricText = (text, neume, rightX) => {
      text.setMaxWidth(ctxt, this.staffRight);
      //text.bounds.x = neume.hasLyrics()? Math.min(...neume.lyrics.map(l => l.bounds.x)) : 0;
      text.bounds.x = 0;
      if (rightX)
        text.bounds.x = (text.bounds.x + rightX - text.bounds.width) / 2;
      var beyondStaffRight =
        neume.bounds.x + text.bounds.right() - this.staffRight;
      if (beyondStaffRight > 0) {
        text.bounds.x -= beyondStaffRight;
      }
      if (neume.bounds.x + text.bounds.x < 0) {
        text.bounds.x = -neume.bounds.x;
      }
    };

    // make a final pass over all of the notes to add any necessary
    // ledger lines and to smooth out episemata
    for (var i = this.notationsStartIndex; i < lastIndex; i++) {
      var neume = notations[i];

      minY = Math.min(minY, neume.bounds.y);
      maxY = Math.max(maxY, neume.bounds.bottom());

      if (neume.constructor === Custos) {
        processElementForLedgerLine(neume);
        continue;
      }

      // if the AboveLinesText would extend beyond the right edge of the staff, right align it instead
      if (neume.alText) {
        for (var j = 0; j < neume.alText.length; j++) {
          positionNonLyricText(neume.alText[j], neume);
        }
      }

      // set up horizontal position of translations
      if (neume.translationText) {
        for (j = 0; j < neume.translationText.length; j++) {
          var text = neume.translationText[j];
          if (text.endNeume) {
            var rightX = text.endNeume.hasLyrics()
              ? text.endNeume.bounds.x +
                Math.max(...text.endNeume.lyrics.map(l => l.bounds.right()))
              : text.endNeume.bounds.right();
            rightX -= neume.bounds.x;
            positionNonLyricText(text, neume, rightX);
          } else {
            positionNonLyricText(text, neume);
          }
        }
      }

      // if it's not a neume then just skip here
      if (!neume.isNeume) continue;

      for (j = 0; j < neume.ledgerLines.length; j++) {
        var ll = neume.ledgerLines[j];
        processElementForLedgerLine(ll.element, ll.endElem, ll.staffPosition);
      }

      for (j = 0; j < neume.notes.length; j++) {
        var k,
          note = neume.notes[j];

        // blend episemata as we're able
        if (note.episemata.length === 0) episemata = [];
        for (k = 0; k < note.episemata.length; k++) {
          var episema = note.episemata[k];

          var spaceBetweenEpisemata = 0;

          // calculate the distance between the last episemata and this one...
          // lots of code for a simple: currEpisemata.left - prevEpisemata.right
          if (episemata.length > 0)
            spaceBetweenEpisemata =
              neume.bounds.x +
              episema.bounds.x -
              (episemata[episemata.length - 1].note.neume.bounds.x +
                episemata[episemata.length - 1].bounds.right());

          // we try to blend the episema if we're able.
          if (
            episemata.length === 0 ||
            episemata[episemata.length - 1].positionHint !==
              episema.positionHint ||
            episemata[episemata.length - 1].terminating === true ||
            episemata[episemata.length - 1].alignment ===
              HorizontalEpisemaAlignment.Left ||
            episemata[episemata.length - 1].alignment ===
              HorizontalEpisemaAlignment.Center ||
            episema.alignment === HorizontalEpisemaAlignment.Right ||
            episema.alignment === HorizontalEpisemaAlignment.Center ||
            (spaceBetweenEpisemata > ctxt.intraNeumeSpacing * 2 &&
              note.glyphVisualizer.glyphCode !== GlyphCode.None)
          ) {
            // start a new set of episemata to potentially blend
            episemata = [episema];
          } else {
            // blend all previous with this one
            var newY;

            if (episema.positionHint === MarkingPositionHint.Below)
              newY = Math.max(
                episema.bounds.y,
                episemata[episemata.length - 1].bounds.y
              );
            else
              newY = Math.min(
                episema.bounds.y,
                episemata[episemata.length - 1].bounds.y
              );

            if (episema.bounds.y !== newY) episema.bounds.y = newY;
            else {
              for (var l = 0; l < episemata.length; l++)
                episemata[l].bounds.y = newY;
            }

            // extend the last episema to meet the new one
            var newWidth =
              neume.bounds.x +
              episema.bounds.x -
              (episemata[episemata.length - 1].note.neume.bounds.x +
                episemata[episemata.length - 1].bounds.x);
            if (newWidth < 0) {
              newWidth *= -1;
              episemata[episemata.length - 1].bounds.x -= newWidth;
            }
            episemata[episemata.length - 1].bounds.width = newWidth;

            episemata.push(episema);
          }
        }

        if (note.braceEnd) this.handleEndBrace(ctxt, note, i);

        if (note.braceStart) {
          ctxt.lastStartBrace = startBrace = note.braceStart;
          startBrace.notationIndex = i;
        }
      }
    }

    // if we still have an active brace, that means it spands two chant lines!
    if (startBrace !== null) {
      if (this.custos) {
        // if the next end brace is on the first note following the line break, simply use it with the custos
        // Do the same if there is only an accidental between
        // otherwise, make a new end brace to work for this one, and a new start brace for the next line.
        var nextNotation = notations[lastIndex];
        var nextNote = nextNotation.notes && nextNotation.notes[0];
        var nextNotationButOne = notations[lastIndex + 1];
        var nextNoteButOne =
          nextNotationButOne &&
          nextNotationButOne.notes &&
          nextNotationButOne.notes[0];
        var braceEnd =
          (nextNote && nextNote.braceEnd) ||
          (nextNotation.isAccidental &&
            nextNoteButOne &&
            nextNoteButOne.braceEnd);
        if (braceEnd) {
          this.custos.braceEnd = braceEnd;
          this.handleEndBrace(ctxt, this.custos, i);
        } else {
          this.braceStart = startBrace;
          this.custos.braceEnd = new BracePoint(
            this.custos,
            startBrace.isAbove,
            startBrace.shape,
            BraceAttachment.Right
          );
          this.handleEndBrace(ctxt, this.custos, i - 1);
          ctxt.lastStartBrace = new BracePoint(
            null,
            startBrace.isAbove,
            startBrace.shape,
            BraceAttachment.Left
          );
          ctxt.lastStartBrace.notationIndex = i;
        }
      }
    }

    // don't forget to also include the final custos, which may need a ledger line too
    if (this.custos) processElementForLedgerLine(this.custos);
  }

  // this is where the real core of positioning neumes takes place
  // returns true if positioning was able to fit the neume before rightNotationBoundary.
  // returns false if cannot fit before given right margin.
  // fixme: if this returns false, shouldn't we set the connectors on prev to be activated?!
  positionNotationElement(
    ctxt,
    prevLyrics,
    prev,
    curr,
    rightNotationBoundary,
    condensableSpaces = []
  ) {
    if (!condensableSpaces.hasOwnProperty(\"sum\")) condensableSpaces.sum = 0;
    var i,
      space = { notation: curr },
      fixedX = false;

    // To begin we just place the current notation right after the previous,
    // irrespective of lyrics.
    // But if the previous neume was part of a polyphonic \"no width\" group and the current is not, or is of a separate group,
    // we force it to have the same x as the previous group.
    if (
      (!curr.hasNoWidth || curr.firstWithNoWidth === curr) &&
      prev.firstWithNoWidth
    ) {
      curr.bounds.x = prev.firstWithNoWidth.bounds.x;
      fixedX = true;
    } else {
      curr.bounds.x = prev.bounds.right();
    }

    if (
      (curr.constructor === TextOnly && this.extraTextOnlyIndex === null) ||
      (!curr.hasLyrics() && prev.calculatedTrailingSpace < 0)
    ) {
      // We transfer over the trailing space from the previous neume if the current neume is text only,
      // so that the text only neume has a better chance at not needing a connector.
      curr.calculatedTrailingSpace = prev.calculatedTrailingSpace;
      if (curr.hasLyrics())
        curr.calculatedTrailingSpace -= curr.lyrics[0].bounds.width;
      if (curr.constructor === TextOnly && curr.lyrics.length === 1) {
        curr.lyrics[0].setMaxWidth(
          ctxt,
          this.staffRight,
          this.staffRight -
            LyricArray.getRight(prevLyrics) -
            ctxt.minLyricWordSpacing
        );
      }
    } else if (!fixedX) {
      curr.bounds.x += prev.calculatedTrailingSpace;
    }

    if (
      curr.hasLyrics() &&
      !prev.isDivider &&
      !prev.isAccidental &&
      this.numNotationsOnLine > 0 &&
      (curr.lyrics[0].lyricType === LyricType.SingleSyllable ||
        curr.lyrics[0].lyricType === LyricType.BeginningSyllable)
    ) {
      curr.bounds.x += ctxt.intraNeumeSpacing * ctxt.interVerbalMultiplier;
    }
    if (curr.hasNoWidth || fixedX) {
      space.total = space.condensable = 0;
    } else if (
      this.extraTextOnlyIndex !== null &&
      curr.constructor === TextOnly
    ) {
      curr.bounds.x = 0;
      space.total = space.condensable = 0;
    } else {
      space.total = curr.bounds.x - prev.bounds.right();
      space.condensable = space.total * ctxt.condensingTolerance;
    }

    // if the previous notation has no lyrics, then we simply make sure the
    // current notation with lyrics is in the bounds of the line
    if (prevLyrics.length === 0) {
      var maxRight = curr.bounds.right() + curr.calculatedTrailingSpace;

      // if the lyric left is negative, then offset the neume appropriately
      for (i = 0; i < curr.lyrics.length; i++) {
        let currLyric = curr.lyrics[i];
        // we hope for the best!
        // but always use a connector if the lyric has original text that was all used up for the drop cap.
        let needsConnector =
          currLyric.allowsConnector() &&
          currLyric.dropCap &&
          currLyric.originalText &&
          !currLyric.text;
        currLyric.setNeedsConnector(needsConnector);
        let minLeft = this.staffLeft - this.paddingLeft;

        if (currLyric.getLeft() < minLeft)
          curr.bounds.x -= currLyric.getLeft() - minLeft;

        space.condensable = Math.min(
          space.condensable,
          currLyric.getLeft() - minLeft
        );
        maxRight = Math.max(maxRight, currLyric.getRight());
      }

      if (
        maxRight >
        rightNotationBoundary + condensableSpaces.sum + space.condensable
      )
        return false;
      condensableSpaces.push(space);
      condensableSpaces.sum += space.condensable;
      return true;
    } else {
      if (curr.firstOfSyllable && prevLyrics.length && !curr.hasLyrics()) {
        curr.bounds.x = Math.max(curr.bounds.x, prevLyrics[0].getRight());
        space.total = curr.bounds.x - prev.bounds.right();
        space.condensable = space.total * ctxt.condensingTolerance;
      }
    }

    // if the curr notation has no lyrics, then simply check whether there is enough room
    if (curr.hasLyrics() === false) {
      if (
        curr.bounds.right() + curr.calculatedTrailingSpace >
        rightNotationBoundary + condensableSpaces.sum + space.condensable
      )
        return false;
      condensableSpaces.push(space);
      condensableSpaces.sum += space.condensable;
      return true;
    }

    // if we have multiple lyrics on the current or the previous notation,
    // we will have to run several passes over each set of lyrics:

    // on the first pass, we will check the absolute left-most placement of the new syllables
    // we will make additional passes until everything is stable
    do {
      var hasShifted = false;
      var atLeastOneWithoutConnector = false;
      for (i = 0; i < curr.lyrics.length; i++) {
        if (!curr.lyrics[i].originalText) continue;
        var prevLyricRight = 0;
        let condensableSpacesSincePrevLyric = [];
        let condensableSpaceSincePrevLyric = null;
        if (i < prevLyrics.length && prevLyrics[i]) {
          prevLyricRight = prevLyrics[i].getRight();
          let notationI = condensableSpaces
            .map(s => s.notation)
            .lastIndexOf(prevLyrics[i].notation);
          if (notationI >= 0) {
            condensableSpacesSincePrevLyric = condensableSpaces.slice(
              notationI + 1
            );
            condensableSpacesSincePrevLyric.sum = condensableSpacesSincePrevLyric
              .map(s => s.condensable)
              .reduce((a, b) => a + b, 0);
          } else {
            condensableSpacesSincePrevLyric.sum = 0;
          }
        }

        curr.lyrics[i].setNeedsConnector(false); // we hope for the best!
        var currLyricLeft = curr.lyrics[i].getLeft();
        if (!prevLyrics[i] || prevLyrics[i].allowsConnector() === false) {
          // No connector needed, but include space between words if necessary!
          let extraSpace = currLyricLeft - prevLyricRight - ctxt.minLyricWordSpacing;
          if (extraSpace < 0) {
            // push the current element over a bit.
            let shift =
              prevLyricRight + ctxt.minLyricWordSpacing - currLyricLeft;
            curr.bounds.x += shift;
            condensableSpaceSincePrevLyric = 0;
            hasShifted = shift > 0.5;
          } else {
            condensableSpaceSincePrevLyric = extraSpace;
          }
        } else {
          // we may need a connector yet...
          if (
            prevLyricRight + 0.1 >
            currLyricLeft -
              condensableSpacesSincePrevLyric.sum -
              space.condensable
          ) {
            // in this case, the lyric elements actually overlap.
            // so nope, no connector needed. instead, we just place the lyrics together
            // fixme: for better text layout, we could actually use the kerning values
            // between the prev and curr lyric elements!
            let shift = prevLyricRight - currLyricLeft;
            if (shift < -0.1) {
              // in this case, the spacing needs to be condensed in the neumes since the last lyric...
              let multiplier =
                shift /
                (condensableSpacesSincePrevLyric.sum + space.condensable);
              let offset = 0;
              condensableSpacesSincePrevLyric.forEach(s => {
                offset += multiplier * s.condensable;
                s.notation.bounds.x += offset;
              });
            }
            curr.bounds.x += shift;
            condensableSpaceSincePrevLyric = 0;
            atLeastOneWithoutConnector = true;
            hasShifted = shift > 0.5;
          } else {
            // bummer, looks like we couldn't merge the syllables together. Better add a connector...
            if (ctxt.minLyricWordSpacing < ctxt.hyphenWidth) {
              var spaceBetweenSyls = currLyricLeft - prevLyricRight;
              if (spaceBetweenSyls < ctxt.hyphenWidth) {
                var minHyphenWidth =
                  prevLyrics.length > 1
                    ? ctxt.intraNeumeSpacing
                    : ctxt.minLyricWordSpacing;
                // we might not need to shift the syllable, but we do want to shrink the hyphen...
                prevLyrics[i].setConnectorWidth(
                  Math.max(minHyphenWidth, spaceBetweenSyls)
                );
              }
            }
            prevLyrics[i].setNeedsConnector(true);
            prevLyricRight = prevLyrics[i].getRight();

            if (prevLyricRight + 0.1 > currLyricLeft) {
              let shift = prevLyricRight - currLyricLeft;
              curr.bounds.x += shift;
              condensableSpaceSincePrevLyric = 0;
              hasShifted = shift > 0.5;
            } else {
              condensableSpaceSincePrevLyric = currLyricLeft - prevLyricRight;
            }
          }
        }

        if (condensableSpaceSincePrevLyric !== null) {
          if (
            condensableSpaceSincePrevLyric <
            condensableSpacesSincePrevLyric.sum + space.condensable
          ) {
            // reduce condensable space so that lyrics retain at least the width of a space character between words:
            let multiplier = condensableSpaceSincePrevLyric / (condensableSpacesSincePrevLyric.sum + space.condensable);
            space.condensable *= multiplier;
            if (condensableSpacesSincePrevLyric.sum) {
              condensableSpacesSincePrevLyric.forEach(space => {
                space.condensable *= multiplier;
              });
              condensableSpaces.sum = condensableSpaces
                .map(s => s.condensable)
                .reduce((a, b) => a + b, 0);
            }
          }
        }
      }
    } while (
      curr.lyrics.length > 1 &&
      hasShifted &&
      atLeastOneWithoutConnector
    );

    for (i = Math.min(curr.lyrics.length, prevLyrics.length) - 1; i >= 0; i--) {
      let pLyrics = prevLyrics[i];
      if (pLyrics.needsConnector && pLyrics.connectorWidth) {
        currLyricLeft = curr.lyrics[i].getLeft();
        prevLyricRight = pLyrics.getRight() - pLyrics.connectorWidth;
        spaceBetweenSyls = currLyricLeft - prevLyricRight;
        if (spaceBetweenSyls >= ctxt.hyphenWidth) spaceBetweenSyls = 0;
        pLyrics.setConnectorWidth(spaceBetweenSyls);
      }
    }

    if (
      curr.bounds.right() + curr.calculatedTrailingSpace <
        rightNotationBoundary + condensableSpaces.sum + space.condensable &&
      LyricArray.getRight(curr.lyrics, true) <=
        this.staffRight + condensableSpaces.sum + space.condensable
    ) {
      if (prev.isAccidental) {
        // move the previous accidental up next to the current note:
        let shift =
          curr.bounds.x -
          prev.bounds.width -
          prev.calculatedTrailingSpace -
          prev.bounds.x;
        prev.bounds.x += shift;
        if (Math.abs(shift) > 0.1) {
          let lastCondensable = condensableSpaces[condensableSpaces.length - 1];
          condensableSpaces.sum -= lastCondensable.condensable;
          lastCondensable.condensable = 0;
        }
      }
      condensableSpaces.push(space);
      condensableSpaces.sum += space.condensable;
      return true;
    }

    // if we made it this far, then the element won't fit on this line.
    return false;
  }

  /**
   * Find the notation closest to x without going past it
   * @param {number} x
   */
  bisectNotationAtX(x, useMidpoint = true) {
    let minIndex = -1,
      maxIndex = Math.min(this.numNotationsOnLine, Infinity),
      curIndex = minIndex + ((maxIndex - minIndex) >> 1),
      notations = this.score.notations.slice(
        this.notationsStartIndex,
        this.notationsStartIndex + this.numNotationsOnLine
      );

    while (minIndex < curIndex) {
      let notation = notations[curIndex];
      let notationX = notation.bounds.x;
      if (notationX > x) {
        maxIndex = curIndex;
      } else {
        minIndex = curIndex;
      }
      curIndex = minIndex + ((maxIndex - minIndex) >> 1);
    }
    let notation = notations[curIndex];
    if (
      useMidpoint &&
      notation &&
      notation.bounds.width === 0 &&
      curIndex + 1 < notations.length
    ) {
      let nextNotation = notations[curIndex + 1],
        closenessToLeft = x - notation.bounds.x,
        closenessToRight = nextNotation.bounds.x - x;
      if (nextNotation.bounds.width === 0 && closenessToRight < closenessToLeft)
        ++curIndex;
    }
    return notations[curIndex];
  }
}



// WEBPACK FOOTER //
// ./src/Exsurge.Chant.ChantLine.js","//
// Author(s):
// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
//
// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the \"Software\"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

import { NoteShape } from \"./Exsurge.Chant.js\";
import {
  ChantLayoutElement,
  GlyphCode,
  GlyphVisualizer,
  MarkingPositionHint,
  QuickSvg
} from \"./Exsurge.Drawing.js\";

export class Accent extends GlyphVisualizer {
  constructor(ctxt, note, glyphCode = GlyphCode.AcuteAccent) {
    super(ctxt, glyphCode);
    this.note = note;
    this.positionHint = MarkingPositionHint.Above;
  }

  performLayout(ctxt) {
    this.bounds.x = this.note.bounds.x + this.bounds.width / 2; // center on the note itself

    // this puts the acute accent either over the staff lines, or over the note if the
    // note is above the staff lines
    this.setStaffPosition(ctxt, Math.max(this.note.staffPosition + 1, 4));
  }
}

// for positioning markings on notes
export var HorizontalEpisemaAlignment = {
  Default: 0,
  Left: 1,
  Center: 2,
  Right: 3
};

/*
 * HorizontalEpisema
 *
 * A horizontal episema marking is it's own visualizer (that is, it implements createSvgFragment)
 */
export class HorizontalEpisema extends ChantLayoutElement {
  constructor(note) {
    super();

    this.note = note;

    this.positionHint = MarkingPositionHint.Default;
    this.terminating = false; // indicates if this episema should terminate itself or not
    this.alignment = HorizontalEpisemaAlignment.Default;
  }

  performLayout(ctxt) {
    // following logic helps to keep the episemata away from staff lines if they get too close

    var y = 0,
      step;
    var minDistanceAway = ctxt.staffInterval * 0.25; // min distance from neume
    var glyphCode = this.note.glyphVisualizer.glyphCode;
    var ledgerLine = this.note.neume.ledgerLines[0] || {};
    var punctumInclinatumShorten = false;

    if (glyphCode === GlyphCode.PunctumInclinatum) {
      let notes = this.note.neume.notes,
        index = notes.indexOf(this.note),
        prevNote = notes[index - 1];
      if (
        prevNote &&
        prevNote.glyphVisualizer.glyphCode === GlyphCode.PunctumInclinatum &&
        prevNote.staffPosition - this.note.staffPosition === 1
      ) {
        punctumInclinatumShorten = true;
      }
    }

    if (this.positionHint === MarkingPositionHint.Below) {
      y = this.note.bounds.bottom() + minDistanceAway; // the highest the line could be at
      if (glyphCode === GlyphCode.None)
        // correction for episema under the second note of a porrectus
        y += ctxt.staffInterval / 2;
      step = Math.ceil(y / ctxt.staffInterval);
      // if there's enough space, center the episema between the punctum and the next staff line
      if (step % 2 === 0) {
        step = (step + 3 / 4 + (y - minDistanceAway) / ctxt.staffInterval) / 2;
      } else {
        // otherwise, find nearest acceptable third between staff lines (or staff line)
        step = (Math.ceil((1.5 * y) / ctxt.staffInterval - 0.5) * 2 + 1) / 3;

        // if it's an odd step, that means we're on a staff line,
        // so we shift to between the staff line
        if (Math.abs(step) % 2 === 1) {
          if (Math.abs(step) < 4 || ledgerLine.staffPosition === -step) {
            step += 2 / 3;
          } else {
            // no ledger line, but we don't want the episema to be at exactly the same height the ledger line would occupy:
            step += 1 / 3;
          }
        }
      }
    } else {
      y = this.note.bounds.y - minDistanceAway; // the lowest the line could be at
      step = Math.floor(y / ctxt.staffInterval);
      // if there's enough space, center the episema between the punctum and the next staff line
      if (step % 2 === 0) {
        step = (step - 3 / 4 + (y + minDistanceAway) / ctxt.staffInterval) / 2;
      } else {
        // otherwise, find nearest acceptable third between staff lines (or staff line)
        step = (Math.floor((1.5 * y) / ctxt.staffInterval - 0.5) * 2 + 1) / 3;

        // find nearest acceptable third between staff lines (or staff line)
        if (Math.abs(step) % 2 === 1) {
          // if it was a staff line, we need to adjust
          if (Math.abs(step) < 4 || ledgerLine.staffPosition === -step) {
            step -= 2 / 3;
          } else {
            // no ledger line, but we don't want the episema to be at exactly the same height the ledger line would occupy:
            step -= 1 / 3;
          }
        }
      }
    }

    y = step * ctxt.staffInterval;

    var width = this.note.bounds.width;
    var x = this.note.bounds.x;

    // The porrectus requires special handling of the note width,
    // otherwise the width is just that of the note itself
    if (
      glyphCode === GlyphCode.Porrectus1 ||
      glyphCode === GlyphCode.Porrectus2 ||
      glyphCode === GlyphCode.Porrectus3 ||
      glyphCode === GlyphCode.Porrectus4
    )
      width = ctxt.staffInterval;
    else if (glyphCode === GlyphCode.None) {
      width = ctxt.staffInterval;
      x -= width;
    } else if (punctumInclinatumShorten) {
      width *= 2 / 3;
      x += 0.5 * width;
    } else if (glyphCode === GlyphCode.PunctumInclinatumLiquescent) {
      width *= 2 / 3;
      x += 0.25 * width;
    }

    // also, the position hint can affect the x/width of the episema
    if (this.alignment === HorizontalEpisemaAlignment.Left) {
      width *= 0.8;
    } else if (this.alignment === HorizontalEpisemaAlignment.Center) {
      x += width * 0.1;
      width *= 0.8;
    } else if (this.alignment === HorizontalEpisemaAlignment.Right) {
      x += width * 0.2;
      width *= 0.8;
    }

    this.bounds.x = x;
    this.bounds.y = y - ctxt.episemaLineWeight / 2;
    this.bounds.width = width;
    this.bounds.height = ctxt.episemaLineWeight;

    this.origin.x = 0;
    this.origin.y = 0;
  }

  draw(ctxt) {
    var canvasCtxt = ctxt.canvasCtxt;

    canvasCtxt.fillStyle = ctxt.neumeLineColor;

    canvasCtxt.fillRect(
      this.bounds.x,
      this.bounds.y,
      this.bounds.width,
      this.bounds.height
    );
  }

  getSvgProps(ctxt) {
    return {
      x: this.bounds.x,
      y: this.bounds.y,
      width: this.bounds.width,
      height: this.bounds.height,
      fill: ctxt.neumeLineColor,
      class: \"horizontalEpisema\"
    };
  }

  createSvgNode(ctxt) {
    return QuickSvg.createNode(\"rect\", this.getSvgProps(ctxt));
  }
  createSvgTree(ctxt) {
    return QuickSvg.createSvgTree(\"rect\", this.getSvgProps(ctxt));
  }

  createSvgFragment(ctxt) {
    return QuickSvg.createFragment(\"rect\", this.getSvgProps(ctxt));
  }
}

/*
 * Ictus
 */
export class Ictus extends GlyphVisualizer {
  constructor(ctxt, note) {
    super(ctxt, GlyphCode.VerticalEpisemaAbove);
    this.note = note;
    this.positionHint = MarkingPositionHint.Default;
  }

  performLayout(ctxt) {
    var glyphCode = this.note.glyphVisualizer.glyphCode;
    // we have to place the ictus further from the note in some cases to avoid a collision with an episema on the same note:
    var positionHint = this.positionHint || MarkingPositionHint.Below;
    var staffPosition =
      this.note.staffPosition +
      (positionHint === MarkingPositionHint.Above ? 1 : -1);
    var collisionWithEpisema =
      this.note.episemata.length > 0 &&
      (this.note.episemata[0].positionHint || MarkingPositionHint.Above) ===
        positionHint;
    var horizontalOffset;
    var verticalOffset = 1;
    var shortOffset = -0.2;
    var extraOffset = 0;
    var collisionWithStaffLine =
      staffPosition % 2 &&
      (Math.abs(staffPosition) < 4 ||
        (this.note.neume.ledgerLines[0] || {}).staffPosition === staffPosition);

    // The porrectus requires special handling of the note width,
    // otherwise the width is just that of the note itself
    if (
      glyphCode === GlyphCode.Porrectus1 ||
      glyphCode === GlyphCode.Porrectus2 ||
      glyphCode === GlyphCode.Porrectus3 ||
      glyphCode === GlyphCode.Porrectus4
    )
      horizontalOffset = ctxt.staffInterval / 2;
    else if (glyphCode === GlyphCode.None) {
      horizontalOffset = -ctxt.staffInterval / 2;
    } else {
      horizontalOffset = this.note.bounds.width / 2;
      if (
        glyphCode === GlyphCode.PunctumInclinatum &&
        !collisionWithStaffLine &&
        !collisionWithEpisema
      ) {
        extraOffset = 0.3;
      }
    }

    if (this.positionHint === MarkingPositionHint.Above) {
      glyphCode = GlyphCode.VerticalEpisemaAbove;
      verticalOffset *= -1;
    } else {
      glyphCode = GlyphCode.VerticalEpisemaBelow;
    }
    if (collisionWithEpisema) {
      extraOffset = 0.4;
    }
    verticalOffset *=
      ctxt.staffInterval *
      (extraOffset + (collisionWithStaffLine ? 0.3 : shortOffset));

    this.setGlyph(ctxt, glyphCode);
    this.setStaffPosition(ctxt, staffPosition);

    this.bounds.x = this.note.bounds.x + horizontalOffset - this.origin.x;
    this.bounds.y += verticalOffset;
  }
}

/*
 * Mora
 */
export class Mora extends GlyphVisualizer {
  constructor(ctxt, note) {
    super(ctxt, GlyphCode.Mora);
    this.note = note;
    this.positionHint = MarkingPositionHint.Default;
    this.horizontalOffset = ctxt.staffInterval / 2 + this.origin.x;
  }

  performLayout(ctxt) {
    this.setGlyph(ctxt, this.glyphCode);
    this.horizontalOffset = ctxt.staffInterval / 2 + this.origin.x;
    var staffPosition = this.note.staffPosition;

    this.setStaffPosition(ctxt, staffPosition);

    var verticalOffset = 0;
    // First, we need to find the next note in the neume.
    var noteIndex = this.note.neume.notes.indexOf(this.note);
    var nextNote;
    if (noteIndex >= 0) {
      ++noteIndex;
      if (this.note.neume.notes.length > noteIndex) {
        nextNote = this.note.neume.notes[noteIndex];
        if (
          nextNote.morae &&
          nextNote.morae.length &&
          this.note.neume.notes.length === noteIndex + 1
        ) {
          // this note is the second to last in its neume, and the last note also has a mora
          this.horizontalOffset +=
            nextNote.bounds.right() - this.note.bounds.right();
        } else if (nextNote.bounds.right() > this.note.bounds.right()) {
          // center the dot over the following note.
          this.horizontalOffset =
            (nextNote.bounds.right() -
              this.note.bounds.right() -
              this.bounds.right()) /
            2;
        } else {
          nextNote = null;
        }
      } else if (this.note.neume.notes.length === noteIndex) {
        // this note is the last in its neume:
        if (this.note.neume.trailingSpace === 0) {
          // if this was the last note in its neume, we only care about the next note if there is no trailing space at the end of this neume.
          var notationIndex = this.note.neume.score.notations.indexOf(
            this.note.neume
          );
          if (notationIndex >= 0) {
            var nextNotation = this.note.neume.score.notations[
              notationIndex + 1
            ];
            if (nextNotation && nextNotation.notes) {
              nextNote = nextNotation.notes[0];
            }
          }
        } else if (this.note.shape !== NoteShape.Inclinatum) {
          this.note.neume.calculatedTrailingSpace += this.origin.x;
        }
      }
    }

    if (this.positionHint === MarkingPositionHint.Above) {
      if (staffPosition % 2 === 0) verticalOffset -= ctxt.staffInterval * 1.75;
      else verticalOffset -= ctxt.staffInterval * 0.75;
    } else if (this.positionHint === MarkingPositionHint.Below) {
      if (staffPosition % 2 === 0) verticalOffset += ctxt.staffInterval * 1.75;
      else verticalOffset += ctxt.staffInterval * 0.75;
    } else {
      if (staffPosition % 2 === 0) {
        // if the note is in a space and followed by a note on the line below, we often want to move the mora dot up slightly so that it is centered
        // between the top of the note's space and the top of the following note.
        if (nextNote && nextNote.staffPosition === staffPosition - 1) {
          verticalOffset -= ctxt.staffInterval * 0.25;
        }
      } else {
        verticalOffset -= ctxt.staffInterval * 0.75;
      }
    }
    this.bounds.x = this.horizontalOffset + this.note.bounds.right();
    this.bounds.y += verticalOffset;
  }
}

// indicates the shape of the brace
export var BraceShape = {
  RoundBrace: 0,
  CurlyBrace: 1,
  AccentedCurlyBrace: 2
};

// indicates how the brace is alignerd to the note to which it's connected
export var BraceAttachment = {
  Left: 0,
  Right: 1
};

export class BracePoint extends ChantLayoutElement {
  constructor(note, isAbove, shape, attachment) {
    super();

    this.note = note;
    this.isAbove = isAbove;
    this.shape = shape;
    this.attachment = attachment;
  }

  getAttachmentX(note) {
    if (!note) note = this.note;
    if (this.attachment === BraceAttachment.Left)
      return (note.neume ? note.neume.bounds.x : 0) + note.bounds.x;
    else return (note.neume ? note.neume.bounds.x : 0) + note.bounds.right();
  }
}



// WEBPACK FOOTER //
// ./src/Exsurge.Chant.Markings.js","//
// Author(s):
// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
//
// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the \"Software\"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

import { Step } from \"./Exsurge.Core.js\";
import {
  ChantNotationElement, DividerLineVisualizer, GlyphCode,
  GlyphVisualizer
} from \"./Exsurge.Drawing.js\";

/*
 *
 */
export class Custos extends ChantNotationElement {
  // if auto is true, then the custos will automatically try to determine it's height based on
  // subsequent notations
  constructor(auto = false) {
    super();
    this.auto = auto;
    this.staffPosition = 0; // default sane value
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    if (this.auto) {
      var neume = ctxt.findNextNeume();

      if (neume)
        this.staffPosition = ctxt.activeClef.pitchToStaffPosition(
          neume.notes[0].pitch
        );

      // in case there was a weird fa/do clef change, let's sanitize the staffPosition by making sure it is
      // within reasonable bounds
      while (this.staffPosition < -6) this.staffPosition += 7;

      while (this.staffPosition > 6) this.staffPosition -= 7;
    }

    var glyph = new GlyphVisualizer(
      ctxt,
      Custos.getGlyphCode(this.staffPosition)
    );
    glyph.setStaffPosition(ctxt, this.staffPosition);
    this.addVisualizer(glyph);

    this.finishLayout(ctxt);
  }

  // called when layout has changed and our dependencies are no longer good
  resetDependencies() {
    // we only need to resolve new dependencies if we're an automatic custos
    if (this.auto) this.needsLayout = true;
  }

  static getGlyphCode(staffPosition) {
    if (staffPosition <= 2) {
      // ascending custodes
      if (Math.abs(staffPosition) % 2 === 1) return GlyphCode.CustosLong;
      else return GlyphCode.CustosShort;
    } else {
      // descending custodes
      if (Math.abs(staffPosition) % 2 === 1) return GlyphCode.CustosDescLong;
      else return GlyphCode.CustosDescShort;
    }
  }
}

/*
 * Divider
 */
export class Divider extends ChantNotationElement {
  constructor() {
    super();

    this.isDivider = true;
    this.resetsAccidentals = true;
  }
}

/*
 * QuarterBar
 */
export class QuarterBar extends Divider {
  performLayout(ctxt) {
    super.performLayout(ctxt);
    this.addVisualizer(new DividerLineVisualizer(ctxt, 2, 4, this));

    this.origin.x = this.bounds.width / 2;

    this.finishLayout(ctxt);
  }
}

/*
 * HalfBar
 */
export class HalfBar extends Divider {
  performLayout(ctxt) {
    super.performLayout(ctxt);

    this.addVisualizer(new DividerLineVisualizer(ctxt, -2, 2, this));

    this.origin.x = this.bounds.width / 2;

    this.finishLayout(ctxt);
  }
}

/*
 * FullBar
 */
export class FullBar extends Divider {
  performLayout(ctxt) {
    super.performLayout(ctxt);

    this.addVisualizer(new DividerLineVisualizer(ctxt, -3, 3, this));

    this.origin.x = this.bounds.width / 2;

    this.finishLayout(ctxt);
  }
}

/*
 * Insertion Cursor
 */
export class InsertionCursor extends Divider {
  performLayout(ctxt) {
    super.performLayout(ctxt);

    this.addVisualizer(new DividerLineVisualizer(ctxt, -4, 4));

    this.origin.x = this.bounds.width / 2;
    this.bounds.width = 0;
    this.bounds.height = 0;

    this.finishLayout(ctxt);
  }
}

/*
 * DominicanBar
 */
export class DominicanBar extends Divider {
  constructor(staffPosition) {
    super();
    staffPosition--;
    var parity = staffPosition % 2;

    this.staffPosition = staffPosition - 2 * parity;
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);
    this.addVisualizer(
      new DividerLineVisualizer(
        ctxt,
        this.staffPosition - 3,
        this.staffPosition,
        this
      )
    );

    this.origin.x = this.bounds.width / 2;

    this.finishLayout(ctxt);
  }
}

/*
 * DoubleBar
 */
export class DoubleBar extends Divider {
  performLayout(ctxt) {
    super.performLayout(ctxt);

    var line0 = new DividerLineVisualizer(ctxt, -3, 3, this);
    line0.bounds.x = 0;
    this.addVisualizer(line0);

    var line1 = new DividerLineVisualizer(ctxt, -3, 3, this);
    line1.bounds.x = ctxt.intraNeumeSpacing * 2 - line1.bounds.width;
    this.addVisualizer(line1);

    this.origin.x = this.bounds.width / 2;

    this.finishLayout(ctxt);
  }
}

export const AccidentalType = {
  Flat: -1,
  Natural: 0,
  Sharp: 1
};

/*
 * Accidental
 */
export class Accidental extends ChantNotationElement {
  constructor(staffPosition, accidentalType) {
    super();
    this.isAccidental = true;
    this.keepWithNext = true; // accidentals should always stay connected...

    this.staffPosition = staffPosition;
    this.accidentalType = accidentalType;
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    this.addVisualizer(this.createGlyphVisualizer(ctxt));

    this.finishLayout(ctxt);
  }

  // creation of the glyph visualizer is refactored out or performLayout
  // so that clefs can use the same logic for their accidental glyph
  createGlyphVisualizer(ctxt) {
    var glyphCode = GlyphCode.Flat;

    switch (this.accidentalType) {
      case AccidentalType.Natural:
        glyphCode = GlyphCode.Natural;
        break;
      case AccidentalType.Sharp:
        glyphCode = GlyphCode.Sharp;
        break;
      default:
        glyphCode = GlyphCode.Flat;
        break;
    }

    var glyph = new GlyphVisualizer(ctxt, glyphCode);
    glyph.setStaffPosition(ctxt, this.staffPosition);

    return glyph;
  }

  adjustStep(step) {
    switch (this.accidentalType) {
      case AccidentalType.Flat:
        if (step === Step.Ti) return Step.Te;
        if (step === Step.Mi) return Step.Me;
        break;
      case AccidentalType.Sharp:
        if (step === Step.Do) return Step.Du;
        if (step === Step.Fa) return Step.Fu;
        break;
      case AccidentalType.Natural:
        if (step === Step.Te) return Step.Ti;
        if (step === Step.Me) return Step.Mi;
        if (step === Step.Du) return Step.Do;
        if (step === Step.Fu) return Step.Fa;
        break;
    }

    // no adjustment needed
    return step;
  }

  applyToPitch(pitch) {
    // no adjusment needed
    if (this.pitch.octave !== pitch.octave) return;

    pitch.step = this.adjustStep(pitch.step);
  }
}

/*
 * Virgula
 */
export class Virgula extends Divider {
  constructor() {
    super();

    // unlike other dividers a virgula does not reset accidentals
    this.resetsAccidentals = false;

    // the staff position of the virgula is customizable, so that it
    // can be placed on different lines (top or bottom) depending on the
    // notation tradition of what is being notated (e.g., Benedictine has it
    //  on top line, Norbertine at the bottom)
    this.staffPosition = 3;
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    var glyph = new GlyphVisualizer(ctxt, GlyphCode.Virgula);
    glyph.setStaffPosition(ctxt, this.staffPosition);

    this.addVisualizer(glyph);

    this.origin.x = this.bounds.width / 2;

    this.finishLayout(ctxt);
  }
}



// WEBPACK FOOTER //
// ./src/Exsurge.Chant.Signs.js","//
// Author(s):
// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
//
// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the \"Software\"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

import {
  Units,
  Pitch,
  Point,
  Rect,
  Margins,
  Size,
  Step
} from \"./Exsurge.Core.js\";
import {
  MarkingPositionHint,
  LyricType,
  Lyric,
  LyricArray,
  AboveLinesText,
  ChoralSign,
  TranslationText,
  DefaultTrailingSpace,
  GlyphCode
} from \"./Exsurge.Drawing.js\";
import {
  Note,
  LiquescentType,
  NoteShape,
  NoteShapeModifiers,
  ChantMapping,
  ChantScore,
  ChantDocument,
  Clef,
  DoClef,
  FaClef,
  TextOnly,
  ChantLineBreak
} from \"./Exsurge.Chant.js\";
import * as Markings from \"./Exsurge.Chant.Markings.js\";
import * as Signs from \"./Exsurge.Chant.Signs.js\";
import * as Neumes from \"./Exsurge.Chant.Neumes.js\";

// reusable reg exps
var __syllablesRegex = /(?=\\S)((?:<v>[\\s\\S]*<\\/v>|[^(])*)(?:\\(?([^)]*)\\)?)?/g
var __altTranslationRegex = /<alt>(.*?)<\\/alt>|\\[(alt:)?(.*?)\\]/g;

var __notationsRegex = /z0|z|Z|::|:|[,;][1-6]?|`|[cf][1-4]|cb[1-4]|\\/+| |\\!|-?[a-mA-M][oOwWvVrRsxy#~\\+><_\\.'012345]*(?:\\[[^\\]]*\\]?)*|\\{([^}]+)\\}?/g;
var __notationsRegex_group_insideBraces = 1;

var __bracketedCommandRegex = /^([a-z]+):(.*)/;

// for the brace string inside of [ and ] in notation data
// the capturing groups are:
//  1. o or u, to indicate over or under
//  2. b, cb, or cba, to indicate the brace type
//  3. 0 or 1 to indicate the attachment point
//  4. { or } to indicate opening/closing (this group will be null if the metric version is used)
//  5. a float indicating the millimeter length of the brace (not supported yet)
var __braceSpecRegex = /([ou])(b|cb|cba):([01])(?:([{}])|;(\\d*(?:\\.\\d+)?)mm)/;

const TrailingSpaceForAccidental = ctxt =>
  ctxt.intraNeumeSpacing * ctxt.accidentalSpaceMultiplier;
const TrailingSpaceMultiple = multiplier => ctxt =>
  ctxt.intraNeumeSpacing * multiplier;

const regexHeaderEnd = /(?:^|\
)%%\\s?\
/;
const regexHeaderLine = /^([\\w-_.]+):\\s*((?:[^;\\r\
]|;[ \	])*)(?:;|$)/i;
const regexHeaderComment = /^%.*/;
export class GabcHeader {
  static getLength(gabc) {
    let match = gabc.match(regexHeaderEnd);
    return match ? match.index + match[0].length : 0;
  }

  constructor(text) {
    if (typeof text !== \"string\") text = \"\";
    this.comments = [];
    this.cValues = {};
    this.original = \"\";
    let match = text.match(regexHeaderEnd);
    if (match) {
      let txtHeader = (this.original = text.slice(
        0,
        match.index + match[0].length
      ));
      var lines = txtHeader.split(/\\r?\
/g);
      for (var i = 0; i < lines.length; ++i) {
        let line = lines[i],
          match = regexHeaderLine.exec(line);
        if (match) {
          var key = match[1].replace(/-([a-z])/g, function(a, letter) {
            return letter.toUpperCase();
          });
          if (this[match[1]]) {
            var arrayName = match[1] + \"Array\";
            if (!this[arrayName]) {
              this[arrayName] = [this[match[1]]];
            }
            this[arrayName].push(match[2]);
          } else {
            this[match[1]] = match[2];
          }
          if (key !== match[1]) this[key] = this[match[1]];
        } else if ((match = regexHeaderComment.exec(line))) {
          if (line !== \"%%\") {
            match = regexHeaderLine.exec(line.slice(1));
            if (match) {
              let key = match[1].replace(/-([a-z])/g, function(a, letter) {
                return letter.toUpperCase();
              });
              this.cValues[match[1]] = match[2];
              if (key !== match[1]) this.cValues[key] = match[2];
            } else {
              this.comments[i] = line;
            }
          }
        }
      }
    }
  }

  toString() {
    var result = [];
    for (let key in this) {
      if (
        typeof this[key] !== \"string\" ||
        /^(length|original|comments|cValues)$/.test(key)
      ) {
        continue;
      }
      var alternateKey = key.replace(/[A-Z]/g, function(letter) {
        return \"-\" + letter.toLowerCase();
      });
      if (alternateKey !== key && alternateKey in this) continue;
      var array = this[key + \"Array\"];
      if (array) {
        for (var i = 0; i < array.length; ++i) {
          result.push(key + \": \" + array[i] + \";\");
        }
      } else {
        result.push(key + \": \" + this[key] + \";\");
      }
    }
    for (let key in this.cValues) {
      if (key.length === 0 || !this.cValues.hasOwnProperty(key)) continue;
      result.push(\"%\" + key + \": \" + this.cValues[key] + \";\");
    }
    for (let i in this.comments) {
      if (!this.comments.hasOwnProperty(i)) continue;
      try {
        result.splice(i, 0, this.comments[i]);
      } catch (e) {
        console.warn(e);
      }
    }
    return result.join(\"\
\") + \"\
%%\
\";
  }
}

var elementCountForNotations = items =>
  items.reduce((sum, item) => sum + (item.notes ? item.notes.length : 1), 0);

export class Gabc {
  // takes gabc source code (without the header info) and returns an array
  // of ChantMappings describing the chant. A chant score can then be created
  // fron the chant mappings and later updated via updateMappings() if need
  // be...
  static createMappingsFromSource(ctxt, gabcSource) {
    var headerLength = GabcHeader.getLength(gabcSource);
    gabcSource = gabcSource.slice(headerLength);
    var words = this.splitWords(gabcSource);

    // set the default clef
    ctxt.activeClef = Clef.default();

    var mappings = this.createMappingsFromWords(
      ctxt,
      words,
      clef => (ctxt.activeClef = clef)
    );

    // always set the last notation to have a trailingSpace of 0. This makes layout for the last chant line simpler
    if (
      mappings.length > 0 &&
      mappings[mappings.length - 1].notations.length > 0
    )
      mappings[mappings.length - 1].notations[
        mappings[mappings.length - 1].notations.length - 1
      ].trailingSpace = 0;

    return mappings;
  }

  // A simple general purpose diff algorithm adapted here for comparing
  // an array of existing mappings with an updated list of gabc words.
  // note before is an array of mappings, and after is an array of strings
  // (gabc words).
  //
  // This is definitely not the most effecient diff algorithm, but for our
  // limited needs and source size it seems to work just fine...
  //
  // code is adapted from: https://github.com/paulgb/simplediff
  //
  // Returns:
  //   A list of pairs, with the first part of the pair being one of three
  //   strings ('-', '+', '=') and the second part being a list of values from
  //   the original before and/or after lists. The first part of the pair
  //   corresponds to whether the list of values is a deletion, insertion, or
  //   unchanged, respectively.
  static diffDescriptorsAndNewWords(before, after) {
    // Create a map from before values to their indices
    var oldIndexMap = {},
      i;
    for (i = 0; i < before.length; i++) {
      oldIndexMap[before[i].source] = oldIndexMap[before[i].source] || [];
      oldIndexMap[before[i].source].push(i);
    }

    var overlap = [],
      startOld,
      startNew,
      subLength,
      inew;

    startOld = startNew = subLength = 0;

    for (inew = 0; inew < after.length; inew++) {
      var _overlap = [];
      oldIndexMap[after[inew]] = oldIndexMap[after[inew]] || [];
      for (i = 0; i < oldIndexMap[after[inew]].length; i++) {
        var iold = oldIndexMap[after[inew]][i];
        // now we are considering all values of val such that
        // `before[iold] == after[inew]`
        _overlap[iold] = ((iold && overlap[iold - 1]) || 0) + 1;
        if (_overlap[iold] > subLength) {
          // this is the largest substring seen so far, so store its indices
          subLength = _overlap[iold];
          startOld = iold - subLength + 1;
          startNew = inew - subLength + 1;
        }
      }
      overlap = _overlap;
    }

    if (subLength === 0) {
      // If no common substring is found, we return an insert and delete...
      var result = [];

      if (before.length) result.push([\"-\", before]);

      if (after.length) result.push([\"+\", after]);

      return result;
    }

    // ...otherwise, the common substring is unchanged and we recursively
    // diff the text before and after that substring
    return [].concat(
      this.diffDescriptorsAndNewWords(
        before.slice(0, startOld),
        after.slice(0, startNew)
      ),
      [[\"=\", after.slice(startNew, startNew + subLength)]],
      this.diffDescriptorsAndNewWords(
        before.slice(startOld + subLength),
        after.slice(startNew + subLength)
      )
    );
  }

  // this function essentially performs and applies a rudimentary diff between a
  // previously parsed set of mappings and between a new gabc source text.
  // the mappings array passed in is changed in place to be updated from the
  // new source
  static updateMappingsFromSource(
    ctxt,
    mappings,
    newGabcSource,
    insertionIndex = null,
    oldInsertionIndex = null
  ) {
    var headerLength = GabcHeader.getLength(newGabcSource);
    newGabcSource = newGabcSource.slice(headerLength);
    // always remove the last old mapping since it's spacing/trailingSpace is handled specially
    mappings.pop();

    if (insertionIndex === null) {
      insertionIndex = NaN;
    }
    if (oldInsertionIndex === null) {
      oldInsertionIndex = NaN;
    }

    var newWords = this.splitWords(newGabcSource);

    var results = this.diffDescriptorsAndNewWords(mappings, newWords);

    var index = 0,
      j,
      k,
      l,
      sourceIndex = 0,
      wordLength = 0,
      mapping,
      elementIndex = 0;

    ctxt.activeClef = Clef.default();

    // apply the results to the mappings, marking notations that need to be processed
    var lastTranslationNeumes = [];
    for (var i = 0; i < results.length; i++) {
      var resultCode = results[i][0];
      var resultValues = results[i][1];

      if (index > 0)
        sourceIndex =
          mappings[index - 1].sourceIndex +
          mappings[index - 1].source.length +
          1;
      if (resultCode === \"=\") {
        var sourceIndexDiff = sourceIndex - mappings[index].sourceIndex;
        // skip over ones that haven't changed, but updating the clef and source
        // index (and pitch in case clef or accidentals have changed) as we go
        for (j = 0; j < resultValues.length; j++, index++) {
          mapping = mappings[index];
          if (
            elementIndex === 0 &&
            mapping.notations.length &&
            mapping.notations[0].isClef
          ) {
            // the first clef doesn't get kept as a notation:
            elementIndex = -1;
          }
          if (
            insertionIndex >= elementIndex ||
            oldInsertionIndex >= elementIndex
          ) {
            // check if the insertion index is within this mapping:
            let elementCount = elementCountForNotations(mapping.notations);
            if (
              (insertionIndex >= elementIndex &&
                insertionIndex < elementIndex + elementCount) ||
              (oldInsertionIndex >= elementIndex &&
                oldInsertionIndex < elementIndex + elementCount)
            ) {
              // re-do this mapping:
              // TODO: check sourceIndex
              let sourceIndex = mapping.sourceIndex + sourceIndexDiff;
              mapping = this.createMappingFromWord(
                ctxt,
                resultValues[j],
                sourceIndex,
                lastTranslationNeumes,
                insertionIndex - elementIndex
              );
              mappings.splice(index, 1, mapping);

              elementIndex += elementCount;
              continue;
            }
            elementIndex += elementCount;
          }
          mapping.sourceIndex += sourceIndexDiff;
          for (k = 0; k < mapping.notations.length; k++) {
            var curNotation = mapping.notations[k];
            var prevIsAccidental =
              mapping.notations[k - 1] && mapping.notations[k - 1].isAccidental;
            // notify the notation that its dependencies are no longer valid
            curNotation.resetDependencies();

            if (curNotation.isClef) {
              ctxt.activeClef = mappings[index].notations[k];
            }

            if (curNotation.isAccidental) {
              ctxt.activeClef.activeAccidental = curNotation;
            } else if (
              curNotation.resetsAccidentals ||
              (!prevIsAccidental &&
                curNotation.hasLyrics() &&
                curNotation.lyrics[0].lyricType <= LyricType.BeginningSyllable)
            ) {
              ctxt.activeClef.resetAccidentals();
            }

            // update source index, pitch, and automatic braces
            if (curNotation.notes) {
              for (l = 0; l < curNotation.notes.length; ++l) {
                let note = curNotation.notes[l];
                note.sourceIndex += sourceIndexDiff;
                note.pitch = ctxt.activeClef.staffPositionToPitch(
                  note.staffPosition
                );
                if (note.braceEnd && note.braceEnd.automatic)
                  delete note.braceEnd;
                if (this.needToEndBrace && !note.braceStart && !note.braceEnd) {
                  note.braceEnd = new Markings.BracePoint(
                    note,
                    this.needToEndBrace.isAbove,
                    this.needToEndBrace.shape,
                    this.needToEndBrace.attachment ===
                    Markings.BraceAttachment.Left
                      ? Markings.BraceAttachment.Right
                      : Markings.BraceAttachment.Left
                  );
                  note.braceEnd.automatic = true;
                  delete this.needToEndBrace;
                } else if (note.braceStart && note.braceStart.automatic) {
                  this.needToEndBrace = note.braceStart;
                }
              }
            }
            if (curNotation.translationText) {
              for (l = 0; l < curNotation.translationText.length; ++l) {
                let transText = curNotation.translationText[l];
                delete transText.endNeume;
                curNotation.translationText[l].sourceIndex += sourceIndexDiff;
                if (
                  transText.textAnchor === \"end\" &&
                  lastTranslationNeumes[0]
                ) {
                  let lastTranslationText =
                    lastTranslationNeumes[0].translationText[l];
                  if (lastTranslationText)
                    lastTranslationText.endNeume = curNotation;
                }
              }
              lastTranslationNeumes[0] = curNotation;
            }
            if (sourceIndexDiff) {
              if (typeof curNotation.sourceIndex === \"number\") {
                curNotation.sourceIndex += sourceIndexDiff;
              }
              for (l = 0; l < curNotation.lyrics.length; ++l) {
                curNotation.lyrics[l].sourceIndex += sourceIndexDiff;
              }
              if (curNotation.alText) {
                for (l = 0; l < curNotation.alText.length; ++l) {
                  curNotation.alText[l].sourceIndex += sourceIndexDiff;
                }
              }
            }
          }
        }
      } else if (resultCode === \"-\") {
        // delete elements that no longer exist, but first notify all
        // elements of the change
        mappings.splice(index, resultValues.length);
      } else if (resultCode === \"+\") {
        // insert new ones
        for (j = 0; j < resultValues.length; j++) {
          wordLength = resultValues[j].length + 1;
          mapping = this.createMappingFromWord(
            ctxt,
            resultValues[j],
            sourceIndex,
            lastTranslationNeumes,
            insertionIndex - elementIndex
          );

          if (
            elementIndex === 0 &&
            mapping.notations.length &&
            mapping.notations[0].isClef
          ) {
            // the first clef doesn't get kept as a notation:
            elementIndex = -1;
            let elementCount = elementCountForNotations(mapping.notations);
            if (insertionIndex < elementCount) {
              // re-do the first mapping, because it was broken up incorrectly, due to the presence of the initial clef
              mapping = this.createMappingFromWord(
                ctxt,
                resultValues[j],
                sourceIndex,
                lastTranslationNeumes,
                insertionIndex - elementIndex
              );
            }
          }

          for (k = 0; k < mapping.notations.length; k++) {
            let curNotation = mapping.notations[k];
            elementIndex += curNotation.notes ? curNotation.notes.length : 1;
            if (curNotation.isClef) {
              ctxt.activeClef = mapping.notations[k];
            }
          }

          mappings.splice(index++, 0, mapping);
          sourceIndex += wordLength;
        }
      }
    }

    // always set the last notation to have a trailingSpace of 0. This makes layout for the last chant line simpler
    if (
      mappings.length > 0 &&
      mappings[mappings.length - 1].notations.length > 0
    )
      mappings[mappings.length - 1].notations[
        mappings[mappings.length - 1].notations.length - 1
      ].trailingSpace = 0;

    return headerLength;
  }

  // takes an array of gabc words (like that returned by splitWords below)
  // and returns an array of ChantMapping objects, one for each word.
  static createMappingsFromWords(ctxt, words) {
    var mappings = [];
    var sourceIndex = 0,
      wordLength = 0,
      lastTranslationNeumes = [];

    for (var i = 0; i < words.length; i++) {
      sourceIndex += wordLength;
      wordLength = words[i].length + 1;
      var word = words[i].trim();

      if (word === \"\") continue;

      var mapping = this.createMappingFromWord(
        ctxt,
        word,
        sourceIndex,
        lastTranslationNeumes
      );

      if (mapping) mappings.push(mapping);
    }

    return mappings;
  }

  // takes a gabc word (like those returned by splitWords below) and returns
  // a ChantMapping object that contains the gabc word source text as well
  // as the generated notations.
  static createMappingFromWord(
    ctxt,
    word,
    sourceIndex,
    lastTranslationNeumes,
    insertionIndex
  ) {
    var matches = [];
    var notations = [];
    var currSyllable = 0;

    while ((match = __syllablesRegex.exec(word))) matches.push(match);

    for (var j = 0; j < matches.length; j++) {
      var match = matches[j];

      var lyricText = match[1].replace(
        /(^|<\\/sp>)([\\s\\S]*?)($|<sp>)/g,
        (_, pre, main, post) => `${pre}${main.replace(/~/g, \" \")}${post}`
      );
      var alText = [];
      var translationText = [];
      var notationData = match[2];

      // new words reset the accidentals, per the Solesmes style (see LU xviij)
      // but we need to also make sure that there _is_ a word and that it has notes associated with it.
      if (
        currSyllable === 0 &&
        /[a-z]/i.test(lyricText) &&
        /[a-m]/i.test(notationData)
      )
        ctxt.activeClef.resetAccidentals();

      var items = this.parseNotations(
        ctxt,
        notationData,
        sourceIndex + match.index + match[1].length + 1,
        insertionIndex
      );

      if (items.length === 0) continue;

      if (insertionIndex >= 0)
        insertionIndex -= elementCountForNotations(items);

      items[0].firstOfSyllable = !!lyricText;
      items[0].firstOfParentheses = true;
      notations.push(...items);

      // add the lyrics and/or alText to the first notation that makes sense...
      var notationWithLyrics = null;
      for (var i = 0; i < items.length; i++) {
        var cne = items[i];

        if (cne.isAccidental && i + 1 < items.length) continue;

        notationWithLyrics = cne;
        break;
      }

      var m = __altTranslationRegex.exec();
      let indexOffset = 0;
      while ((m = __altTranslationRegex.exec(lyricText))) {
        let index = m.index;
        lyricText =
          lyricText.slice(0, index) + lyricText.slice(index + m[0].length);
        index += sourceIndex + indexOffset + 1;
        if (typeof m[1] === \"string\") {
          let elem = new AboveLinesText(
            ctxt,
            m[1],
            notationWithLyrics,
            index + 4
          );
          elem.alIndex = alText.push(elem) - 1;
        } else if (typeof m[2] === \"string\") {
          let elem = new AboveLinesText(
            ctxt,
            m[3],
            notationWithLyrics,
            index + m[2].length
          );
          elem.alIndex = alText.push(elem) - 1;
        } else {
          let elem = new TranslationText(ctxt, m[3], notationWithLyrics, index);
          elem.translationIndex = translationText.push(elem) - 1;
        }
        indexOffset += m[0].length;
        __altTranslationRegex.exec();
      }
      if (lyricText === \"\" && alText.length === 0) continue;

      if (notationWithLyrics === null)
        return new ChantMapping(word, notations, sourceIndex);

      if (alText.length) notationWithLyrics.alText = alText;

      if (translationText.length) {
        notationWithLyrics.translationText = translationText;
        for (i = 0; i < translationText.length; ++i) {
          let transText = translationText[i];
          if (transText.textAnchor === \"end\" && lastTranslationNeumes[0]) {
            let lastTranslationText =
              lastTranslationNeumes[0].translationText[i];
            if (lastTranslationText)
              lastTranslationText.endNeume = notationWithLyrics;
          }
        }
        lastTranslationNeumes[0] = notationWithLyrics;
      }

      if (lyricText === \"\") continue;

      var proposedLyricType;

      // if it's not a neume or a TextOnly notation, then make the lyrics a directive
      if (!cne.isNeume && cne.constructor !== TextOnly)
        proposedLyricType = LyricType.Directive;
      // otherwise trye to guess the lyricType for the first lyric anyway
      else if (currSyllable === 0 && j === matches.length - 1)
        proposedLyricType = LyricType.SingleSyllable;
      else if (currSyllable === 0 && j < matches.length - 1)
        proposedLyricType = LyricType.BeginningSyllable;
      else if (j === matches.length - 1)
        proposedLyricType = LyricType.EndingSyllable;
      else proposedLyricType = LyricType.MiddleSyllable;

      currSyllable++;

      var lyrics = this.createSyllableLyrics(
        ctxt,
        lyricText,
        proposedLyricType,
        notationWithLyrics,
        items,
        sourceIndex + match.index
      );

      if (lyrics === null || lyrics.length === 0) continue;

      notationWithLyrics.lyrics = lyrics;
    }

    return new ChantMapping(word, notations, sourceIndex);
  }

  // returns an array of lyrics (an array because each syllable can have multiple lyrics)
  static createSyllableLyrics(
    ctxt,
    text,
    proposedLyricType,
    notation,
    notations,
    sourceIndex
  ) {
    var lyrics = [];

    // an extension to gabc: multiple lyrics per syllable can be separated by a |
    var lyricTexts = text.split(\"|\");

    for (var i = 0; i < lyricTexts.length; i++) {
      var lyricText = lyricTexts[i];

      if (i > 0) {
        if (lyricText.match(/\\s$/)) {
          lyricText = lyricText.replace(/s+$/, \"\");
          proposedLyricType = LyricType.EndingSyllable;
        } else {
          proposedLyricType = LyricType.MiddleSyllable;
        }
      }

      // gabc allows lyrics to indicate the centering part of the text by
      // using braces to indicate how to center the lyric. So a lyric can
      // look like \"f{i}re\" or \"{fenced}\" to center on the i or on the entire
      // word, respectively. Here we determine if the lyric should be spaced
      // manually with this method of using braces.
      // however, we don't want to consider any braces inside of v tags, so we
      // do a bit of text processing here:
      var lyricTextWithoutVTags = lyricText;
      const vtagRegex = /<v>[\\s\\S]*?<\\/v>/;
      let match;
      const vtags = [];
      while ((match = vtagRegex.exec(lyricTextWithoutVTags))) {
        let index = match.index;
        let length = match[0].length;
        vtags[index] = length;
        lyricTextWithoutVTags = lyricTextWithoutVTags.slice(0, index) + lyricTextWithoutVTags.slice(index + length);
      }
      var centerStartIndex = lyricTextWithoutVTags.indexOf(\"{\");
      var centerLength = 0;

      if (centerStartIndex >= 0) {
        let indexClosingBracket = lyricTextWithoutVTags.indexOf(\"}\");

        if (
          indexClosingBracket >= 0 &&
          indexClosingBracket > centerStartIndex
        ) {
          const getTrueIndex = (indexWithoutVTags) => {
            // map indices back to the lyricText with the V tags:
            let accum = 0;
            for (let index in vtags) {
              if (vtags.hasOwnProperty(index) && indexWithoutVTags >= index) {
                accum += vtags[index];
              } else {
                break;
              }
            }
            return indexWithoutVTags + accum;
          }
          centerStartIndex = getTrueIndex(centerStartIndex);
          indexClosingBracket = getTrueIndex(indexClosingBracket);
          centerLength = indexClosingBracket - centerStartIndex - 1;

          // strip out the brackets:
          lyricText =
            lyricText.substring(0, centerStartIndex) +
            lyricText.substring(centerStartIndex + 1, indexClosingBracket) +
            lyricText.substring(indexClosingBracket + 1, lyricText.length);
        } else centerStartIndex = -1; // if there's no closing bracket, don't enable centering
      }

      var lyric = this.makeLyric(
        ctxt,
        lyricText,
        proposedLyricType,
        notation,
        notations,
        sourceIndex
      );

      if (centerStartIndex >= 0) {
        // update indices in case there had been any tags, etc.
        let textIndex = 0,
          centerEndIndex = -1;
        for (let span of lyric.spans) {
          if (
            centerStartIndex >= span.index &&
            centerStartIndex <= span.index + span.text.length
          ) {
            centerEndIndex = centerStartIndex + centerLength;
            centerStartIndex += textIndex - span.index;
          }
          if (
            centerEndIndex >= 0 &&
            centerEndIndex >= span.index &&
            centerEndIndex <= span.index + span.text.length
          ) {
            centerEndIndex += textIndex - span.index;
            centerLength = centerEndIndex - centerStartIndex;
            centerEndIndex = -1;
            break;
          }
          textIndex += span.text.length;
        }
        if (centerEndIndex >= 0) {
          centerEndIndex = textIndex;
          centerLength = centerEndIndex - centerStartIndex;
        }
      }

      // if we have manual lyric centering, then set it now
      if (centerStartIndex >= 0) {
        lyric.centerStartIndex = centerStartIndex;
        lyric.centerLength = centerLength;
      }

      lyric.lyricIndex = lyrics.push(lyric) - 1;
      sourceIndex += lyricText.length + 1;
    }
    notation.lyrics = lyrics;
    return lyrics;
  }

  static makeLyric(ctxt, text, lyricType, notation, notations, sourceIndex) {
    var elides = false;
    var forceConnector = false;
    if (text.length > 1) {
      if (text[text.length - 1] === \"-\") {
        forceConnector = true;
        if (lyricType === LyricType.EndingSyllable)
          lyricType = LyricType.MiddleSyllable;
        else if (lyricType === LyricType.SingleSyllable)
          lyricType = LyricType.BeginningSyllable;

        text = text.slice(0, -1);
      } else if (text[text.length - 1] === \" \") {
        if (lyricType === LyricType.MiddleSyllable)
          lyricType = LyricType.EndingSyllable;
        else if (lyricType === LyricType.BeginningSyllable)
          lyricType = LyricType.SingleSyllable;

        text = text.slice(0, -1);
      } else if (/<\\/i>$/.test(text)) {
        // must be an elision
        elides = true;
      }
    }

    if (text.match(/^(?:[*†]+|i+j|\\d+)\\.?$/)) lyricType = LyricType.Directive;

    var lyric = new Lyric(
      ctxt,
      text,
      lyricType,
      notation,
      notations,
      sourceIndex
    );
    lyric.elidesToNext = elides;
    if (forceConnector) lyric.setForceConnector(true);

    return lyric;
  }

  // takes a string of gabc notations and creates exsurge objects out of them.
  // returns an array of notations.
  static parseNotations(ctxt, data, sourceIndex, insertionIndex) {
    // if there is no data, then this must be a text only object
    if (!data) return [new TextOnly(sourceIndex, 0)];

    var baseSourceIndex = sourceIndex;
    var sourceLength = 0;
    var notations = [];
    var notes = [];
    var trailingSpace = DefaultTrailingSpace;

    var addToLastSourceGabc = gabc => {
      if (notes.length > 0) {
        notes[notes.length - 1].sourceGabc += gabc;
      }
    };
    var addNotation = notation => {
      // first, if we have any notes left over, we create a neume out of them
      if (notes.length > 0) {
        // create neume(s)
        var neumes = this.createNeumesFromNotes(ctxt, notes, trailingSpace);
        for (var i = 0; i < neumes.length; i++) notations.push(neumes[i]);

        notes = [];
      }

      // reset the trailing space
      trailingSpace = DefaultTrailingSpace;

      // then, if we're passed a notation, let's add it
      // also, perform chant logic here
      if (notation !== null) {
        let prevNotation = notations[notations.length - 1];
        notation.sourceIndex = sourceIndex;
        notation.sourceGabc = match[0];
        if (notation.isClef) {
          ctxt.activeClef = notation;
          if (
            prevNotation &&
            prevNotation.trailingSpace.isDefault &&
            prevNotation.isDivider
          ) {
            prevNotation.trailingSpace = TrailingSpaceForAccidental;
          }
        } else if (notation.isAccidental) {
          ctxt.activeClef.activeAccidental = notation;
        } else if (
          notation.trailingSpace.isDefault &&
          notation instanceof Signs.Custos
        ) {
          notation.trailingSpace = TrailingSpaceForAccidental;
        } else if (notation.resetsAccidentals)
          ctxt.activeClef.resetAccidentals();

        notations.push(notation);
      }
    };

    var regex = new RegExp(__notationsRegex.source, \"g\");
    var match;

    while ((match = regex.exec(data))) {
      sourceIndex = baseSourceIndex + match.index;
      sourceLength = match[0].length;
      var atom = match[0];

      // handle the clefs and dividers here
      switch (atom) {
        case \",\":
          addNotation(new Signs.QuarterBar());
          break;
        case \"`\":
          addNotation(new Signs.Virgula());
          break;
        case \";\":
          addNotation(new Signs.HalfBar());
          break;
        case \";1\":
        case \";2\":
        case \";3\":
        case \";4\":
        case \";5\":
        case \";6\":
        case \",1\":
        case \",2\":
        case \",3\":
        case \",4\":
        case \",5\":
        case \",6\":
          addNotation(new Signs.DominicanBar(parseInt(atom[1], 10)));
          break;
        case \":\":
          addNotation(new Signs.FullBar());
          break;
        case \"::\":
          addNotation(new Signs.DoubleBar());
          break;
        // other gregorio dividers are not supported yet

        case \"c1\":
          addNotation((ctxt.activeClef = new DoClef(-3, 2)));
          break;

        case \"c2\":
          addNotation((ctxt.activeClef = new DoClef(-1, 2)));
          break;

        case \"c3\":
          addNotation((ctxt.activeClef = new DoClef(1, 2)));
          break;

        case \"c4\":
          addNotation((ctxt.activeClef = new DoClef(3, 2)));
          break;

        case \"f1\":
          addNotation((ctxt.activeClef = new FaClef(-3, 2)));
          break;

        case \"f2\":
          addNotation((ctxt.activeClef = new FaClef(-1, 2)));
          break;

        case \"f3\":
          addNotation((ctxt.activeClef = new FaClef(1, 2)));
          break;

        case \"f4\":
          addNotation((ctxt.activeClef = new FaClef(3, 2)));
          break;

        case \"cb1\":
          addNotation(
            (ctxt.activeClef = new DoClef(
              -3,
              2,
              new Signs.Accidental(-4, Signs.AccidentalType.Flat)
            ))
          );
          break;

        case \"cb2\":
          addNotation(
            (ctxt.activeClef = new DoClef(
              -1,
              2,
              new Signs.Accidental(-2, Signs.AccidentalType.Flat)
            ))
          );
          break;

        case \"cb3\":
          addNotation(
            (ctxt.activeClef = new DoClef(
              1,
              2,
              new Signs.Accidental(0, Signs.AccidentalType.Flat)
            ))
          );
          break;

        case \"cb4\":
          addNotation(
            (ctxt.activeClef = new DoClef(
              3,
              2,
              new Signs.Accidental(2, Signs.AccidentalType.Flat)
            ))
          );
          break;

        case \"z\":
          addNotation(new ChantLineBreak(true));
          break;
        case \"Z\":
          addNotation(new ChantLineBreak(false));
          break;
        case \"z0\":
          addNotation(new Signs.Custos(true));
          break;

        // spacing indicators
        case \"!\":
          trailingSpace = 0;
          addToLastSourceGabc(atom);
          addNotation(null);
          break;
        case \" \":
          // fixme: is this correct? logically what is the difference in gabc
          // between putting a space between notes vs putting '//' between notes?
          trailingSpace = TrailingSpaceMultiple(2);
          addToLastSourceGabc(atom);
          addNotation(null);
          break;

        default:
          // might be a number of slashes, a custos, might be an accidental, or might be a note
          if (atom[0] === \"/\") {
            trailingSpace = TrailingSpaceMultiple(atom.length);
            addToLastSourceGabc(atom);
            addNotation(null);
          } else if (atom.length > 1 && atom[1] === \"+\") {
            // custos
            var custos = new Signs.Custos();

            custos.staffPosition = this.gabcHeightToExsurgeHeight(atom[0]);

            addNotation(custos);
          } else if (atom.length > 1 && /[xy#]/.test(atom[1])) {
            var accidentalType;

            switch (atom[1]) {
              case \"y\":
                accidentalType = Signs.AccidentalType.Natural;
                break;
              case \"#\":
                accidentalType = Signs.AccidentalType.Sharp;
                break;
              default:
                accidentalType = Signs.AccidentalType.Flat;
                break;
            }

            var noteArray = [];
            this.createNoteFromData(
              ctxt,
              ctxt.activeClef,
              atom,
              noteArray,
              sourceIndex
            );
            var accidental = new Signs.Accidental(
              noteArray[0].staffPosition,
              accidentalType
            );
            accidental.pitch = this.gabcHeightToExsurgePitch(
              ctxt.activeClef,
              atom[0]
            );
            accidental.sourceIndex = sourceIndex;
            accidental.sourceLength = sourceLength;
            accidental.trailingSpace = TrailingSpaceForAccidental;

            ctxt.activeClef.activeAccidental = accidental;

            addNotation(accidental);
          } else if (atom.length > 1 && atom[0] === \"{\") {
            trailingSpace = 0;
            addNotation(null);
            let bracketedNotations = this.parseNotations(
              ctxt,
              match[__notationsRegex_group_insideBraces],
              sourceIndex + 1
            );
            // Set the width of these notations to 0
            bracketedNotations.forEach(neume => {
              neume.hasNoWidth = true;
              neume.firstWithNoWidth = bracketedNotations[0];
            });
            notations.push(...bracketedNotations);
          } else {
            // looks like it's a note
            if (insertionIndex === -1) {
              trailingSpace = TrailingSpaceMultiple(1);
              addNotation(null);
            }
            this.createNoteFromData(
              ctxt,
              ctxt.activeClef,
              atom,
              notes,
              sourceIndex
            );
            --insertionIndex;
          }
          break;
      }
    }

    // finish up any remaining notes we have left
    addNotation(null);

    return notations;
  }

  static createNeumesFromNotes(ctxt, notes, finalTrailingSpace) {
    var neumes = [];
    var firstNoteIndex = 0;
    var currNoteIndex = 0;

    // here we use a simple finite state machine to create the neumes from the notes
    // createNeume is helper function which returns the next state after a neume is created
    // (unknownState). Each state object has a neume() function and a handle() function.
    // neume() allows us to create the neume of the state in the event that we run out
    // of notes. handle() gives the state an opportunity to examine the currNote and
    // determine what to do...either transition to a different neume/state, or
    // continue building the neume of that state. handle() returns the next state

    var createNeume = function(neume, includeCurrNote, includePrevNote = true) {
      // add the notes to the neume
      var lastNoteIndex;
      if (includeCurrNote) lastNoteIndex = currNoteIndex;
      else if (includePrevNote) lastNoteIndex = currNoteIndex - 1;
      else lastNoteIndex = currNoteIndex - 2;

      if (lastNoteIndex < 0) return;

      while (firstNoteIndex <= lastNoteIndex) {
        let note = notes[firstNoteIndex++];
        neume.addNote(note);
        if (note.alText) {
          if (!neume.alText) neume.alText = [];
          neume.alText.push(note.alText);
          note.alText.noteIndex = firstNoteIndex - 1;
        }
      }

      neumes.push(neume);

      if (includeCurrNote === false) {
        currNoteIndex--;

        if (includePrevNote === false) currNoteIndex--;

        neume.keepWithNext = true;
        if (notes[currNoteIndex + 1].shape === NoteShape.Quilisma)
          neume.trailingSpace = 0;
        else {
          neume.trailingSpace = TrailingSpaceMultiple(1);
          neume.allowLineBreakBeforeNext = true;
        }
      }

      return unknownState;
    };

    var unknownState = {
      neume: function() {
        return new Neumes.Punctum();
      },
      handle: function(currNote, prevNote) {
        if (currNote.shape === NoteShape.Virga) return virgaState;
        else if (currNote.shape === NoteShape.Stropha) return apostrophaState;
        else if (currNote.shape === NoteShape.Oriscus) return oriscusState;
        else if (currNote.shape === NoteShape.Inclinatum)
          return punctaInclinataState;
        else if (currNote.shapeModifiers & NoteShapeModifiers.Cavum)
          return createNeume(new Neumes.Punctum(), true);
        else return punctumState;
      }
    };

    var punctumState = {
      neume: function() {
        return new Neumes.Punctum();
      },
      handle: function(currNote, prevNote, notesRemaining) {
        if (currNote.shape || prevNote.liquescent === LiquescentType.Small) {
          var neume = new Neumes.Punctum();
          var state = createNeume(neume, false);
          // if the current note is on a space within the staff AND the previous note is on the line below AND the previous note has a mora,
          // then we went the trailing space at its default of intraNeumeSpacing to prevent the dot from running up into the current note.
          // Otherwise, we want no trailing space.
          if (
            currNote.staffPosition > prevNote.staffPosition &&
            (currNote.staffPosition % 2 === 1 ||
              prevNote.staffPosition !== currNote.staffPosition - 1 ||
              !prevNote.morae ||
              prevNote.morae.length === 0)
          )
            neume.trailingSpace = 0;
          return state;
        }

        if (currNote.staffPosition > prevNote.staffPosition) {
          if (currNote.ictus)
            currNote.ictus.positionHint = MarkingPositionHint.Above;
          return podatusState;
        } else if (currNote.staffPosition < prevNote.staffPosition) {
          if (prevNote.ictus)
            prevNote.ictus.positionHint = MarkingPositionHint.Above;
          if (currNote.shape === NoteShape.Inclinatum) return climacusState;
          else if (prevNote.staffPosition - currNote.staffPosition <= 4) {
            return clivisState;
          }
        } else if (!prevNote.morae || !prevNote.morae.length) {
          return distrophaState;
        }
        return createNeume(new Neumes.Punctum(), false);
      }
    };

    var punctaInclinataState = {
      neume: function() {
        return new Neumes.PunctaInclinata();
      },
      handle: function() {
        if (currNote.shape !== NoteShape.Inclinatum)
          return createNeume(new Neumes.PunctaInclinata(), false);
        else return punctaInclinataState;
      }
    };

    var oriscusState = {
      neume: function() {
        return new Neumes.Oriscus();
      },
      handle: function(currNote, prevNote) {
        if (currNote.shape === NoteShape.Default) {
          if (currNote.staffPosition > prevNote.staffPosition) {
            prevNote.shapeModifiers |= NoteShapeModifiers.Ascending;
            return createNeume(new Neumes.PesQuassus(), true);
          } else if (currNote.staffPosition < prevNote.staffPosition) {
            prevNote.shapeModifiers |= NoteShapeModifiers.Descending;
            return createNeume(new Neumes.Clivis(), true);
          }
        }
        // stand alone oriscus
        var neume = new Neumes.Oriscus(),
          state = createNeume(neume, false);
        // if the current note is on a space within the staff AND the previous note is on the line below AND the previous note has a mora,
        // then we went the trailing space at its default of intraNeumeSpacing to prevent the dot from running up into the current note.
        // Otherwise, we want no trailing space.
        if (
          currNote.staffPosition > prevNote.staffPosition &&
          (currNote.staffPosition % 2 === 1 ||
            prevNote.staffPosition !== currNote.staffPosition - 1 ||
            !prevNote.morae ||
            prevNote.morae.length === 0)
        )
          neume.trailingSpace = 0;
        return state;
      }
    };

    var podatusState = {
      neume: function() {
        return new Neumes.Podatus();
      },
      handle: function(currNote, prevNote) {
        if (currNote.staffPosition > prevNote.staffPosition) {
          if (currNote.ictus)
            currNote.ictus.positionHint = MarkingPositionHint.Above;
          if (prevNote.ictus)
            prevNote.ictus.positionHint = MarkingPositionHint.Below;

          if (prevNote.shape === NoteShape.Oriscus) return salicusState;
          else return scandicusState;
        } else if (currNote.staffPosition < prevNote.staffPosition) {
          if (currNote.shape === NoteShape.Inclinatum)
            return pesSubpunctisState;
          else return torculusState;
        } else return createNeume(new Neumes.Podatus(), false);
      }
    };

    var clivisState = {
      neume: function() {
        return new Neumes.Clivis();
      },
      handle: function(currNote, prevNote) {
        if (
          currNote.shape === NoteShape.Default &&
          currNote.staffPosition > prevNote.staffPosition
        ) {
          if (currNote.ictus)
            currNote.ictus.positionHint = MarkingPositionHint.Above;
          return porrectusState;
        } else return createNeume(new Neumes.Clivis(), false);
      }
    };

    var climacusState = {
      neume: function() {
        return new Neumes.Climacus();
      },
      handle: function(currNote, prevNote) {
        if (currNote.shape !== NoteShape.Inclinatum)
          return createNeume(new Neumes.Climacus(), false);
        else return state;
      }
    };

    var porrectusState = {
      neume: function() {
        return new Neumes.Porrectus();
      },
      handle: function(currNote, prevNote) {
        if (
          currNote.shape === NoteShape.Default &&
          currNote.staffPosition < prevNote.staffPosition
        )
          return createNeume(new Neumes.PorrectusFlexus(), true);
        else return createNeume(new Neumes.Porrectus(), false);
      }
    };

    var pesSubpunctisState = {
      neume: function() {
        return new Neumes.PesSubpunctis();
      },
      handle: function(currNote, prevNote) {
        if (currNote.shape !== NoteShape.Inclinatum)
          return createNeume(new Neumes.PesSubpunctis(), false);
        else return state;
      }
    };

    var salicusState = {
      neume: function() {
        return new Neumes.Salicus();
      },
      handle: function(currNote, prevNote) {
        if (currNote.staffPosition < prevNote.staffPosition)
          return salicusFlexusState;
        else return createNeume(new Neumes.Salicus(), false);
      }
    };

    var salicusFlexusState = {
      neume: function() {
        return new Neumes.SalicusFlexus();
      },
      handle: function(currNote, prevNote) {
        return createNeume(new Neumes.SalicusFlexus(), false);
      }
    };

    var scandicusState = {
      neume: function() {
        return new Neumes.Scandicus();
      },
      handle: function(currNote, prevNote) {
        if (
          prevNote.shape === NoteShape.Virga &&
          currNote.shape === NoteShape.Inclinatum &&
          currNote.staffPosition < prevNote.staffPosition
        ) {
          // if we get here, then it seems we have a podatus, now being followed by a climacus
          // rather than a scandicus. react accordingly
          return createNeume(new Neumes.Podatus(), false, false);
        } else if (
          currNote.shape === NoteShape.Default &&
          currNote.staffPosition < prevNote.staffPosition
        )
          return scandicusFlexusState;
        else return createNeume(new Neumes.Scandicus(), false);
      }
    };

    var scandicusFlexusState = {
      neume: function() {
        return new Neumes.ScandicusFlexus();
      },
      handle: function(currNote, prevNote) {
        return createNeume(new Neumes.ScandicusFlexus(), false);
      }
    };

    var virgaState = {
      neume: function() {
        return new Neumes.Virga();
      },
      handle: function(currNote, prevNote) {
        if (
          currNote.shape === NoteShape.Inclinatum &&
          currNote.staffPosition < prevNote.staffPosition
        )
          return climacusState;
        else if (
          currNote.shape === NoteShape.Virga &&
          currNote.staffPosition === prevNote.staffPosition
        )
          return bivirgaState;
        else return createNeume(new Neumes.Virga(), false);
      }
    };

    var bivirgaState = {
      neume: function() {
        return new Neumes.Bivirga();
      },
      handle: function(currNote, prevNote) {
        if (
          currNote.shape === NoteShape.Virga &&
          currNote.staffPosition === prevNote.staffPosition
        )
          return createNeume(new Neumes.Trivirga(), true);
        else return createNeume(new Neumes.Bivirga(), false);
      }
    };

    var apostrophaState = {
      neume: function() {
        return new Neumes.Apostropha();
      },
      handle: function(currNote, prevNote) {
        if (currNote.staffPosition === prevNote.staffPosition)
          return distrophaState;
        else return createNeume(new Neumes.Apostropha(), false);
      }
    };

    var distrophaState = {
      neume: function() {
        return new Neumes.Distropha();
      },
      handle: function(currNote, prevNote) {
        if (currNote.staffPosition === prevNote.staffPosition) {
          if (prevNote.morae && prevNote.morae.length) {
            return createNeume(new Neumes.Distropha(), false);
          } else {
            return tristrophaState;
          }
        } else return createNeume(new Neumes.Apostropha(), false, false);
      }
    };

    var tristrophaState = {
      neume: function() {
        return new Neumes.Tristropha();
      },
      handle: function(currNote, prevNote) {
        // we only create a tristropha when the note run ends after three
        // and the neume() function of this state is called. Otherwise
        // we always interpret the third note to belong to the next sequence
        // of notes.
        //
        // fixme: gabc allows any number of punctum/stropha in succession...
        // is this a valid neume type? Or is it just multiple *stropha neumes
        // in succession? Should we simplify the apostropha/distropha/
        // tristropha classes to a generic stropha neume that can have 1 or
        // more successive notes?
        return createNeume(new Neumes.Distropha(), false, false);
      }
    };

    var torculusState = {
      neume: function() {
        return new Neumes.Torculus();
      },
      handle: function(currNote, prevNote) {
        if (
          currNote.shape === NoteShape.Default &&
          currNote.staffPosition > prevNote.staffPosition
        ) {
          let prevNoteButOne = notes[currNoteIndex - 2];
          if (
            prevNoteButOne &&
            prevNoteButOne.staffPosition - prevNote.staffPosition <= 4
          ) {
            if (currNote.ictus)
              currNote.ictus.positionHint = MarkingPositionHint.Above;
            return torculusResupinusState;
          }
        }
        return createNeume(new Neumes.Torculus(), false);
      }
    };

    var torculusResupinusState = {
      neume: function() {
        return new Neumes.TorculusResupinus();
      },
      handle: function(currNote, prevNote) {
        if (
          currNote.shape === NoteShape.Default &&
          currNote.staffPosition < prevNote.staffPosition
        )
          return createNeume(new Neumes.TorculusResupinusFlexus(), true);
        else return createNeume(new Neumes.TorculusResupinus(), false);
      }
    };

    var state = unknownState;

    while (currNoteIndex < notes.length) {
      var prevNote = currNoteIndex > 0 ? notes[currNoteIndex - 1] : null;
      var currNote = notes[currNoteIndex];

      state = state.handle(
        currNote,
        prevNote,
        notes.length - 1 - currNoteIndex
      );

      // if we are on the last note, then try to create a neume if we need to.
      if (currNoteIndex === notes.length - 1 && state !== unknownState)
        createNeume(state.neume(), true);

      currNoteIndex++;
    }

    if (neumes.length > 0) {
      if (!finalTrailingSpace.isDefault) {
        neumes[neumes.length - 1].trailingSpace = finalTrailingSpace;
        neumes[neumes.length - 1].keepWithNext = true;

        if (finalTrailingSpace > 0)
          neumes[neumes.length - 1].allowLineBreakBeforeNext = neumes[
            neumes.length - 1
          ].keepWithNext = true;
      }
    }

    return neumes;
  }

  // appends any notes created to the notes array argument
  static createNoteFromData(ctxt, clef, data, notes, sourceIndex) {
    var note = new Note();
    note.sourceIndex = sourceIndex;
    note.sourceGabc = data;

    if (data.length < 1) throw \"Invalid note data: \" + data;

    if (data[0] === \"-\") {
      // liquescent initio debilis
      note.liquescent = LiquescentType.InitioDebilis;
      data = data.substring(1);
    }

    if (data.length < 1) throw \"Invalid note data: \" + data;

    // the next char is always the pitch
    var pitch = this.gabcHeightToExsurgePitch(clef, data[0]);

    if (data[0] === data[0].toUpperCase()) note.shape = NoteShape.Inclinatum;

    note.staffPosition = this.gabcHeightToExsurgeHeight(data[0]);
    note.pitch = pitch;

    var mark;

    var episemaNoteIndex = notes.length;
    var episemaNote = note;

    // process the modifiers
    for (var i = 1; i < data.length; i++) {
      var c = data[i];
      var lookahead = \"\\0\";

      var haveLookahead = i + 1 < data.length;
      if (haveLookahead) lookahead = data[i + 1];

      switch (c) {
        // rhythmic markings
        case \".\":
          mark = null;

          // gabc supports putting up to two morae on each note, by repeating the
          // period. here, we check to see if we've already created a mora for the
          // note, and if so, we simply force the second one to have an Above
          // position hint. if a user decides to try to put position indicators
          // on the double morae (such as 1 or 2), then really the behavior is
          // not defined by gabc, so it's on the user to figure it out.
          if (note.morae.length > 0 && notes.length) {
            var previousNote = notes.slice(-1)[0];
            var previousMora = note.morae.slice(-1)[0];
            previousMora.note = previousNote;
          }

          mark = new Markings.Mora(ctxt, note);
          if (haveLookahead && lookahead === \"1\")
            mark.positionHint = MarkingPositionHint.Above;
          else if (haveLookahead && lookahead === \"0\")
            mark.positionHint = MarkingPositionHint.Below;

          note.morae.push(mark);
          break;

        case \"_\":
          var episemaHadModifier = false;

          mark = new Markings.HorizontalEpisema(episemaNote);
          while (haveLookahead) {
            if (lookahead === \"0\")
              mark.positionHint = MarkingPositionHint.Below;
            else if (lookahead === \"1\")
              mark.positionHint = MarkingPositionHint.Above;
            else if (lookahead === \"2\") mark.terminating = true;
            // episema terminates
            else if (lookahead === \"3\")
              mark.alignment = Markings.HorizontalEpisemaAlignment.Left;
            else if (lookahead === \"4\")
              mark.alignment = Markings.HorizontalEpisemaAlignment.Center;
            else if (lookahead === \"5\")
              mark.alignment = Markings.HorizontalEpisemaAlignment.Right;
            else break;

            // the gabc definition for episemata is so convoluted...
            // - double underscores create episemata over multiple notes.
            // - unless the _ has a 0, 1, 3, 4, or 5 modifier, which means
            //   another underscore puts a second episema on the same note
            // - (when there's a 2 lookahead, then this is treated as an
            //   unmodified underscore, so another underscore would be
            //   added to previous notes
            if (
              mark.alignment !== Markings.HorizontalEpisemaAlignment.Default &&
              mark.positionHint !== MarkingPositionHint.Below
            )
              episemaHadModifier = true;

            i++;
            haveLookahead = i + 1 < data.length;

            if (haveLookahead) lookahead = data[i + 1];
          }

          // since gabc allows consecutive underscores which is a shortcut to
          // apply the episemata to previous notes, we keep track of that here
          // in order to add the new episema to the correct note.

          if (episemaNote) episemaNote.episemata.push(mark);

          if (episemaNote === note && episemaHadModifier) episemaNote = note;
          else if (episemaNoteIndex >= 0 && notes.length > 0)
            episemaNote = notes[--episemaNoteIndex];

          break;

        case \"'\":
          mark = new Markings.Ictus(ctxt, note);
          if (haveLookahead && lookahead === \"1\")
            mark.positionHint = MarkingPositionHint.Above;
          else if (haveLookahead && lookahead === \"0\")
            mark.positionHint = MarkingPositionHint.Below;
          else if (note.shape === NoteShape.Virga)
            // ictus on a virga goes above by default:
            mark.positionHint = MarkingPositionHint.Above;

          note.ictus = mark;
          break;

        //note shapes
        case \"r\":
          if (haveLookahead && /^[0-5]$/.test(lookahead)) {
            switch (lookahead) {
              case \"0\":
                note.shapeModifiers |= NoteShapeModifiers.Cavum;
                note.shapeModifiers |= NoteShapeModifiers.Linea;
                break;
              case \"1\":
                note.accent = new Markings.Accent(
                  ctxt,
                  note,
                  GlyphCode.AcuteAccent
                );
                break;
              case \"2\":
                note.accent = new Markings.Accent(
                  ctxt,
                  note,
                  GlyphCode.GraveAccent
                );
                break;
              case \"3\":
                note.accent = new Markings.Accent(ctxt, note, GlyphCode.Circle);
                break;
              case \"4\":
                note.accent = new Markings.Accent(
                  ctxt,
                  note,
                  GlyphCode.Semicircle
                );
                break;
              case \"5\":
                note.accent = new Markings.Accent(
                  ctxt,
                  note,
                  GlyphCode.ReversedSemicircle
                );
                break;
              default:
            }
            i++;
          } else note.shapeModifiers |= NoteShapeModifiers.Cavum;
          break;
        
        case \"R\":
          note.shapeModifiers |= NoteShapeModifiers.Linea;
          break;

        case \"s\":
          if (note.shape === NoteShape.Stropha) {
            // if we're already a stropha, that means this is gabc's
            // quick stropha feature (e.g., gsss). create a new note
            let newNote = new Note();
            newNote.sourceIndex = sourceIndex + i;
            newNote.sourceGabc = \"s\";
            newNote.staffPosition = note.staffPosition;
            newNote.pitch = note.pitch;
            notes.push(note);
            note = newNote;
            episemaNoteIndex++; // since a new note was added, increase the index here
          }

          note.shape = NoteShape.Stropha;
          break;

        case \"v\":
          if (note.shape === NoteShape.Virga) {
            // if we're already a stropha, that means this is gabc's
            // quick virga feature (e.g., gvvv). create a new note
            let newNote = new Note();
            newNote.sourceIndex = sourceIndex + i;
            newNote.sourceGabc = \"v\";
            newNote.staffPosition = note.staffPosition;
            newNote.pitch = note.pitch;
            notes.push(note);
            note = newNote;
            episemaNoteIndex++; // since a new note was added, increase the index here
          }

          note.shape = NoteShape.Virga;
          break;
        
        case \"V\":
          note.shape = NoteShape.Virga;
          note.shapeModifers |= NoteShapeModifiers.Reverse;
          break;

        case \"w\":
          note.shape = NoteShape.Quilisma;
          break;

        case \"o\":
          note.shape = NoteShape.Oriscus;
          if (haveLookahead && lookahead === \"<\") {
            note.shapeModifiers |= NoteShapeModifiers.Ascending;
            i++;
          } else if (haveLookahead && lookahead === \">\") {
            note.shapeModifiers |= NoteShapeModifiers.Descending;
            i++;
          }
          break;

        case \"O\":
          note.shape = NoteShape.Oriscus;
          if (haveLookahead && lookahead === \"<\") {
            note.shapeModifiers |=
              NoteShapeModifiers.Ascending | NoteShapeModifiers.Stemmed;
            i++;
          } else if (haveLookahead && lookahead === \">\") {
            note.shapeModifiers |=
              NoteShapeModifiers.Descending | NoteShapeModifiers.Stemmed;
            i++;
          } else note.shapeModifiers |= NoteShapeModifiers.Stemmed;
          break;

        // liquescents
        case \"~\":
          if (note.shape === NoteShape.Inclinatum)
            note.liquescent |= LiquescentType.Small;
          else if (note.shape === NoteShape.Oriscus)
            note.liquescent |= LiquescentType.Large;
          else note.liquescent |= LiquescentType.Small;
          break;
        case \"<\":
          note.liquescent |= LiquescentType.Ascending;
          break;
        case \">\":
          note.liquescent |= LiquescentType.Descending;
          break;

        // accidentals
        case \"x\":
          if (note.pitch.step === Step.Mi) note.pitch.step = Step.Me;
          else if (note.pitch.step === Step.Ti) note.pitch.step = Step.Te;
          break;
        case \"y\":
          if (note.pitch.step === Step.Te) note.pitch.step = Step.Ti;
          else if (note.pitch.step === Step.Me) note.pitch.step = Step.Mi;
          else if (note.pitch.step === Step.Du) note.pitch.step = Step.Do;
          else if (note.pitch.step === Step.Fu) note.pitch.step = Step.Fa;
          break;
        case \"#\":
          if (note.pitch.step === Step.Do) note.pitch.step = Step.Du;
          else if (note.pitch.step === Step.Fa) note.pitch.step = Step.Fu;
          break;

        // gabc special item groups
        case \"[\":
          // read in the whole group and parse it
          var startIndex = ++i;
          while (i < data.length && data[i] !== \"]\") i++;

          this.processInstructionForNote(
            ctxt,
            note,
            data.substring(startIndex, i),
            startIndex
          );
          break;
      }
    }

    if (
      this.needToEndBrace &&
      !note.braceStart &&
      !note.braceEnd &&
      !/[xy#]/.test(c)
    ) {
      note.braceEnd = new Markings.BracePoint(
        note,
        this.needToEndBrace.isAbove,
        this.needToEndBrace.shape,
        this.needToEndBrace.attachment === Markings.BraceAttachment.Left
          ? Markings.BraceAttachment.Right
          : Markings.BraceAttachment.Left
      );
      note.braceEnd.automatic = true;
      delete this.needToEndBrace;
    }

    notes.push(note);
  }

  // an instruction in this context is referring to a special gabc coding found after
  // notes between ['s and ]'s. choral signs and braces fall into this
  // category.
  //
  // currently only brace instructions are supported here!
  static processInstructionForNote(ctxt, note, instruction, sourceIndexOffset) {
    var results = instruction.match(__bracketedCommandRegex);
    if (results === null) return;
    var cmd = results[1];
    var data = results[2];
    switch (cmd) {
      case \"cs\":
        note.choralSign = new ChoralSign(
          ctxt,
          data,
          note,
          note.sourceIndex + sourceIndexOffset,
          instruction.length
        );
        return;
      case \"alt\":
        note.alText = new AboveLinesText(
          ctxt,
          data,
          note,
          note.sourceIndex + sourceIndexOffset,
          instruction.length
        );
        return;
    }

    results = instruction.match(__braceSpecRegex);

    if (results === null) return;

    // see the comments at the definition of __braceSpecRegex for the
    // capturing groups
    var above = results[1] === \"o\";
    var shape = Markings.BraceShape.CurlyBrace; // default

    switch (results[2]) {
      case \"b\":
        shape = Markings.BraceShape.RoundBrace;
        break;
      case \"cb\":
        shape = Markings.BraceShape.CurlyBrace;
        break;
      case \"cba\":
        shape = Markings.BraceShape.AccentedCurlyBrace;
        break;
    }

    var attachmentPoint =
      results[3] === \"1\"
        ? Markings.BraceAttachment.Left
        : Markings.BraceAttachment.Right;

    if (results[4] === \"{\" || results[5])
      note.braceStart = new Markings.BracePoint(
        note,
        above,
        shape,
        attachmentPoint
      );
    else
      note.braceEnd = new Markings.BracePoint(
        note,
        above,
        shape,
        attachmentPoint
      );

    // just have the next note end a brace that uses length;
    if (results[5]) {
      note.braceStart.automatic = true;
      this.needToEndBrace = note.braceStart;
    }
  }

  // takes raw gabc text source and parses it into words. For example, passing
  // in a string of \"me(f.) (,) ma(fff)num(d!ewf) tu(fgF'E)am,(f.)\" would return
  // an array of four strings: [\"me(f.)\", \"(,)\", \"ma(fff)num(d!ewf)\", \"tu(fgF'E)am,(f.)\"]
  static splitWords(gabcNotations) {
    // split the notations on whitespace boundaries, as long as the space
    // immediately follows a set of parentheses. Prior to doing that, we replace
    // all whitespace with spaces, which prevents tabs and newlines from ending
    // up in the notation data.
    gabcNotations = gabcNotations
      // .trim()
      // .replace(/\\s/g, \" \")
      .replace(/\\)\\s(?=[^\\)]*(?:\\(|$))/g, \")\
\");
    return gabcNotations.split(/\
/g);
  }

  static parseSource(gabcSource) {
    return this.parseWords(this.splitWords(gabcSource));
  }

  // gabcWords is an array of strings, e.g., the result of splitWords above
  static parseWords(gabcWords) {
    var words = [];

    for (var i = 0; i < gabcWords.length; i++)
      words.push(this.parseWord(gabcWords[i]));

    return words;
  }

  // returns an array of objects, each of which has the following properties
  //  - notations (string)
  //  - lyrics (array of strings)
  static parseWord(gabcWord) {
    var syllables = [];
    var matches = [];

    syllables.wordLength = gabcWord.length;

    while ((match = __syllablesRegex.exec(gabcWord))) matches.push(match);

    for (var j = 0; j < matches.length; j++) {
      var match = matches[j];

      var lyrics = match[1].trim().split(\"|\");
      var notations = match[2];

      syllables.push({
        notations: notations,
        lyrics: lyrics
      });
    }

    return syllables;
  }

  // returns pitch
  static gabcHeightToExsurgeHeight(gabcHeight) {
    return gabcHeight.toLowerCase().charCodeAt(0) - \"a\".charCodeAt(0) - 6;
  }

  // returns pitch
  static gabcHeightToExsurgePitch(clef, gabcHeight) {
    var exsurgeHeight = this.gabcHeightToExsurgeHeight(gabcHeight);

    var pitch = clef.staffPositionToPitch(exsurgeHeight);

    return pitch;
  }
}



// WEBPACK FOOTER //
// ./src/Exsurge.Gabc.js","//
// Author(s):
// Fr. Matthew Spencer, OSJ <mspencer@osjusa.org>
//
// Copyright (c) 2008-2016 Fr. Matthew Spencer, OSJ
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the \"Software\"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

import {
  LiquescentType,
  NoteShape,
  NoteShapeModifiers
} from \"./Exsurge.Chant.js\";
import {
  ChantNotationElement,
  GlyphCode, LineaVisualizer, MarkingPositionHint,
  NeumeLineVisualizer, VirgaLineVisualizer
} from \"./Exsurge.Drawing.js\";
import { Glyphs } from \"./Exsurge.Glyphs.js\";

class NeumeBuilder {
  constructor(ctxt, neume, startingX = 0) {
    this.ctxt = ctxt;
    this.neume = neume;
    this.x = startingX;
    this.lastNote = null;
    this.lineIsHanging = false;
    this.minX = 0;
  }

  // used to start a hanging line on the left of the next note
  lineFrom(note) {
    var previousNotation = this.ctxt.notations[this.ctxt.currNotationIndex - 1];
    if (
      this.x === 0 &&
      previousNotation &&
      previousNotation.notes &&
      previousNotation.trailingSpace === 0
    ) {
      this.lastNote = previousNotation.notes.slice(-1)[0];
      this.minX = -this.ctxt.neumeLineWeight;
    } else {
      this.lastNote = note;
      this.lineIsHanging = true;
    }
    return this;
  }

  // add a note, with a connecting line on the left if we have one
  noteAt(note, glyph, withLineTo = true) {
    if (!note) throw \"NeumeBuilder.noteAt: note must be a valid note\";

    if (!glyph) throw \"NeumeBuilder.noteAt: glyph must be a valid glyph code\";

    note.setGlyph(this.ctxt, glyph);
    var noteAlignsRight = note.glyphVisualizer.align === \"right\";

    var needsLine =
      withLineTo &&
      this.lastNote !== null &&
      (this.lineIsHanging ||
        (this.lastNote.glyphVisualizer &&
          this.lastNote.glyphVisualizer.align === \"right\") ||
        Math.abs(this.lastNote.staffPosition - note.staffPosition) > 1);

    if (needsLine) {
      var line = new NeumeLineVisualizer(
        this.ctxt,
        this.lastNote,
        note,
        this.lineIsHanging
      );
      this.neume.addVisualizer(line);
      line.bounds.x = Math.max(this.minX, this.x - line.bounds.width);

      if (!noteAlignsRight) this.x = line.bounds.x;
    }
    
    let xOffset = 0;
    if (note.shapeModifiers & NoteShapeModifiers.Linea) {
      var linea = new LineaVisualizer(
        this.ctxt,
        note
      );
      this.neume.addVisualizer(linea);
      note.origin.x += linea.origin.x;
      xOffset = linea.origin.x;
    }

    // if this is the first note of a right aligned glyph (probably an initio debilis),
    // then there's nothing to worry about. but if it's not then first, then this
    // subtraction will right align it visually
    if (noteAlignsRight && this.lastNote)
      note.bounds.x = this.x - note.bounds.width;
    else {
      note.bounds.x = this.x + xOffset;
      this.x += note.bounds.width + xOffset;
    }

    this.neume.addVisualizer(note);

    this.lastNote = note;
    this.lineIsHanging = false;

    return this;
  }

  // a special form of noteAdd that creates a virga
  // uses a punctum cuadratum and a line rather than the virga glyphs
  virgaAt(note, withLineTo = true) {
    // add the punctum for the virga
    this.noteAt(note, GlyphCode.PunctumQuadratum);

    // add a line for the virga
    var line = new VirgaLineVisualizer(this.ctxt, note);
    this.x -= line.bounds.width;
    if (note.shapeModifers & NoteShapeModifiers.Reverse) {
      line.bounds.x = 0;
    } else {
      line.bounds.x = this.x;
    }
    this.neume.addVisualizer(line);

    this.lastNote = note;
    this.lineIsHanging = false;

    return this;
  }

  advanceBy(x) {
    this.lastNote = null;
    this.lineIsHanging = false;

    this.x += x;

    return this;
  }

  // for terminating hanging lines with no lower notes
  withLineEndingAt(note) {
    if (this.lastNote === null) return;

    var line = new NeumeLineVisualizer(this.ctxt, this.lastNote, note, true);
    this.neume.addVisualizer(line);
    this.x -= line.bounds.width;
    line.bounds.x = this.x;

    this.neume.addVisualizer(line);

    this.lastNote = note;

    return this;
  }

  withPodatus(lowerNote, upperNote) {
    var upperGlyph;
    var lowerGlyph;

    if (lowerNote.liquescent === LiquescentType.InitioDebilis) {
      // liquescent upper note or not?
      if (upperNote.liquescent === LiquescentType.None)
        upperGlyph = GlyphCode.PunctumQuadratum;
      else upperGlyph = GlyphCode.PunctumQuadratumDesLiquescent;

      lowerGlyph = GlyphCode.TerminatingDesLiquescent;
    } else if (upperNote.liquescent & LiquescentType.Small) {
      lowerGlyph = GlyphCode.BeginningAscLiquescent;
      upperGlyph = GlyphCode.TerminatingAscLiquescent;
    } else if (upperNote.liquescent & LiquescentType.Ascending) {
      lowerGlyph = GlyphCode.PunctumQuadratum;
      upperGlyph = GlyphCode.PunctumQuadratumAscLiquescent;
    } else if (upperNote.liquescent & LiquescentType.Descending) {
      lowerGlyph = GlyphCode.PunctumQuadratum;
      upperGlyph = GlyphCode.PunctumQuadratumDesLiquescent;
    } else {
      // standard shape
      lowerGlyph = GlyphCode.PodatusLower;
      upperGlyph = GlyphCode.PodatusUpper;
    }

    // allow a quilisma pes
    if (lowerNote.shape === NoteShape.Quilisma) lowerGlyph = GlyphCode.Quilisma;

    this.noteAt(lowerNote, lowerGlyph).noteAt(upperNote, upperGlyph);

    // make sure we don't have lines connected to the podatus
    this.lastNote = null;

    return this;
  }

  withClivis(upper, lower) {
    var lowerGlyph;

    if (upper.shape === NoteShape.Oriscus)
      this.noteAt(upper, GlyphCode.OriscusDes, false);
    else this.lineFrom(lower).noteAt(upper, GlyphCode.PunctumQuadratum);

    if (lower.liquescent & LiquescentType.Small) {
      lowerGlyph = GlyphCode.TerminatingDesLiquescent;
    } else if (lower.liquescent === LiquescentType.Ascending)
      lowerGlyph = GlyphCode.PunctumQuadratumAscLiquescent;
    else if (lower.liquescent === LiquescentType.Descending)
      lowerGlyph = GlyphCode.PunctumQuadratumDesLiquescent;
    else lowerGlyph = GlyphCode.PunctumQuadratum;

    this.noteAt(lower, lowerGlyph);

    // make sure we don't have lines connected to the clivis
    this.lastNote = null;

    return this;
  }

  // lays out a sequence of notes that are inclinata (e.g., climacus, pes subpunctis)
  withInclinata(notes) {
    var staffPosition = notes[0].staffPosition,
      prevStaffPosition = notes[0].staffPosition;

    // it is important to advance by the width of the inclinatum glyph itself
    // rather than by individual note widths, so that any liquescents are spaced
    // the same as non-liquscents
    var advanceWidth =
      Glyphs.PunctumInclinatum.bounds.width * this.ctxt.glyphScaling;

    // now add all the punctum inclinatum
    for (var i = 0; i < notes.length; i++, prevStaffPosition = staffPosition) {
      var note = notes[i];

      if (note.liquescent & LiquescentType.Small)
        note.setGlyph(this.ctxt, GlyphCode.PunctumInclinatumLiquescent);
      else if (note.liquescent & LiquescentType.Large)
        // fixme: is the large inclinatum liquescent the same as the apostropha?
        note.setGlyph(this.ctxt, GlyphCode.Stropha);
      // fixme: some climaci in the new chant books end with a punctum quadratum
      // (see, for example, the antiphon \"Sancta Maria\" for October 7).
      else note.setGlyph(this.ctxt, GlyphCode.PunctumInclinatum);

      staffPosition = note.staffPosition;

      var multiple = Math.abs(prevStaffPosition - staffPosition);
      switch (multiple) {
        case 0:
          multiple = 1.1;
          break;
        default:
          multiple *= 2 / 3;
          break;
      }

      if (i > 0) this.x += advanceWidth * multiple;

      note.bounds.x = this.x;

      this.neume.addVisualizer(note);
    }

    return this;
  }

  withPorrectusSwash(start, end) {
    var needsLine =
      this.lastNote !== null &&
      (this.lineIsHanging ||
        (this.lastNote.glyphVisualizer &&
          this.lastNote.glyphVisualizer.align === \"right\") ||
        Math.abs(this.lastNote.staffPosition - start.staffPosition) > 1);

    if (needsLine) {
      var line = new NeumeLineVisualizer(
        this.ctxt,
        this.lastNote,
        start,
        this.lineIsHanging
      );
      this.x = Math.max(this.minX, this.x - line.bounds.width);
      line.bounds.x = this.x;
      this.neume.addVisualizer(line);
    }

    var glyph;

    switch (start.staffPosition - end.staffPosition) {
      case 1:
        glyph = GlyphCode.Porrectus1;
        break;
      case 2:
        glyph = GlyphCode.Porrectus2;
        break;
      case 3:
        glyph = GlyphCode.Porrectus3;
        break;
      case 4:
        glyph = GlyphCode.Porrectus4;
        break;
      default:
        // fixme: should we generate an error here?
        glyph = GlyphCode.None;
        break;
    }

    start.setGlyph(this.ctxt, glyph);
    start.bounds.x = this.x;

    // the second glyph does not draw anything, but it still has logical importance for the editing
    // environment...it can respond to changes which will then change the swash glyph of the first.
    end.setGlyph(this.ctxt, GlyphCode.None);

    this.x = start.bounds.right();
    end.bounds.x = this.x - end.bounds.width;

    this.neume.addVisualizer(start);
    this.neume.addVisualizer(end);

    this.lastNote = end;
    this.lineIsHanging = false;

    return this;
  }
}

/*
 * Neumes base class
 */
export class Neume extends ChantNotationElement {
  constructor(notes = []) {
    super();

    this.isNeume = true; // poor man's reflection
    this.notes = notes;

    for (var i = 0; i < notes.length; i++) notes[i].neume = this;
  }

  addNote(note) {
    note.neume = this;
    this.notes.push(note);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);
  }

  finishLayout(ctxt) {
    this.ledgerLines = this.requiresLedgerLine();

    // allow subclasses an opportunity to position their own markings...
    this.positionMarkings();

    // layout the markings of the notes
    for (var i = 0; i < this.notes.length; i++) {
      var note = this.notes[i];
      var j;

      for (j = 0; j < note.episemata.length; j++) {
        note.episemata[j].performLayout(ctxt);
        this.addVisualizer(note.episemata[j]);
      }

      for (j = 0; j < note.morae.length; j++) {
        note.morae[j].performLayout(ctxt);
        this.addVisualizer(note.morae[j]);
      }

      // if the note has an ictus, then add it here
      if (note.ictus) {
        note.ictus.performLayout(ctxt);
        this.addVisualizer(note.ictus);
      }

      if (note.accent) {
        note.accent.performLayout(ctxt);
        this.addVisualizer(note.accent);
      }

      if (note.choralSign) {
        note.choralSign.performLayout(ctxt);
        this.addVisualizer(note.choralSign);
      }

      // braces are handled by the chant line, so we don't mess with them here
      // this is because brace size depends on chant line logic (neume spacing,
      // justification, etc.) so they are considered chant line level
      // markings rather than note level markings
    }

    this.origin.x = this.notes[0].origin.x;
    this.origin.y = this.notes[0].origin.y;

    super.finishLayout(ctxt);
  }

  requiresLedgerLine() {
    var firstAbove = false,
      needsAbove = false,
      firstBelow = false,
      needsBelow = false,
      // isPorrectus = false,
      result = [];

    if (!this.notes) return result;

    for (var i = 0; i < this.notes.length; ++i) {
      var note = this.notes[i];
      var staffPosition = note.staffPosition;
      if (staffPosition >= 4) {
        needsAbove = needsAbove || staffPosition >= 5;
        if (firstAbove === false) firstAbove = Math.max(0, i - 1);
        if (staffPosition >= 5) continue;
      } else if (staffPosition <= -4) {
        needsBelow = needsBelow || staffPosition <= -5;
        if (firstBelow === false) firstBelow = Math.max(0, i - 1);
        if (staffPosition <= -5) continue;
      }
      if (needsAbove || needsBelow) {
        var endI = i; // Math.abs(staffPosition) >= 4? i : i - 1;
        result.push({
          element: this.notes[firstAbove || firstBelow || 0],
          endElem: this.notes[endI],
          staffPosition: needsAbove ? 5 : -5
        });
        firstAbove = firstBelow = needsAbove = needsBelow = false;
      }
      // isPorrectus = /^Porrectus\\d$/.test(note.glyphVisualizer.glyphCode);
    }
    if (needsAbove || needsBelow) {
      result.push({
        element: this.notes[firstAbove || firstBelow || 0],
        endElem: this.notes[this.notes.length - 1],
        staffPosition: needsAbove ? 5 : -5
      });
    }
    return result;
  }

  resetDependencies() {}

  build(ctxt) {
    return new NeumeBuilder(ctxt, this);
  }
  positionEpisemata(note, position) {
    var i;
    for (i = 0; i < note.episemata.length; i++)
      if (note.episemata[i].positionHint === MarkingPositionHint.Default)
        note.episemata[i].positionHint = position;
    if (note.choralSign) note.choralSign.positionHint = position;
    return note.episemata.length;
  }
  positionEpisemataAbove(note) {
    return this.positionEpisemata(note, MarkingPositionHint.Above);
  }
  positionEpisemataBelow(note) {
    return this.positionEpisemata(note, MarkingPositionHint.Below);
  }

  positionPodatusEpisemata(bottomNote, topNote) {
    // 1. episema on lower note by default be below, upper note above
    this.positionEpisemataBelow(bottomNote);
    this.positionEpisemataAbove(topNote);
    if (topNote.ictus) {
      topNote.ictus.positionHint = MarkingPositionHint.Above;
    }
  }
  positionInclinataMorae(notes) {
    notes = notes.slice(-2);
    if (notes.length < 2 || notes[1].staffPosition > notes[0].staffPosition)
      return;
    var bottomNote = notes[1],
      topNote = notes[0],
      mark;

    // The mora on the second (lower) note should be below the punctum,
    // if the punctum is on a line and the previous punctum is in the space above.
    if (
      Math.abs(bottomNote.staffPosition % 2) === 1 &&
      topNote.staffPosition - bottomNote.staffPosition === 1 &&
      bottomNote.morae.length > 0
    ) {
      mark = bottomNote.morae.slice(-1)[0];
      if (mark.positionHint === MarkingPositionHint.Default)
        mark.positionHint = MarkingPositionHint.Below;
    }
  }
  positionPodatusMorae(bottomNote, topNote) {
    var mark;

    // The mora on the first (lower) note should be below it,
    // if it is on a line.
    if (Math.abs(bottomNote.staffPosition % 2) === 1) {
      if (bottomNote.morae.length === 1) {
        mark = bottomNote.morae[0];
      } else if (topNote.morae.length > 1) {
        mark = topNote.morae[0];
      }
      if (mark && mark.positionHint === MarkingPositionHint.Default)
        mark.positionHint = MarkingPositionHint.Below;
    }

    // if there is a mora on the first note but not on the second, and the neume
    // continues with a punctum higher than the second note, we need to adjust
    // the space after the neume so that it follows immediately with no gap
    if (bottomNote.morae.length > 0 && topNote.morae.length === 0) {
      bottomNote.morae[0].ignoreBounds = true;
    }
  }
  // for any subclasses that begin with a podatus, they can call this from their own positionMarkings()
  positionPodatusMarkings(bottomNote, topNote) {
    this.positionPodatusEpisemata(bottomNote, topNote);
    this.positionPodatusMorae(bottomNote, topNote);
  }

  // just like a clivis, but the first note of the three also works like the second note of the clivis:
  // episema below, unless the middle note also has an episema
  positionTorculusMarkings(firstNote, secondNote, thirdNote) {
    var hasTopEpisema = this.positionClivisMarkings(secondNote, thirdNote);
    hasTopEpisema =
      this.positionEpisemata(
        firstNote,
        hasTopEpisema ? MarkingPositionHint.Above : MarkingPositionHint.Below
      ) && hasTopEpisema;
    return hasTopEpisema;
  }
  positionClivisMorae(firstNote, secondNote) {
    // 1. second note of a clivis that ends on a line and goes down one step has its mora below:
    var morae = firstNote.morae.concat(secondNote.morae);
    if (
      secondNote.morae.length &&
      firstNote.staffPosition - secondNote.staffPosition === 1 &&
      Math.abs(secondNote.staffPosition % 2) === 1
    ) {
      morae.slice(-1)[0].positionHint = MarkingPositionHint.Below;
    }
  }
  positionClivisEpisemata(firstNote, secondNote) {
    var hasTopEpisema = this.positionEpisemataAbove(firstNote);
    this.positionEpisemata(
      secondNote,
      hasTopEpisema ? MarkingPositionHint.Above : MarkingPositionHint.Below
    );
    return hasTopEpisema;
  }
  positionClivisMarkings(firstNote, secondNote) {
    this.positionClivisMorae(firstNote, secondNote);
    return this.positionClivisEpisemata(firstNote, secondNote);
  }

  positionPorrectusMarkings(firstNote, secondNote, thirdNote) {
    // episemata on first and second note work like a clivis,
    // the second note should have its episema below, unless the first note also has an episema.
    this.positionClivisEpisemata(firstNote, secondNote);
    this.positionPodatusMarkings(secondNote, thirdNote);
  }

  positionPorrectusFlexusMarkings(first, second, third, fourth) {
    var hasTopEpisema = this.positionEpisemataAbove(first);
    hasTopEpisema = this.positionClivisMarkings(third, fourth) || hasTopEpisema;
    this.positionEpisemata(
      second,
      hasTopEpisema ? MarkingPositionHint.Above : MarkingPositionHint.Below
    );
  }

  // subclasses can override this in order to correctly place markings in a neume specific way
  positionMarkings() {}
}

/*
 * Apostropha
 */
export class Apostropha extends Neume {
  positionMarkings() {
    var positionHint = MarkingPositionHint.Above;

    // logic here is this: if first episema is default position, place it above.
    // then place the second one (if there is one) opposite of the first.
    for (var i = 0; i < this.notes[0].episemata.length; i++) {
      if (
        this.notes[0].episemata[i].positionHint === MarkingPositionHint.Default
      )
        this.notes[0].episemata[i].positionHint = positionHint;
      else positionHint = this.notes[0].episemata[i].positionHint;

      // now place the next one in the opposite position
      positionHint =
        positionHint === MarkingPositionHint.Above
          ? MarkingPositionHint.Below
          : MarkingPositionHint.Above;
    }
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    this.build(ctxt).noteAt(
      this.notes[0],
      Apostropha.getNoteGlyphCode(this.notes[0])
    );

    this.finishLayout(ctxt);
  }

  static getNoteGlyphCode(note) {
    if (note.shape === NoteShape.Stropha) return GlyphCode.Stropha;

    if (note.liquescent & LiquescentType.Ascending)
      return GlyphCode.PunctumQuadratumAscLiquescent;
    else if (note.liquescent & LiquescentType.Descending)
      return GlyphCode.PunctumQuadratumDesLiquescent;

    if (note.shapeModifiers & NoteShapeModifiers.Cavum)
      return GlyphCode.PunctumCavum;

    return GlyphCode.PunctumQuadratum;
  }
}

/*
 * Bivirga
 *
 * For simplicity in implementation, Bivirga's have two notes in the object
 * structure. These technically must be the same pitch though.
 */
export class Bivirga extends Neume {
  positionMarkings() {
    this.positionEpisemataAbove(this.notes[0]);
    this.positionEpisemataAbove(this.notes[1]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    this.build(ctxt)
      .virgaAt(this.notes[0])
      .advanceBy(ctxt.intraNeumeSpacing)
      .virgaAt(this.notes[1]);

    this.finishLayout(ctxt);
  }
}

/*
 * Trivirga
 *
 * For simplicity in implementation, Trivirga's have three notes in the object
 * structure. These technically must be the same pitch though.
 */
export class Trivirga extends Neume {
  positionMarkings() {
    this.positionEpisemataAbove(this.notes[0]);
    this.positionEpisemataAbove(this.notes[1]);
    this.positionEpisemataAbove(this.notes[2]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    this.build(ctxt)
      .virgaAt(this.notes[0])
      .advanceBy(ctxt.intraNeumeSpacing)
      .virgaAt(this.notes[1])
      .advanceBy(ctxt.intraNeumeSpacing)
      .virgaAt(this.notes[2]);

    this.finishLayout(ctxt);
  }
}

/*
 * Climacus
 */
export class Climacus extends Neume {
  positionMarkings() {
    for (var i = 0; i < this.notes.length; i++) {
      this.positionEpisemataAbove(this.notes[i]);
    }
    this.positionInclinataMorae(this.notes);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    this.build(ctxt)
      .virgaAt(this.notes[0])
      .advanceBy(ctxt.intraNeumeSpacing)
      .withInclinata(this.notes.slice(1));

    this.finishLayout(ctxt);
  }
}

/*
 * Clivis
 */
export class Clivis extends Neume {
  positionMarkings() {
    this.positionClivisMarkings(this.notes[0], this.notes[1]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    var upper = this.notes[0];
    var lower = this.notes[1];

    this.build(ctxt).withClivis(upper, lower);

    this.finishLayout(ctxt);
  }
}

/*
 * Distropha
 *
 * For simplicity in implementation, Distropha's have two notes in the object
 * structure. These technically must be the same pitch though (like Bivirga).
 */
export class Distropha extends Neume {
  positionMarkings() {
    this.positionEpisemataAbove(this.notes[0]);
    this.positionEpisemataAbove(this.notes[1]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);
    let glyphCodes = this.notes.map((note) =>
      Apostropha.getNoteGlyphCode(note)
    );
    let glyphAdvance = ctxt.intraNeumeSpacing;
    glyphCodes.slice(0, 2).forEach((glyphCode) => {
      if (glyphCode === GlyphCode.Stropha)
        glyphAdvance -= ctxt.intraNeumeSpacing / 4;
    });

    this.build(ctxt)
      .noteAt(this.notes[0], glyphCodes[0])
      .advanceBy(glyphAdvance)
      .noteAt(this.notes[1], glyphCodes[1]);

    this.finishLayout(ctxt);
  }
}

/*
 * Oriscus
 */
export class Oriscus extends Neume {
  positionMarkings() {
    this.positionEpisemataAbove(this.notes[0]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    // determine the glyph to use
    var note = this.notes[0];
    var glyph;

    if (note.liquescent !== LiquescentType.None) {
      glyph = GlyphCode.OriscusLiquescent;
    } else {
      if (note.shapeModifiers & NoteShapeModifiers.Ascending)
        glyph = GlyphCode.OriscusAsc;
      else if (note.shapeModifiers & NoteShapeModifiers.Descending)
        glyph = GlyphCode.OriscusDes;
      else {
        // by default we take the descending form, unless we can figure out by a lookahead here
        glyph = GlyphCode.OriscusDes;

        // try to find a neume following this one
        var neume = ctxt.findNextNeume();

        if (neume) {
          var nextNoteStaffPosition = ctxt.activeClef.pitchToStaffPosition(
            neume.notes[0].pitch
          );

          if (nextNoteStaffPosition > note.staffPosition)
            glyph = GlyphCode.OriscusAsc;
        }
      }
    }

    this.build(ctxt).noteAt(note, glyph);

    this.finishLayout(ctxt);
  }

  resetDependencies() {
    // a single oriscus tries to automatically use the right direction
    // based on the following neumes. if we don't have a manually designated
    // direction, then we reset our layout so that we can try to guess it
    // at next layout phase.
    if (
      this.notes[0].shapeModifiers & NoteShapeModifiers.Ascending ||
      this.notes[0].shapeModifiers & NoteShapeModifiers.Descending
    )
      return;

    this.needsLayout = true;
  }
}

/*
 * PesQuassus
 */
export class PesQuassus extends Neume {
  performLayout(ctxt) {
    super.performLayout(ctxt);

    var lower = this.notes[0];
    var upper = this.notes[1];

    var lowerGlyph;

    var lowerStaffPos = lower.staffPosition;
    var upperStaffPos = upper.staffPosition;

    if (lower.shape === NoteShape.Oriscus) lowerGlyph = GlyphCode.OriscusAsc;
    else lowerGlyph = GlyphCode.PunctumQuadratum;

    var builder = this.build(ctxt).noteAt(lower, lowerGlyph);

    if (upperStaffPos - lowerStaffPos === 1)
      // use a virga glyph in this case
      builder.virgaAt(upper);
    else if (upper.liquescent === LiquescentType.LargeDescending)
      builder
        .noteAt(upper, GlyphCode.PunctumQuadratumDesLiquescent)
        .withLineEndingAt(lower);
    else
      builder.noteAt(upper, GlyphCode.PunctumQuadratum).withLineEndingAt(lower);

    this.finishLayout(ctxt);
  }
}

/*
 * PesSubpunctis
 */
export class PesSubpunctis extends Neume {
  positionMarkings() {
    this.positionPodatusEpisemata(this.notes[0], this.notes[1]);
    for (var i = 2; i < this.notes.length; ++i) {
      this.positionEpisemataAbove(this.notes[i]);
    }
    this.positionInclinataMorae(this.notes.slice(1));
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    // podatus followed by inclinata
    this.build(ctxt)
      .withPodatus(this.notes[0], this.notes[1])
      .advanceBy(ctxt.intraNeumeSpacing * 0.68)
      .withInclinata(this.notes.slice(2));

    this.finishLayout(ctxt);
  }
}

/*
 * Podatus
 *
 * This podatus class handles a few neume types actually, depending on the note
 * data: Podatus (including various liquescent types on the upper note),
 * Podatus initio debilis, and Quilisma-Pes
 */
export class Podatus extends Neume {
  positionMarkings() {
    this.positionPodatusMarkings(this.notes[0], this.notes[1]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    this.build(ctxt).withPodatus(this.notes[0], this.notes[1]);

    this.finishLayout(ctxt);
  }
}

/*
 * Porrectus
 */
export class Porrectus extends Neume {
  positionMarkings() {
    this.positionPorrectusMarkings(this.notes[0], this.notes[1], this.notes[2]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    var first = this.notes[0];
    var second = this.notes[1];
    var third = this.notes[2];

    var thirdGlyph;

    if (third.liquescent & LiquescentType.Small)
      thirdGlyph = GlyphCode.TerminatingAscLiquescent;
    else if (third.liquescent & LiquescentType.Descending)
      thirdGlyph = GlyphCode.PunctumQuadratumDesLiquescent;
    else thirdGlyph = GlyphCode.PodatusUpper;

    this.build(ctxt)
      .lineFrom(second)
      .withPorrectusSwash(first, second)
      .noteAt(third, thirdGlyph);

    this.finishLayout(ctxt);
  }
}

/*
 * PorrectusFlexus
 */
export class PorrectusFlexus extends Neume {
  positionMarkings() {
    this.positionPorrectusFlexusMarkings(
      this.notes[0],
      this.notes[1],
      this.notes[2],
      this.notes[3]
    );
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    var first = this.notes[0];
    var second = this.notes[1];
    var third = this.notes[2];
    var fourth = this.notes[3];

    var thirdGlyph = GlyphCode.PunctumQuadratum,
      fourthGlyph;

    if (fourth.liquescent & LiquescentType.Small) {
      thirdGlyph = GlyphCode.PunctumQuadratumDesLiquescent;
      fourthGlyph = GlyphCode.TerminatingDesLiquescent;
    } else if (fourth.liquescent & LiquescentType.Ascending)
      fourthGlyph = GlyphCode.PunctumQuadratumAscLiquescent;
    else if (fourth.liquescent & LiquescentType.Descending)
      fourthGlyph = GlyphCode.PunctumQuadratumDesLiquescent;
    else fourthGlyph = GlyphCode.PunctumQuadratum;

    this.build(ctxt)
      .lineFrom(second)
      .withPorrectusSwash(first, second)
      .noteAt(third, thirdGlyph)
      .noteAt(fourth, fourthGlyph);

    this.finishLayout(ctxt);
  }
}

// this is some type of pseudo nume right? there is no such thing as a neume
// of puncta inclinata, but this will be part of other composite neumes.
export class PunctaInclinata extends Neume {
  positionMarkings() {
    this.positionInclinataMorae(this.notes);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    this.build(ctxt).withInclinata(this.notes);

    this.finishLayout(ctxt);
  }
}

/*
 * Punctum
 */
export class Punctum extends Neume {
  positionMarkings() {
    this.positionEpisemataAbove(this.notes[0]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    var note = this.notes[0];
    var glyph = GlyphCode.PunctumQuadratum;

    // determine the glyph to use
    if (note.liquescent !== LiquescentType.None) {
      if (note.shape === NoteShape.Inclinatum)
        glyph = GlyphCode.PunctumInclinatumLiquescent;
      else if (note.shape === NoteShape.Oriscus)
        glyph = GlyphCode.OriscusLiquescent;
      else if (note.liquescent & LiquescentType.Ascending)
        glyph = GlyphCode.PunctumQuadratumAscLiquescent;
      else if (note.liquescent & LiquescentType.Descending)
        glyph = GlyphCode.PunctumQuadratumDesLiquescent;
      else glyph = GlyphCode.PunctumQuadratumLiquescent;
    } else {
      if (note.shapeModifiers & NoteShapeModifiers.Cavum)
        glyph = GlyphCode.PunctumCavum;
      else if (note.shape === NoteShape.Inclinatum)
        glyph = GlyphCode.PunctumInclinatum;
      else if (note.shape === NoteShape.Quilisma) glyph = GlyphCode.Quilisma;
      else glyph = GlyphCode.PunctumQuadratum;
    }

    this.build(ctxt).noteAt(note, glyph);

    this.finishLayout(ctxt);
  }
}

/*
 * Salicus
 */
export class Salicus extends Neume {
  positionMarkings() {
    // by default place episema below
    // fixme: is this correct?
    for (var i = 0; i < this.notes.length; i++)
      this.positionEpisemataBelow(this.notes[i]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    var first = this.notes[0];
    var second = this.notes[1];
    var third = this.notes[2];

    var builder = this.build(ctxt).noteAt(first, GlyphCode.PunctumQuadratum);

    // if the next note doesn't require a stem connector, then add a tad bit
    // of spacing here
    if (!(second.shapeModifiers & NoteShapeModifiers.Stemmed))
      builder.advanceBy(ctxt.intraNeumeSpacing);

    // second note is always an oriscus, which may or may not be stemmed
    // to the first
    builder.noteAt(second, GlyphCode.OriscusAsc);

    // third note can be a punctum quadratum or various liquescent forms
    if (third.liquescent & LiquescentType.Small)
      builder.noteAt(third, GlyphCode.TerminatingAscLiquescent);
    else if (third.liquescent === LiquescentType.Ascending)
      builder.noteAt(third, GlyphCode.PunctumQuadratumAscLiquescent);
    else if (third.liquescent === LiquescentType.Descending)
      builder.noteAt(third, GlyphCode.PunctumQuadratumDesLiquescent);
    else builder.virgaAt(third);

    this.finishLayout(ctxt);
  }
}

/*
 * Salicus Flexus
 */
export class SalicusFlexus extends Neume {
  positionMarkings() {
    var hasTopEpisema = this.positionTorculusMarkings(
      this.notes[1],
      this.notes[2],
      this.notes[3]
    );
    this.positionEpisemata(
      this.notes[0],
      hasTopEpisema ? MarkingPositionHint.Above : MarkingPositionHint.Below
    );
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    var first = this.notes[0];
    var second = this.notes[1];
    var third = this.notes[2];
    var fourth = this.notes[3];

    var builder = this.build(ctxt).noteAt(first, GlyphCode.PunctumQuadratum);

    // if the next note doesn't require a stem connector, then add a tad bit
    // of spacing here
    if (!(second.shapeModifiers & NoteShapeModifiers.Stemmed))
      builder.advanceBy(ctxt.intraNeumeSpacing);

    // second note is always an oriscus, which may or may not be stemmed
    // to the first
    builder.noteAt(second, GlyphCode.OriscusAsc);

    // third note can be a punctum quadratum or various liquescent forms,
    // ...based on note four though!
    if (fourth.liquescent & LiquescentType.Small)
      builder.noteAt(third, GlyphCode.PunctumQuadratumDesLiquescent);
    else builder.noteAt(third, GlyphCode.PunctumQuadratum);

    // finally, do the fourth note
    if (fourth.liquescent & LiquescentType.Small)
      builder.noteAt(fourth, GlyphCode.TerminatingDesLiquescent);
    else if (fourth.liquescent & LiquescentType.Ascending)
      builder.noteAt(fourth, GlyphCode.PunctumQuadratumAscLiquescent);
    else if (fourth.liquescent & LiquescentType.Descending)
      builder.noteAt(fourth, GlyphCode.PunctumQuadratumDesLiquescent);
    else builder.noteAt(fourth, GlyphCode.PunctumQuadratum);

    this.finishLayout(ctxt);
  }
}

/*
 * Scandicus
 */
export class Scandicus extends Neume {
  positionMarkings() {
    if (this.notes[2].shape === NoteShape.Virga) {
      this.positionPodatusMarkings(this.notes[0], this.notes[1]);
      this.positionEpisemataAbove(this.notes[2]);
    } else {
      this.positionEpisemataBelow(this.notes[0]);
      this.positionPodatusMarkings(this.notes[1], this.notes[2]);
    }
  }

  // if the third note shape is a virga, then the scadicus is rendered
  // as a podatus followed by a virga. Otherwise, it's rendered as a
  // punctum followed by a podatus...
  performLayout(ctxt) {
    super.performLayout(ctxt);

    var first = this.notes[0];
    var second = this.notes[1];
    var third = this.notes[2];

    if (third.shape === NoteShape.Virga) {
      this.build(ctxt).withPodatus(first, second).virgaAt(third);
    } else {
      this.build(ctxt)
        .noteAt(
          first,
          first.shape === NoteShape.Quilisma
            ? GlyphCode.Quilisma
            : GlyphCode.PunctumQuadratum
        )
        .withPodatus(second, third);
    }

    this.finishLayout(ctxt);
  }
}

/*
 * Scandicus Flexus
 */
export class ScandicusFlexus extends Neume {
  positionMarkings() {
    if (this.notes[2].shape === NoteShape.Virga) {
      this.positionPodatusMarkings(this.notes[0], this.notes[1]);
      this.positionClivisMarkings(this.notes[2], this.notes[3]);
    } else {
      this.positionEpisemataBelow(this.notes[0]);
      this.positionPodatusMarkings(this.notes[1], this.notes[2]);
      this.positionEpisemataAbove(this.notes[3]);
    }
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    var first = this.notes[0];
    var second = this.notes[1];
    var third = this.notes[2];
    var fourth = this.notes[3];

    if (third.shape === NoteShape.Virga) {
      this.build(ctxt)
        .withPodatus(first, second)
        .advanceBy(ctxt.intraNeumeSpacing)
        .withClivis(third, fourth);
    } else {
      var fourthGlyph = GlyphCode.PunctumQuadratum;

      if (fourth.liquescent & LiquescentType.Ascending)
        fourthGlyph = GlyphCode.PunctumQuadratumAscLiquescent;
      else if (fourth.liquescent & LiquescentType.Descending)
        fourthGlyph = GlyphCode.PunctumQuadratumDesLiquescent;

      this.build(ctxt)
        .noteAt(first, GlyphCode.PunctumQuadratum)
        .withPodatus(second, third)
        .advanceBy(ctxt.intraNeumeSpacing)
        .noteAt(fourth, fourthGlyph);
    }

    this.finishLayout(ctxt);
  }
}

/*
 * Torculus
 */
export class Torculus extends Neume {
  positionMarkings() {
    this.positionTorculusMarkings(this.notes[0], this.notes[1], this.notes[2]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    var note1 = this.notes[0];
    var note2 = this.notes[1];
    var note3 = this.notes[2];

    var glyph1, glyph3;

    if (note1.liquescent === LiquescentType.InitioDebilis)
      glyph1 = GlyphCode.TerminatingDesLiquescent;
    else if (note1.shape === NoteShape.Quilisma) glyph1 = GlyphCode.Quilisma;
    else glyph1 = GlyphCode.PunctumQuadratum;

    if (note3.liquescent & LiquescentType.Small)
      glyph3 = GlyphCode.TerminatingDesLiquescent;
    else if (note3.liquescent & LiquescentType.Ascending)
      glyph3 = GlyphCode.PunctumQuadratumAscLiquescent;
    else if (note3.liquescent & LiquescentType.Descending)
      glyph3 = GlyphCode.PunctumQuadratumDesLiquescent;
    else glyph3 = GlyphCode.PunctumQuadratum;

    this.build(ctxt)
      .noteAt(note1, glyph1)
      .noteAt(note2, GlyphCode.PunctumQuadratum)
      .noteAt(note3, glyph3);

    this.finishLayout(ctxt);
  }
}

/*
 * TorculusResupinus
 */
export class TorculusResupinus extends Neume {
  positionMarkings() {
    this.positionPorrectusMarkings(this.notes[1], this.notes[2], this.notes[3]);
    this.positionClivisEpisemata(this.notes[1], this.notes[0]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    var first = this.notes[0];
    var second = this.notes[1];
    var third = this.notes[2];
    var fourth = this.notes[3];

    var firstGlyph, fourthGlyph;

    if (first.liquescent === LiquescentType.InitioDebilis) {
      firstGlyph = GlyphCode.TerminatingDesLiquescent;
    } else if (first.shape === NoteShape.Quilisma)
      firstGlyph = GlyphCode.Quilisma;
    else firstGlyph = GlyphCode.PunctumQuadratum;

    if (fourth.liquescent & LiquescentType.Small)
      fourthGlyph = GlyphCode.TerminatingAscLiquescent;
    else if (third.liquescent & LiquescentType.Descending)
      fourthGlyph = GlyphCode.PunctumQuadratumDesLiquescent;
    else fourthGlyph = GlyphCode.PodatusUpper;

    this.build(ctxt)
      .noteAt(first, firstGlyph)
      .withPorrectusSwash(second, third)
      .noteAt(fourth, fourthGlyph);

    this.finishLayout(ctxt);
  }
}

/*
 * TorculusResupinusFlexus
 */
export class TorculusResupinusFlexus extends Neume {
  positionMarkings() {
    this.positionPorrectusFlexusMarkings(
      this.notes[1],
      this.notes[2],
      this.notes[3],
      this.notes[4]
    );
    this.positionClivisEpisemata(this.notes[1], this.notes[0]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    var first = this.notes[0];
    var second = this.notes[1];
    var third = this.notes[2];
    var fourth = this.notes[3];
    var fifth = this.notes[4];

    var firstGlyph,
      fourthGlyph = GlyphCode.PunctumQuadratum,
      fifthGlyph;

    if (first.liquescent === LiquescentType.InitioDebilis) {
      firstGlyph = GlyphCode.TerminatingDesLiquescent;
    } else if (first.shape === NoteShape.Quilisma)
      firstGlyph = GlyphCode.Quilisma;
    else firstGlyph = GlyphCode.PunctumQuadratum;

    if (fifth.liquescent & LiquescentType.Small) {
      fourthGlyph = GlyphCode.PunctumQuadratumDesLiquescent;
      fifthGlyph = GlyphCode.TerminatingDesLiquescent;
    } else if (fifth.liquescent & LiquescentType.Ascending)
      fifthGlyph = GlyphCode.PunctumQuadratumAscLiquescent;
    else if (fifth.liquescent & LiquescentType.Descending)
      fifthGlyph = GlyphCode.PunctumQuadratumDesLiquescent;
    else fifthGlyph = GlyphCode.PunctumQuadratum;

    this.build(ctxt)
      .noteAt(first, firstGlyph)
      .withPorrectusSwash(second, third)
      .noteAt(fourth, fourthGlyph)
      .noteAt(fifth, fifthGlyph);

    this.finishLayout(ctxt);
  }
}

/*
 * Tristropha
 *
 * For simplicity in implementation, Tristropha's have three notes in the object
 * structure. These technically must be the same pitch though (like the
 * Distropha and Bivirga).
 */
export class Tristropha extends Neume {
  positionMarkings() {
    this.positionEpisemataAbove(this.notes[0]);
    this.positionEpisemataAbove(this.notes[1]);
    this.positionEpisemataAbove(this.notes[2]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);
    let glyphCodes = this.notes.map((note) =>
      Apostropha.getNoteGlyphCode(note)
    );
    let glyphAdvance =
      glyphCodes[0] === GlyphCode.Stropha
        ? ctxt.intraNeumeSpacing / 2
        : ctxt.intraNeumeSpacing;

    this.build(ctxt)
      .noteAt(this.notes[0], glyphCodes[0])
      .advanceBy(glyphAdvance)
      .noteAt(this.notes[1], glyphCodes[1])
      .advanceBy(glyphAdvance)
      .noteAt(this.notes[2], glyphCodes[2]);

    this.finishLayout(ctxt);
  }
}

/*
 * Virga
 */
export class Virga extends Neume {
  positionMarkings() {
    this.positionEpisemataAbove(this.notes[0]);
  }

  performLayout(ctxt) {
    super.performLayout(ctxt);

    this.build(ctxt).virgaAt(this.notes[0]);

    this.finishLayout(ctxt);
  }
}



// WEBPACK FOOTER //
// ./src/Exsurge.Chant.Neumes.js","//
// Author(s):
// Benjamin Bloomfield <benjamin@sourceandsummit.com>
//
// Copyright (c) 2019
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the \"Software\"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//

import { Rect } from \"./Exsurge.Core.js\";
import {
  ChantLayoutElement, QuickSvg, Subtitle, Supertitle, TextLeftRight, Title
} from \"./Exsurge.Drawing.js\";

export class Titles extends ChantLayoutElement {
  constructor(
    ctxt,
    score,
    { supertitle, title, subtitle, textLeft, textRight } = {}
  ) {
    super();
    this.score = score;
    this.setSupertitle(ctxt, supertitle);
    this.setTitle(ctxt, title);
    this.setSubtitle(ctxt, subtitle);
    this.setTextLeft(ctxt, textLeft);
    this.setTextRight(ctxt, textRight);
  }

  setBoundsX(ctxt, elementName, width) {
    let element = this[elementName];
    switch (ctxt.textStyles[elementName].alignment) {
      case \"left\":
        element.textAnchor = \"start\";
        element.bounds.x = 0;
        break;
      case \"right\":
        element.textAnchor = \"end\";
        element.bounds.x = width;
        break;
      case \"center\":
      default:
        element.textAnchor = \"middle\";
        element.bounds.x = width / 2;
    }
  }

  /**
   * Lays out the titles, and returns their total height
   * @param  {ChantContext} ctxt
   * @return {number}      the tottal height of titles laid out
   */
  layoutTitles(ctxt, width) {
    this.bounds = new Rect(0, 0, 0, 0);
    let y = 0;
    if (this.supertitle) {
      this.supertitle.recalculateMetrics(ctxt);
      this.supertitle.setMaxWidth(ctxt, width);

      this.setBoundsX(ctxt, \"supertitle\", width);
      this.supertitle.bounds.y = y;
      this.bounds.union(this.supertitle.bounds);
      this.supertitle.bounds.y += this.supertitle.origin.y;
      y += this.supertitle.bounds.height + this.supertitle.padding(ctxt);
    }
    if (this.title) {
      if (y) y += this.title.padding(ctxt);
      this.title.recalculateMetrics(ctxt);
      this.title.setMaxWidth(ctxt, width);
      this.setBoundsX(ctxt, \"title\", width);
      this.title.bounds.y = y;
      this.bounds.union(this.title.bounds);
      this.title.bounds.y += this.title.origin.y;
      y += this.title.bounds.height + this.title.padding(ctxt);
    }
    if (this.subtitle) {
      if (y) y += this.subtitle.padding(ctxt);
      this.subtitle.recalculateMetrics(ctxt);
      this.subtitle.setMaxWidth(ctxt, width);
      this.setBoundsX(ctxt, \"subtitle\", width);
      this.subtitle.bounds.y = y;
      this.bounds.union(this.subtitle.bounds);
      this.subtitle.bounds.y += this.subtitle.origin.y;
      y += this.subtitle.bounds.height + this.subtitle.padding(ctxt);
    }
    let finalY = y,
      textLeft = this.score.overrideTextLeft || this.textLeft;
    if (textLeft) {
      textLeft.recalculateMetrics(ctxt);
      textLeft.bounds.y = y;
      this.bounds.union(textLeft.bounds);
      textLeft.bounds.y += textLeft.origin.y;
      finalY = y + textLeft.bounds.height + textLeft.padding(ctxt);
    }
    if (this.textRight) {
      this.textRight.recalculateMetrics(ctxt);
      this.textRight.bounds.x = width;
      this.textRight.bounds.y = y;
      this.bounds.union(this.textRight.bounds);
      this.textRight.bounds.y += this.textRight.origin.y;
      finalY = Math.max(
        finalY,
        y + this.textRight.bounds.height + this.textRight.padding(ctxt)
      );
    }
    return finalY;
  }

  setSupertitle(ctxt, supertitle) {
    this.supertitle = supertitle ? new Supertitle(ctxt, supertitle) : null;
  }
  setTitle(ctxt, title) {
    this.title = title ? new Title(ctxt, title) : null;
  }
  setSubtitle(ctxt, subtitle) {
    this.subtitle = subtitle ? new Subtitle(ctxt, subtitle) : null;
  }
  setTextLeft(ctxt, textLeft) {
    this.textLeft = textLeft
      ? new TextLeftRight(ctxt, textLeft, \"textLeft\")
      : null;
  }
  setTextRight(ctxt, textRight) {
    this.textRight = textRight
      ? new TextLeftRight(ctxt, textRight, \"textRight\")
      : null;
  }

  hasSupertitle(ctxt, supertitle) {
    return !!this.supertitle;
  }
  hasTitle(ctxt, title) {
    return !!this.title;
  }
  hasSubtitle(ctxt, subtitle) {
    return !!this.subtitle;
  }
  hasTextLeft(ctxt, textLeft) {
    return !!this.textLeft;
  }
  hasTextRight(ctxt, textRight) {
    return !!this.textRight;
  }

  draw(ctxt, scale = 1) {
    var canvasCtxt = ctxt.canvasCtxt;
    canvasCtxt.translate(this.bounds.x, this.bounds.y);

    for (let el of [
      this.supertitle,
      this.title,
      this.subtitle,
      this.score.overrideTextLeft || this.textLeft,
      this.textRight
    ]) {
      if (el) el.draw(ctxt, scale);
    }

    canvasCtxt.translate(-this.bounds.x, -this.bounds.y);
  }

  getInnerNodes(ctxt, functionName = \"createSvgNode\") {
    var nodes = [];

    for (let el of [
      this.supertitle,
      this.title,
      this.subtitle,
      this.score.overrideTextLeft || this.textLeft,
      this.textRight
    ]) {
      if (el) nodes.push(el[functionName](ctxt));
    }
    return nodes;
  }

  createSvgNode(ctxt) {
    var nodes = this.getInnerNodes(ctxt, \"createSvgNode\");

    var node = QuickSvg.createNode(\"g\", { class: \"Titles\" }, nodes);

    node.source = this;
    this.svg = node;

    return node;
  }

  createSvgTree(ctxt) {
    var nodes = this.getInnerNodes(ctxt, \"createSvgTree\");

    return QuickSvg.createSvgTree(
      \"g\",
      { class: \"Titles\", source: this },
      ...nodes
    );
  }

  createSvgFragment(ctxt) {
    var fragment = \"\";

    for (let el of [
      this.supertitle,
      this.title,
      this.subtitle,
      this.score.overrideTextLeft || this.textLeft,
      this.textRight
    ]) {
      if (el) fragment += el.createSvgFragment(ctxt);
    }

    fragment = QuickSvg.createFragment(\"g\", { class: \"Titles\" }, fragment);
    return fragment;
  }
}



// WEBPACK FOOTER //
// ./src/Exsurge.Titles.js"],"sourceRoot":""}
